# ! [doc = " Python bindings for bullish venue"] # ! [doc = ""] # ! [doc = " This module is automatically generated from the Rust source code."] # ! [doc = " Do not edit this file directly."] use pyo3 :: prelude ::*; use pyo3_asyncio ; use venues ; # [pyclass] # [derive (Clone)] pub enum OrderSide { Buy , Sell , } # [pyclass] # [derive (Clone)] pub enum OrderType { Limit , Market , } # [pyclass] # [derive (Clone)] pub enum TimeInForce { Gtc , Fok , Ioc , } # [pyclass] # [derive (Clone)] pub enum OrderStatus { Open , PartiallyFilled , Filled , Cancelled , Rejected , } # [pyclass] # [derive (Clone)] pub enum CandleInterval { OneMinute , FiveMinutes , FifteenMinutes , ThirtyMinutes , OneHour , FourHours , OneDay , OneWeek , OneMonth , } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn send_request <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_request () . await }) } } # [pymethods] impl RestClient { fn get_server_time <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_server_time () . await }) } } # [pyclass] # [derive (Clone)] pub struct CandleParams { inner : venues :: CandleParams , } # [pymethods] impl CandleParams { # [staticmethod] fn from_inner (inner : CandleParams) -> Self { Self { inner } } # [getter] fn interval (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . interval . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_candles <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_candles () . await }) } } # [pymethods] impl RestClient { fn get_nonce <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_nonce () . await }) } } # [pyclass] # [derive (Clone)] pub struct PublicTrade { inner : venues :: PublicTrade , } # [pymethods] impl PublicTrade { # [staticmethod] fn from_inner (inner : PublicTrade) -> Self { Self { inner } } # [getter] fn trade_id (& self) -> PyResult < String > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn is_taker (& self) -> PyResult < bool > { Ok (self . inner . is_taker . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < String > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn datetime (& self) -> PyResult < String > { Ok (self . inner . datetime . clone () . into ()) } # [getter] fn published_timestamp (& self) -> PyResult < String > { Ok (self . inner . published_timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct PublicTradesParams { inner : venues :: PublicTradesParams , } # [pymethods] impl PublicTradesParams { # [staticmethod] fn from_inner (inner : PublicTradesParams) -> Self { Self { inner } } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_public_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_public_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct Ticker { inner : venues :: Ticker , } # [pymethods] impl Ticker { # [staticmethod] fn from_inner (inner : Ticker) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn last_price (& self) -> PyResult < String > { Ok (self . inner . last_price . clone () . into ()) } # [getter] fn price_change (& self) -> PyResult < String > { Ok (self . inner . price_change . clone () . into ()) } # [getter] fn price_change_percent (& self) -> PyResult < String > { Ok (self . inner . price_change_percent . clone () . into ()) } # [getter] fn weighted_avg_price (& self) -> PyResult < String > { Ok (self . inner . weighted_avg_price . clone () . into ()) } # [getter] fn open_price (& self) -> PyResult < String > { Ok (self . inner . open_price . clone () . into ()) } # [getter] fn high_price (& self) -> PyResult < String > { Ok (self . inner . high_price . clone () . into ()) } # [getter] fn low_price (& self) -> PyResult < String > { Ok (self . inner . low_price . clone () . into ()) } # [getter] fn volume (& self) -> PyResult < String > { Ok (self . inner . volume . clone () . into ()) } # [getter] fn quote_volume (& self) -> PyResult < String > { Ok (self . inner . quote_volume . clone () . into ()) } # [getter] fn bid_price (& self) -> PyResult < String > { Ok (self . inner . bid_price . clone () . into ()) } # [getter] fn bid_qty (& self) -> PyResult < String > { Ok (self . inner . bid_qty . clone () . into ()) } # [getter] fn ask_price (& self) -> PyResult < String > { Ok (self . inner . ask_price . clone () . into ()) } # [getter] fn ask_qty (& self) -> PyResult < String > { Ok (self . inner . ask_qty . clone () . into ()) } # [getter] fn count (& self) -> PyResult < u64 > { Ok (self . inner . count . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn get_ticker <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_ticker () . await }) } } # [pymethods] impl RestClient { fn get_index_prices <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_index_prices () . await }) } fn get_index_price_by_symbol <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_index_price_by_symbol () . await }) } } # [pyclass] # [derive (Clone)] pub enum AssetStatus { Active , Inactive , Suspended , } # [pyclass] # [derive (Clone)] pub struct AssetsResponse { inner : venues :: AssetsResponse , } # [pymethods] impl AssetsResponse { # [staticmethod] fn from_inner (inner : AssetsResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SingleAssetResponse { inner : venues :: SingleAssetResponse , } # [pymethods] impl SingleAssetResponse { # [staticmethod] fn from_inner (inner : SingleAssetResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < PyObject > { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_assets <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_assets () . await }) } fn get_asset <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_asset () . await }) } } # [pyclass] # [derive (Clone)] pub enum MarketStatus { Active , Inactive , Suspended , } # [pyclass] # [derive (Clone)] pub enum MarketType { Spot , Futures , Options , Perpetual , } # [pyclass] # [derive (Clone)] pub struct MarketsResponse { inner : venues :: MarketsResponse , } # [pymethods] impl MarketsResponse { # [staticmethod] fn from_inner (inner : MarketsResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SingleMarketResponse { inner : venues :: SingleMarketResponse , } # [pymethods] impl SingleMarketResponse { # [staticmethod] fn from_inner (inner : SingleMarketResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < PyObject > { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_markets <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_markets () . await }) } fn get_market <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_market () . await }) } } # [pyclass] # [derive (Clone)] pub struct OrderbookEntry { inner : venues :: OrderbookEntry , } # [pymethods] impl OrderbookEntry { # [staticmethod] fn from_inner (inner : OrderbookEntry) -> Self { Self { inner } } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn entry_type (& self) -> PyResult < String > { Ok (self . inner . entry_type . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct HybridOrderbook { inner : venues :: HybridOrderbook , } # [pymethods] impl HybridOrderbook { # [staticmethod] fn from_inner (inner : HybridOrderbook) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn bids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . bids . clone () . into ()) } # [getter] fn asks (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . asks . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderbookParams { inner : venues :: OrderbookParams , } # [pymethods] impl OrderbookParams { # [staticmethod] fn from_inner (inner : OrderbookParams) -> Self { Self { inner } } # [getter] fn depth (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . depth . clone () . into ()) } # [getter] fn aggregate (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . aggregate . clone () . into ()) } } # [pymethods] impl RestClient { fn get_orderbook <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_orderbook () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateOrderRequest { inner : venues :: CreateOrderRequest , } # [pymethods] impl CreateOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn command_type (& self) -> PyResult < String > { Ok (self . inner . command_type . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn quote_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_amount . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < PyObject > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn allow_borrow (& self) -> PyResult < bool > { Ok (self . inner . allow_borrow . clone () . into ()) } # [getter] fn trading_account_id (& self) -> PyResult < String > { Ok (self . inner . trading_account_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateOrderResponse { inner : venues :: CreateOrderResponse , } # [pymethods] impl CreateOrderResponse { # [staticmethod] fn from_inner (inner : CreateOrderResponse) -> Self { Self { inner } } # [getter] fn message (& self) -> PyResult < String > { Ok (self . inner . message . clone () . into ()) } # [getter] fn request_id (& self) -> PyResult < String > { Ok (self . inner . request_id . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct Order { inner : venues :: Order , } # [pymethods] impl Order { # [staticmethod] fn from_inner (inner : Order) -> Self { Self { inner } } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < String > { Ok (self . inner . stop_price . clone () . into ()) } # [getter] fn average_fill_price (& self) -> PyResult < String > { Ok (self . inner . average_fill_price . clone () . into ()) } # [getter] fn allow_borrow (& self) -> PyResult < bool > { Ok (self . inner . allow_borrow . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn quantity_filled (& self) -> PyResult < String > { Ok (self . inner . quantity_filled . clone () . into ()) } # [getter] fn quote_amount (& self) -> PyResult < String > { Ok (self . inner . quote_amount . clone () . into ()) } # [getter] fn base_fee (& self) -> PyResult < String > { Ok (self . inner . base_fee . clone () . into ()) } # [getter] fn quote_fee (& self) -> PyResult < String > { Ok (self . inner . quote_fee . clone () . into ()) } # [getter] fn is_liquidation (& self) -> PyResult < bool > { Ok (self . inner . is_liquidation . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < PyObject > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn status_reason (& self) -> PyResult < String > { Ok (self . inner . status_reason . clone () . into ()) } # [getter] fn status_reason_code (& self) -> PyResult < String > { Ok (self . inner . status_reason_code . clone () . into ()) } # [getter] fn created_at_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . created_at_timestamp . clone () . into ()) } # [getter] fn created_at_datetime (& self) -> PyResult < String > { Ok (self . inner . created_at_datetime . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrdersParams { inner : venues :: GetOrdersParams , } # [pymethods] impl GetOrdersParams { # [staticmethod] fn from_inner (inner : GetOrdersParams) -> Self { Self { inner } } # [getter] fn trading_account_id (& self) -> PyResult < String > { Ok (self . inner . trading_account_id . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn side (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . side . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } } # [pymethods] impl RestClient { fn get_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_orders () . await }) } fn create_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_order () . await }) } fn get_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order () . await }) } } # [pyclass] # [derive (Clone)] pub enum TransactionStatus { Pending , Completed , Failed , Cancelled , } # [pyclass] # [derive (Clone)] pub enum TransactionType { Deposit , Withdrawal , Transfer , Trade , Fee , Interest , Rebate , Liquidation , } # [pyclass] # [derive (Clone)] pub struct GetWalletTransactionsParams { inner : venues :: GetWalletTransactionsParams , } # [pymethods] impl GetWalletTransactionsParams { # [staticmethod] fn from_inner (inner : GetWalletTransactionsParams) -> Self { Self { inner } } # [getter] fn trading_account_id (& self) -> PyResult < String > { Ok (self . inner . trading_account_id . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn transaction_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . transaction_type . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn page_size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page_size . clone () . into ()) } # [getter] fn page_token (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page_token . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct WalletTransactionsResponse { inner : venues :: WalletTransactionsResponse , } # [pymethods] impl WalletTransactionsResponse { # [staticmethod] fn from_inner (inner : WalletTransactionsResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } # [getter] fn next_page_token (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . next_page_token . clone () . into ()) } } # [pymethods] impl RestClient { fn get_wallet_transactions <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_wallet_transactions () . await }) } } # [pyclass] # [derive (Clone)] pub struct AssetBalance { inner : venues :: AssetBalance , } # [pymethods] impl AssetBalance { # [staticmethod] fn from_inner (inner : AssetBalance) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn balance (& self) -> PyResult < String > { Ok (self . inner . balance . clone () . into ()) } # [getter] fn available_balance (& self) -> PyResult < String > { Ok (self . inner . available_balance . clone () . into ()) } # [getter] fn locked_balance (& self) -> PyResult < String > { Ok (self . inner . locked_balance . clone () . into ()) } # [getter] fn borrowed_balance (& self) -> PyResult < String > { Ok (self . inner . borrowed_balance . clone () . into ()) } # [getter] fn interest_owed (& self) -> PyResult < String > { Ok (self . inner . interest_owed . clone () . into ()) } # [getter] fn net_balance (& self) -> PyResult < String > { Ok (self . inner . net_balance . clone () . into ()) } # [getter] fn usd_value (& self) -> PyResult < String > { Ok (self . inner . usd_value . clone () . into ()) } # [getter] fn can_borrow (& self) -> PyResult < bool > { Ok (self . inner . can_borrow . clone () . into ()) } # [getter] fn can_collateralize (& self) -> PyResult < bool > { Ok (self . inner . can_collateralize . clone () . into ()) } # [getter] fn collateral_factor (& self) -> PyResult < String > { Ok (self . inner . collateral_factor . clone () . into ()) } # [getter] fn borrow_limit (& self) -> PyResult < String > { Ok (self . inner . borrow_limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AssetBalancesResponse { inner : venues :: AssetBalancesResponse , } # [pymethods] impl AssetBalancesResponse { # [staticmethod] fn from_inner (inner : AssetBalancesResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SingleAssetBalanceResponse { inner : venues :: SingleAssetBalanceResponse , } # [pymethods] impl SingleAssetBalanceResponse { # [staticmethod] fn from_inner (inner : SingleAssetBalanceResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < PyObject > { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_asset_balances <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_asset_balances () . await }) } fn get_asset_balance <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_asset_balance () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn get_jwt_token <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_jwt_token () . await }) } fn send_authenticated_request <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_authenticated_request () . await }) } fn send_signed_request <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_signed_request () . await }) } } # [pyclass] # [derive (Clone)] pub struct TradingAccount { inner : venues :: TradingAccount , } # [pymethods] impl TradingAccount { # [staticmethod] fn from_inner (inner : TradingAccount) -> Self { Self { inner } } # [getter] fn trading_account_id (& self) -> PyResult < String > { Ok (self . inner . trading_account_id . clone () . into ()) } # [getter] fn total_collateral_usd (& self) -> PyResult < String > { Ok (self . inner . total_collateral_usd . clone () . into ()) } # [getter] fn total_borrowed_usd (& self) -> PyResult < String > { Ok (self . inner . total_borrowed_usd . clone () . into ()) } # [getter] fn defaulted_margin_usd (& self) -> PyResult < String > { Ok (self . inner . defaulted_margin_usd . clone () . into ()) } # [getter] fn risk_limit_usd (& self) -> PyResult < String > { Ok (self . inner . risk_limit_usd . clone () . into ()) } # [getter] fn total_liabilities_usd (& self) -> PyResult < String > { Ok (self . inner . total_liabilities_usd . clone () . into ()) } # [getter] fn is_primary_account (& self) -> PyResult < bool > { Ok (self . inner . is_primary_account . clone () . into ()) } # [getter] fn is_borrowing (& self) -> PyResult < bool > { Ok (self . inner . is_borrowing . clone () . into ()) } # [getter] fn is_lending (& self) -> PyResult < bool > { Ok (self . inner . is_lending . clone () . into ()) } # [getter] fn is_defaulted (& self) -> PyResult < bool > { Ok (self . inner . is_defaulted . clone () . into ()) } # [getter] fn rate_limit_token (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . rate_limit_token . clone () . into ()) } # [getter] fn trade_fee_rate (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trade_fee_rate . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TradeFeeRate { inner : venues :: TradeFeeRate , } # [pymethods] impl TradeFeeRate { # [staticmethod] fn from_inner (inner : TradeFeeRate) -> Self { Self { inner } } # [getter] fn maker_fee_rate (& self) -> PyResult < String > { Ok (self . inner . maker_fee_rate . clone () . into ()) } # [getter] fn taker_fee_rate (& self) -> PyResult < String > { Ok (self . inner . taker_fee_rate . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TradingAccountsResponse { inner : venues :: TradingAccountsResponse , } # [pymethods] impl TradingAccountsResponse { # [staticmethod] fn from_inner (inner : TradingAccountsResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_trading_accounts <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_trading_accounts () . await }) } fn get_trading_account <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_trading_account () . await }) } } # [pyclass] # [derive (Clone)] pub struct Trade { inner : venues :: Trade , } # [pymethods] impl Trade { # [staticmethod] fn from_inner (inner : Trade) -> Self { Self { inner } } # [getter] fn trade_id (& self) -> PyResult < String > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn quote_amount (& self) -> PyResult < String > { Ok (self . inner . quote_amount . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn base_fee (& self) -> PyResult < String > { Ok (self . inner . base_fee . clone () . into ()) } # [getter] fn quote_fee (& self) -> PyResult < String > { Ok (self . inner . quote_fee . clone () . into ()) } # [getter] fn is_liquidation (& self) -> PyResult < bool > { Ok (self . inner . is_liquidation . clone () . into ()) } # [getter] fn is_maker (& self) -> PyResult < bool > { Ok (self . inner . is_maker . clone () . into ()) } # [getter] fn created_at_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . created_at_timestamp . clone () . into ()) } # [getter] fn created_at_datetime (& self) -> PyResult < String > { Ok (self . inner . created_at_datetime . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetTradesParams { inner : venues :: GetTradesParams , } # [pymethods] impl GetTradesParams { # [staticmethod] fn from_inner (inner : GetTradesParams) -> Self { Self { inner } } # [getter] fn trading_account_id (& self) -> PyResult < String > { Ok (self . inner . trading_account_id . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn side (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . side . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } } # [pymethods] impl RestClient { fn get_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_trades () . await }) } fn get_trade <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_trade () . await }) } } # [pyclass] # [derive (Clone)] pub struct ApiError { inner : venues :: ApiError , } # [pymethods] impl ApiError { # [staticmethod] fn from_inner (inner : ApiError) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < String > { Ok (self . inner . code . clone () . into ()) } # [getter] fn message (& self) -> PyResult < String > { Ok (self . inner . message . clone () . into ()) } # [getter] fn details (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . details . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ErrorResponse { inner : venues :: ErrorResponse , } # [pymethods] impl ErrorResponse { # [staticmethod] fn from_inner (inner : ErrorResponse) -> Self { Self { inner } } # [getter] fn error (& self) -> PyResult < PyObject > { Ok (self . inner . error . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub enum EndpointType { PublicMarkets , PublicAssets , PublicTicker , PublicOrderbook , PublicTrades , PublicCandles , PublicTime , PublicOther , PrivateLogin , PrivateTradingAccounts , PrivateOrders , PrivateTrades , PrivatePositions , PrivateAssetBalances , PrivateWalletTransactions , PrivateOther , } # [pyclass] # [derive (Clone)] pub struct RateLimit { inner : venues :: RateLimit , } # [pymethods] impl RateLimit { # [staticmethod] fn from_inner (inner : RateLimit) -> Self { Self { inner } } # [getter] fn max_requests (& self) -> PyResult < u64 > { Ok (self . inner . max_requests . clone () . into ()) } # [getter] fn window (& self) -> PyResult < PyObject > { Ok (self . inner . window . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RateLimiter { inner : venues :: RateLimiter , } # [pymethods] impl RateLimiter { # [staticmethod] fn from_inner (inner : RateLimiter) -> Self { Self { inner } } } # [doc = " Create the Python module for bullish"] pub fn create_module (py : Python) -> PyResult <& PyModule > { let m = PyModule :: new (py , "bullish") ?; Ok (m) }