# ! [doc = " Python bindings for deribit venue"] # ! [doc = ""] # ! [doc = " This module is automatically generated from the Rust source code."] # ! [doc = " Do not edit this file directly."] use pyo3 :: prelude ::*; use pyo3_asyncio ; use venues ; # [pyclass] # [derive (Clone)] pub struct JsonRpcResult { inner : venues :: JsonRpcResult , } # [pymethods] impl JsonRpcResult { # [staticmethod] fn from_inner (inner : JsonRpcResult) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < u64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn jsonrpc (& self) -> PyResult < String > { Ok (self . inner . jsonrpc . clone () . into ()) } # [getter] fn result (& self) -> PyResult < PyObject > { Ok (self . inner . result . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub enum DeribitMessage { Request , Response , } # [pyclass] # [derive (Clone)] pub struct JsonRpcRequest { inner : venues :: JsonRpcRequest , } # [pymethods] impl JsonRpcRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn jsonrpc (& self) -> PyResult < String > { Ok (self . inner . jsonrpc . clone () . into ()) } # [getter] fn id (& self) -> PyResult < u64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn method (& self) -> PyResult < String > { Ok (self . inner . method . clone () . into ()) } # [getter] fn params (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . params . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct JsonRpcResponse { inner : venues :: JsonRpcResponse , } # [pymethods] impl JsonRpcResponse { # [staticmethod] fn from_inner (inner : JsonRpcResponse) -> Self { Self { inner } } # [getter] fn jsonrpc (& self) -> PyResult < String > { Ok (self . inner . jsonrpc . clone () . into ()) } # [getter] fn id (& self) -> PyResult < u64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn result (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . result . clone () . into ()) } # [getter] fn error (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . error . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct JsonRpcError { inner : venues :: JsonRpcError , } # [pymethods] impl JsonRpcError { # [staticmethod] fn from_inner (inner : JsonRpcError) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < i64 > { Ok (self . inner . code . clone () . into ()) } # [getter] fn message (& self) -> PyResult < String > { Ok (self . inner . message . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl JsonRpcRequest { fn disable_heartbeat (& self) -> PyResult < () > { self . inner . disable_heartbeat () ; Ok (()) } fn private_trading (& self) -> PyResult < () > { self . inner . private_trading () ; Ok (()) } } # [pyclass] # [derive (Clone)] pub enum Currency { BTC , ETH , STETH , ETHW , USDC , USDT , EURR , MATIC , SOL , XRP , USYC , PAXG , BNB , USDE , USD , BUIDL , Any , } # [pyclass] # [derive (Clone)] pub enum CurrencyPair { BtcUsd , EthUsd , AdaUsdc , AlgoUsdc , AvaxUsdc , BchUsdc , BnbUsdc , BtcUsdc , BtcdvolUsdc , BuidlUsdc , DogeUsdc , DotUsdc , EurrUsdc , EthUsdc , EthdvolUsdc , LinkUsdc , LtcUsdc , NearUsdc , PaxgUsdc , ShibUsdc , SolUsdc , StethUsdc , TrumpUsdc , TrxUsdc , UniUsdc , UsdeUsdc , UsycUsdc , XrpUsdc , BtcUsdt , EthUsdt , EurrUsdt , SolUsdt , StethUsdt , UsdcUsdt , UsdeUsdt , BtcEurr , BtcUsde , BtcUsyc , EthBtc , EthEurr , EthUsde , EthUsyc , StethEth , PaxgBtc , } # [pyclass] # [derive (Clone)] pub enum ComboState { RFQ , Active , Inactive , } # [pyclass] # [derive (Clone)] pub enum WithdrawalPriority { Insane , ExtremeHigh , VeryHigh , High , Mid , Low , VeryLow , } # [pyclass] # [derive (Clone)] pub enum WithdrawalState { Unconfirmed , Confirmed , Cancelled , Completed , Interrupted , Rejected , } # [pyclass] # [derive (Clone)] pub enum AddressBookType { Transfer , Withdrawal , DepositSource , } # [pyclass] # [derive (Clone)] pub enum OrderState { Open , Filled , Rejected , Cancelled , Untriggered , Triggered , } # [pyclass] # [derive (Clone)] pub enum AddressStatus { AdminLocked , Waiting , Confirmed , Ready , } # [pyclass] # [derive (Clone)] pub enum OrderDirection { Buy , Sell , } # [pyclass] # [derive (Clone)] pub enum CancelReason { UserRequest , Autoliquidation , CancelOnDisconnect , RiskMitigation , PmeRiskReduction , PmeAccountLocked , PositionLocked , MmpTrigger , MmpConfigCurtailment , EditPostOnlyReject , OcoOtherClosed , OtoPrimaryClosed , Settlement , } # [pyclass] # [derive (Clone)] pub enum AdvancedType { Usd , Implv , } # [pyclass] # [derive (Clone)] pub enum TriggerType { IndexPrice , MarkPrice , LastPrice , } # [pyclass] # [derive (Clone)] pub enum InstrumentKind { Future , Option , Spot , FutureCombo , OptionCombo , Combo , Any , } # [pyclass] # [derive (Clone)] pub enum OrderType { All , Limit , TriggerAll , Stop , Take , TrailingStop , } # [pyclass] # [derive (Clone)] pub enum Sorting { Asc , Desc , Default , } # [pyclass] # [derive (Clone)] pub enum TickDirection { PlusTick , ZeroPlusTick , MinusTick , ZeroMinusTick , } # [pyclass] # [derive (Clone)] pub enum Liquidity { Maker , Taker , } # [pyclass] # [derive (Clone)] pub enum TradeOrderType { Limit , Market , Liquidation , } # [pyclass] # [derive (Clone)] pub enum LiquidationSide { Maker , Taker , Both , } # [pyclass] # [derive (Clone)] pub enum DepositState { Pending , Completed , Rejected , Replaced , } # [pyclass] # [derive (Clone)] pub enum ClearanceState { InProgress , PendingAdminDecision , PendingUserInput , Success , Failed , Cancelled , RefundInitiated , Refunded , } # [pyclass] # [derive (Clone)] pub enum OpenOrdersOrderType { All , Limit , TriggerAll , StopAll , StopLimit , StopMarket , TakeAll , TakeLimit , TakeMarket , TrailingAll , TrailingStop , } # [pyclass] # [derive (Clone)] pub enum TimeInForce { GoodTilCancelled , GoodTilDay , FillOrKill , ImmediateOrCancel , } # [pyclass] # [derive (Clone)] pub enum TriggerFillCondition { FirstHit , CompleteFill , Incremental , } # [pyclass] # [derive (Clone)] pub enum PlatformLockStatus { AllLocked , PartialLocked , Unlocked , } # [pyclass] # [derive (Clone)] pub enum Resolution { OneSecond , OneMinute , OneHour , TwelveHours , OneDay , } # [pyclass] # [derive (Clone)] pub enum InstrumentType { Linear , Reversed , } # [pyclass] # [derive (Clone)] pub enum OptionType { Call , Put , } # [pyclass] # [derive (Clone)] pub enum FutureType { Reversed , Linear , } # [pyclass] # [derive (Clone)] pub struct PrivateWebSocketClient { inner : venues :: PrivateWebSocketClient , } # [pymethods] impl PrivateWebSocketClient { # [staticmethod] fn from_inner (inner : PrivateWebSocketClient) -> Self { Self { inner } } } # [pymethods] impl PrivateWebSocketClient { fn next_request_id (& self) -> PyResult < () > { self . inner . next_request_id () ; Ok (()) } fn is_connected (& self) -> PyResult < () > { self . inner . is_connected () ; Ok (()) } fn send_serializable <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_serializable () . await }) } fn send_and_receive <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_and_receive () . await }) } } # [pyclass] # [derive (Clone)] pub struct UnsubscribeAllRequest { inner : venues :: UnsubscribeAllRequest , } # [pymethods] impl UnsubscribeAllRequest { # [staticmethod] fn from_inner (inner : UnsubscribeAllRequest) -> Self { Self { inner } } } # [pyclass] # [derive (Clone)] pub struct UnsubscribeAllResponse { inner : venues :: UnsubscribeAllResponse , } # [pymethods] impl UnsubscribeAllResponse { # [staticmethod] fn from_inner (inner : UnsubscribeAllResponse) -> Self { Self { inner } } # [getter] fn result (& self) -> PyResult < String > { Ok (self . inner . result . clone () . into ()) } } # [pymethods] impl PrivateWebSocketClient { fn unsubscribe_all <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . unsubscribe_all () . await }) } } # [pyclass] # [derive (Clone)] pub struct HelloRequest { inner : venues :: HelloRequest , } # [pymethods] impl HelloRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn client_name (& self) -> PyResult < String > { Ok (self . inner . client_name . clone () . into ()) } # [getter] fn client_version (& self) -> PyResult < String > { Ok (self . inner . client_version . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct HelloResponse { inner : venues :: HelloResponse , } # [pymethods] impl HelloResponse { # [staticmethod] fn from_inner (inner : HelloResponse) -> Self { Self { inner } } # [getter] fn result (& self) -> PyResult < PyObject > { Ok (self . inner . result . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct HelloResult { inner : venues :: HelloResult , } # [pymethods] impl HelloResult { # [staticmethod] fn from_inner (inner : HelloResult) -> Self { Self { inner } } # [getter] fn version (& self) -> PyResult < String > { Ok (self . inner . version . clone () . into ()) } } # [pymethods] impl PrivateWebSocketClient { fn hello <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . hello () . await }) } } # [pyclass] # [derive (Clone)] pub struct SubscribeRequest { inner : venues :: SubscribeRequest , } # [pymethods] impl SubscribeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn channels (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . channels . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SubscribeResponse { inner : venues :: SubscribeResponse , } # [pymethods] impl SubscribeResponse { # [staticmethod] fn from_inner (inner : SubscribeResponse) -> Self { Self { inner } } # [getter] fn result (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . result . clone () . into ()) } } # [pymethods] impl PrivateWebSocketClient { fn subscribe <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . subscribe () . await }) } } # [pyclass] # [derive (Clone)] pub struct UnsubscribeRequest { inner : venues :: UnsubscribeRequest , } # [pymethods] impl UnsubscribeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn channels (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . channels . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnsubscribeResponse { inner : venues :: UnsubscribeResponse , } # [pymethods] impl UnsubscribeResponse { # [staticmethod] fn from_inner (inner : UnsubscribeResponse) -> Self { Self { inner } } # [getter] fn result (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . result . clone () . into ()) } } # [pymethods] impl PrivateWebSocketClient { fn unsubscribe <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . unsubscribe () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetComboDetailsRequest { inner : venues :: GetComboDetailsRequest , } # [pymethods] impl GetComboDetailsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn combo_id (& self) -> PyResult < String > { Ok (self . inner . combo_id . clone () . into ()) } } # [pymethods] impl RestClient { fn get_combo_details <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_combo_details () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetMarkPriceHistoryRequest { inner : venues :: GetMarkPriceHistoryRequest , } # [pymethods] impl GetMarkPriceHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn start_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . start_timestamp . clone () . into ()) } # [getter] fn end_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . end_timestamp . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct MarkPriceEntry { inner : venues :: MarkPriceEntry , } # [pymethods] impl MarkPriceEntry { # [staticmethod] fn from_inner (inner : MarkPriceEntry) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn get_mark_price_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_mark_price_history () . await }) } } # [pyclass] # [derive (Clone)] pub enum ExpirationsCurrency { BTC , ETH , USDC , USDT , Any , Grouped , } # [pyclass] # [derive (Clone)] pub enum ExpirationsInstrumentKind { Future , Option , Any , } # [pyclass] # [derive (Clone)] pub struct GetExpirationsRequest { inner : venues :: GetExpirationsRequest , } # [pymethods] impl GetExpirationsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . kind . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetExpirationsResult { inner : venues :: GetExpirationsResult , } # [pymethods] impl GetExpirationsResult { # [staticmethod] fn from_inner (inner : GetExpirationsResult) -> Self { Self { inner } } # [getter] fn future (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . future . clone () . into ()) } # [getter] fn option (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . option . clone () . into ()) } } # [pymethods] impl RestClient { fn get_expirations <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_expirations () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetContractSizeRequest { inner : venues :: GetContractSizeRequest , } # [pymethods] impl GetContractSizeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetContractSizeResult { inner : venues :: GetContractSizeResult , } # [pymethods] impl GetContractSizeResult { # [staticmethod] fn from_inner (inner : GetContractSizeResult) -> Self { Self { inner } } # [getter] fn contract_size (& self) -> PyResult < f64 > { Ok (self . inner . contract_size . clone () . into ()) } } # [pymethods] impl RestClient { fn get_contract_size <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_contract_size () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetTradingviewChartDataRequest { inner : venues :: GetTradingviewChartDataRequest , } # [pymethods] impl GetTradingviewChartDataRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < PyObject > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn start_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . start_timestamp . clone () . into ()) } # [getter] fn end_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . end_timestamp . clone () . into ()) } # [getter] fn resolution (& self) -> PyResult < u64 > { Ok (self . inner . resolution . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetTradingviewChartDataResult { inner : venues :: GetTradingviewChartDataResult , } # [pymethods] impl GetTradingviewChartDataResult { # [staticmethod] fn from_inner (inner : GetTradingviewChartDataResult) -> Self { Self { inner } } # [getter] fn open (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . open . clone () . into ()) } # [getter] fn high (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . high . clone () . into ()) } # [getter] fn low (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . low . clone () . into ()) } # [getter] fn close (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . close . clone () . into ()) } # [getter] fn volume (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . volume . clone () . into ()) } # [getter] fn timestamps (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . timestamps . clone () . into ()) } } # [pymethods] impl RestClient { fn get_tradingview_chart_data <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_tradingview_chart_data () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetVolatilityIndexDataRequest { inner : venues :: GetVolatilityIndexDataRequest , } # [pymethods] impl GetVolatilityIndexDataRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn start_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . start_timestamp . clone () . into ()) } # [getter] fn end_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . end_timestamp . clone () . into ()) } # [getter] fn resolution (& self) -> PyResult < PyObject > { Ok (self . inner . resolution . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetVolatilityIndexDataResult { inner : venues :: GetVolatilityIndexDataResult , } # [pymethods] impl GetVolatilityIndexDataResult { # [staticmethod] fn from_inner (inner : GetVolatilityIndexDataResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } # [getter] fn continuation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . continuation . clone () . into ()) } } # [pymethods] impl RestClient { fn get_volatility_index_data <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_volatility_index_data () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOrderBookByInstrumentIdRequest { inner : venues :: GetOrderBookByInstrumentIdRequest , } # [pymethods] impl GetOrderBookByInstrumentIdRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_id (& self) -> PyResult < String > { Ok (self . inner . instrument_id . clone () . into ()) } # [getter] fn depth (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . depth . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderBookEntry { inner : venues :: OrderBookEntry , } # [pymethods] impl OrderBookEntry { # [staticmethod] fn from_inner (inner : OrderBookEntry) -> Self { Self { inner } } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderBookByInstrumentIdResult { inner : venues :: GetOrderBookByInstrumentIdResult , } # [pymethods] impl GetOrderBookByInstrumentIdResult { # [staticmethod] fn from_inner (inner : GetOrderBookByInstrumentIdResult) -> Self { Self { inner } } # [getter] fn bids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . bids . clone () . into ()) } # [getter] fn asks (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . asks . clone () . into ()) } # [getter] fn best_bid_price (& self) -> PyResult < f64 > { Ok (self . inner . best_bid_price . clone () . into ()) } # [getter] fn best_ask_price (& self) -> PyResult < f64 > { Ok (self . inner . best_ask_price . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_book_by_instrument_id <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_book_by_instrument_id () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetComboIdsRequest { inner : venues :: GetComboIdsRequest , } # [pymethods] impl GetComboIdsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn state (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . state . clone () . into ()) } } # [pymethods] impl RestClient { fn get_combo_ids <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_combo_ids () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } # [getter] fn base_url (& self) -> PyResult < PyObject > { Ok (self . inner . base_url . clone () . into ()) } # [getter] fn client (& self) -> PyResult < PyObject > { Ok (self . inner . client . clone () . into ()) } # [getter] fn rate_limiter (& self) -> PyResult < PyObject > { Ok (self . inner . rate_limiter . clone () . into ()) } } # [pymethods] impl RestClient { fn send_request <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_request () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetDeliveryPricesRequest { inner : venues :: GetDeliveryPricesRequest , } # [pymethods] impl GetDeliveryPricesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn index_name (& self) -> PyResult < PyObject > { Ok (self . inner . index_name . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetDeliveryPricesResult { inner : venues :: GetDeliveryPricesResult , } # [pymethods] impl GetDeliveryPricesResult { # [staticmethod] fn from_inner (inner : GetDeliveryPricesResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } # [getter] fn records_total (& self) -> PyResult < u64 > { Ok (self . inner . records_total . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_prices <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_prices () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetIndexPriceNamesRequest { inner : venues :: GetIndexPriceNamesRequest , } # [pymethods] impl GetIndexPriceNamesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } } # [pymethods] impl RestClient { fn get_index_price_names <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_index_price_names () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetBookSummaryByCurrencyRequest { inner : venues :: GetBookSummaryByCurrencyRequest , } # [pymethods] impl GetBookSummaryByCurrencyRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . kind . clone () . into ()) } } # [pymethods] impl RestClient { fn get_book_summary_by_currency <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_book_summary_by_currency () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetFundingChartDataRequest { inner : venues :: GetFundingChartDataRequest , } # [pymethods] impl GetFundingChartDataRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn length (& self) -> PyResult < String > { Ok (self . inner . length . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FundingChartDataPoint { inner : venues :: FundingChartDataPoint , } # [pymethods] impl FundingChartDataPoint { # [staticmethod] fn from_inner (inner : FundingChartDataPoint) -> Self { Self { inner } } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn interest_8h (& self) -> PyResult < f64 > { Ok (self . inner . interest_8h . clone () . into ()) } # [getter] fn index_price (& self) -> PyResult < f64 > { Ok (self . inner . index_price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetFundingChartDataResult { inner : venues :: GetFundingChartDataResult , } # [pymethods] impl GetFundingChartDataResult { # [staticmethod] fn from_inner (inner : GetFundingChartDataResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_funding_chart_data <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_funding_chart_data () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetIndexPriceRequest { inner : venues :: GetIndexPriceRequest , } # [pymethods] impl GetIndexPriceRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn index_name (& self) -> PyResult < String > { Ok (self . inner . index_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetIndexPriceResult { inner : venues :: GetIndexPriceResult , } # [pymethods] impl GetIndexPriceResult { # [staticmethod] fn from_inner (inner : GetIndexPriceResult) -> Self { Self { inner } } # [getter] fn index_price (& self) -> PyResult < f64 > { Ok (self . inner . index_price . clone () . into ()) } # [getter] fn estimated_delivery_price (& self) -> PyResult < f64 > { Ok (self . inner . estimated_delivery_price . clone () . into ()) } } # [pymethods] impl RestClient { fn get_index_price <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_index_price () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetLastSettlementsByInstrumentRequest { inner : venues :: GetLastSettlementsByInstrumentRequest , } # [pymethods] impl GetLastSettlementsByInstrumentRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SettlementEntry { inner : venues :: SettlementEntry , } # [pymethods] impl SettlementEntry { # [staticmethod] fn from_inner (inner : SettlementEntry) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn settlement_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . settlement_price . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetLastSettlementsByInstrumentResult { inner : venues :: GetLastSettlementsByInstrumentResult , } # [pymethods] impl GetLastSettlementsByInstrumentResult { # [staticmethod] fn from_inner (inner : GetLastSettlementsByInstrumentResult) -> Self { Self { inner } } # [getter] fn settlements (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . settlements . clone () . into ()) } } # [pymethods] impl RestClient { fn get_last_settlements_by_instrument <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_last_settlements_by_instrument () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetHistoricalVolatilityRequest { inner : venues :: GetHistoricalVolatilityRequest , } # [pymethods] impl GetHistoricalVolatilityRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn end_timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct HistoricalVolatilityDataPoint { inner : venues :: HistoricalVolatilityDataPoint , } # [pymethods] impl HistoricalVolatilityDataPoint { # [staticmethod] fn from_inner (inner : HistoricalVolatilityDataPoint) -> Self { Self { inner } } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn value (& self) -> PyResult < f64 > { Ok (self . inner . value . clone () . into ()) } } # [pymethods] impl RestClient { fn get_historical_volatility <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_historical_volatility () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetLastTradesByCurrencyRequest { inner : venues :: GetLastTradesByCurrencyRequest , } # [pymethods] impl GetLastTradesByCurrencyRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < PyObject > { Ok (self . inner . kind . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn sorting (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sorting . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TradeEntry { inner : venues :: TradeEntry , } # [pymethods] impl TradeEntry { # [staticmethod] fn from_inner (inner : TradeEntry) -> Self { Self { inner } } # [getter] fn trade_id (& self) -> PyResult < String > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < String > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn index_price (& self) -> PyResult < f64 > { Ok (self . inner . index_price . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn trade_seq (& self) -> PyResult < u64 > { Ok (self . inner . trade_seq . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < f64 > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn tick_direction (& self) -> PyResult < u64 > { Ok (self . inner . tick_direction . clone () . into ()) } # [getter] fn contracts (& self) -> PyResult < f64 > { Ok (self . inner . contracts . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetLastTradesByCurrencyResult { inner : venues :: GetLastTradesByCurrencyResult , } # [pymethods] impl GetLastTradesByCurrencyResult { # [staticmethod] fn from_inner (inner : GetLastTradesByCurrencyResult) -> Self { Self { inner } } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } # [getter] fn has_more (& self) -> PyResult < bool > { Ok (self . inner . has_more . clone () . into ()) } } # [pymethods] impl RestClient { fn get_last_trades_by_currency <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_last_trades_by_currency () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetIndexRequest { inner : venues :: GetIndexRequest , } # [pymethods] impl GetIndexRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn index_name (& self) -> PyResult < String > { Ok (self . inner . index_name . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetIndexResult { inner : venues :: GetIndexResult , } # [pymethods] impl GetIndexResult { # [staticmethod] fn from_inner (inner : GetIndexResult) -> Self { Self { inner } } # [getter] fn estimated_delivery_price (& self) -> PyResult < f64 > { Ok (self . inner . estimated_delivery_price . clone () . into ()) } # [getter] fn currency_price (& self) -> PyResult < PyObject > { Ok (self . inner . currency_price . clone () . into ()) } } # [pymethods] impl RestClient { fn get_index <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_index () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetFundingRateHistoryRequest { inner : venues :: GetFundingRateHistoryRequest , } # [pymethods] impl GetFundingRateHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn start_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . start_timestamp . clone () . into ()) } # [getter] fn end_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . end_timestamp . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FundingRateHistoryData { inner : venues :: FundingRateHistoryData , } # [pymethods] impl FundingRateHistoryData { # [staticmethod] fn from_inner (inner : FundingRateHistoryData) -> Self { Self { inner } } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn interest_8h (& self) -> PyResult < f64 > { Ok (self . inner . interest_8h . clone () . into ()) } # [getter] fn interest_1h (& self) -> PyResult < f64 > { Ok (self . inner . interest_1h . clone () . into ()) } # [getter] fn index_price (& self) -> PyResult < f64 > { Ok (self . inner . index_price . clone () . into ()) } # [getter] fn prev_index_price (& self) -> PyResult < f64 > { Ok (self . inner . prev_index_price . clone () . into ()) } } # [pymethods] impl RestClient { fn get_funding_rate_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_funding_rate_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetAprHistoryRequest { inner : venues :: GetAprHistoryRequest , } # [pymethods] impl GetAprHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn before (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . before . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AprHistoryData { inner : venues :: AprHistoryData , } # [pymethods] impl AprHistoryData { # [staticmethod] fn from_inner (inner : AprHistoryData) -> Self { Self { inner } } # [getter] fn apr (& self) -> PyResult < f64 > { Ok (self . inner . apr . clone () . into ()) } # [getter] fn day (& self) -> PyResult < u64 > { Ok (self . inner . day . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetAprHistoryResult { inner : venues :: GetAprHistoryResult , } # [pymethods] impl GetAprHistoryResult { # [staticmethod] fn from_inner (inner : GetAprHistoryResult) -> Self { Self { inner } } # [getter] fn continuation (& self) -> PyResult < String > { Ok (self . inner . continuation . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_apr_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_apr_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOrderBookRequest { inner : venues :: GetOrderBookRequest , } # [pymethods] impl GetOrderBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn depth (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . depth . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderBookResult { inner : venues :: GetOrderBookResult , } # [pymethods] impl GetOrderBookResult { # [staticmethod] fn from_inner (inner : GetOrderBookResult) -> Self { Self { inner } } # [getter] fn bids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . bids . clone () . into ()) } # [getter] fn asks (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . asks . clone () . into ()) } # [getter] fn best_bid_price (& self) -> PyResult < f64 > { Ok (self . inner . best_bid_price . clone () . into ()) } # [getter] fn best_ask_price (& self) -> PyResult < f64 > { Ok (self . inner . best_ask_price . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetBookSummaryByInstrumentRequest { inner : venues :: GetBookSummaryByInstrumentRequest , } # [pymethods] impl GetBookSummaryByInstrumentRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } } # [pymethods] impl RestClient { fn get_book_summary_by_instrument <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_book_summary_by_instrument () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetTradeVolumesRequest { inner : venues :: GetTradeVolumesRequest , } # [pymethods] impl GetTradeVolumesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } } # [pyclass] # [derive (Clone)] pub struct TradeVolumeEntry { inner : venues :: TradeVolumeEntry , } # [pymethods] impl TradeVolumeEntry { # [staticmethod] fn from_inner (inner : TradeVolumeEntry) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn futures_volume (& self) -> PyResult < f64 > { Ok (self . inner . futures_volume . clone () . into ()) } # [getter] fn calls_volume (& self) -> PyResult < f64 > { Ok (self . inner . calls_volume . clone () . into ()) } # [getter] fn puts_volume (& self) -> PyResult < f64 > { Ok (self . inner . puts_volume . clone () . into ()) } # [getter] fn spot_volume (& self) -> PyResult < f64 > { Ok (self . inner . spot_volume . clone () . into ()) } } # [pymethods] impl RestClient { fn get_trade_volumes <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_trade_volumes () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetStatusResult { inner : venues :: GetStatusResult , } # [pymethods] impl GetStatusResult { # [staticmethod] fn from_inner (inner : GetStatusResult) -> Self { Self { inner } } # [getter] fn locked (& self) -> PyResult < PyObject > { Ok (self . inner . locked . clone () . into ()) } # [getter] fn locked_indices (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . locked_indices . clone () . into ()) } } # [pymethods] impl RestClient { fn get_status <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_status () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetLastTradesByInstrumentRequest { inner : venues :: GetLastTradesByInstrumentRequest , } # [pymethods] impl GetLastTradesByInstrumentRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn sorting (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sorting . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TradeEntry { inner : venues :: TradeEntry , } # [pymethods] impl TradeEntry { # [staticmethod] fn from_inner (inner : TradeEntry) -> Self { Self { inner } } # [getter] fn trade_id (& self) -> PyResult < String > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < String > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn index_price (& self) -> PyResult < f64 > { Ok (self . inner . index_price . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn trade_seq (& self) -> PyResult < u64 > { Ok (self . inner . trade_seq . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < f64 > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn tick_direction (& self) -> PyResult < u64 > { Ok (self . inner . tick_direction . clone () . into ()) } # [getter] fn contracts (& self) -> PyResult < f64 > { Ok (self . inner . contracts . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetLastTradesByInstrumentResult { inner : venues :: GetLastTradesByInstrumentResult , } # [pymethods] impl GetLastTradesByInstrumentResult { # [staticmethod] fn from_inner (inner : GetLastTradesByInstrumentResult) -> Self { Self { inner } } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } # [getter] fn has_more (& self) -> PyResult < bool > { Ok (self . inner . has_more . clone () . into ()) } } # [pymethods] impl RestClient { fn get_last_trades_by_instrument <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_last_trades_by_instrument () . await }) } } # [pyclass] # [derive (Clone)] pub struct CurrencyInfo { inner : venues :: CurrencyInfo , } # [pymethods] impl CurrencyInfo { # [staticmethod] fn from_inner (inner : CurrencyInfo) -> Self { Self { inner } } # [getter] fn apr (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . apr . clone () . into ()) } # [getter] fn coin_type (& self) -> PyResult < String > { Ok (self . inner . coin_type . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn currency_long (& self) -> PyResult < String > { Ok (self . inner . currency_long . clone () . into ()) } # [getter] fn fee_precision (& self) -> PyResult < u64 > { Ok (self . inner . fee_precision . clone () . into ()) } # [getter] fn in_cross_collateral_pool (& self) -> PyResult < bool > { Ok (self . inner . in_cross_collateral_pool . clone () . into ()) } # [getter] fn min_confirmations (& self) -> PyResult < u64 > { Ok (self . inner . min_confirmations . clone () . into ()) } # [getter] fn min_withdrawal_fee (& self) -> PyResult < f64 > { Ok (self . inner . min_withdrawal_fee . clone () . into ()) } # [getter] fn withdrawal_fee (& self) -> PyResult < f64 > { Ok (self . inner . withdrawal_fee . clone () . into ()) } # [getter] fn withdrawal_priorities (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . withdrawal_priorities . clone () . into ()) } } # [pymethods] impl RestClient { fn get_currencies <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_currencies () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetRfqsRequest { inner : venues :: GetRfqsRequest , } # [pymethods] impl GetRfqsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . kind . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RfqEntry { inner : venues :: RfqEntry , } # [pymethods] impl RfqEntry { # [staticmethod] fn from_inner (inner : RfqEntry) -> Self { Self { inner } } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn last_rfq_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . last_rfq_timestamp . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn traded_volume (& self) -> PyResult < f64 > { Ok (self . inner . traded_volume . clone () . into ()) } } # [pymethods] impl RestClient { fn get_rfqs <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_rfqs () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetInstrumentRequest { inner : venues :: GetInstrumentRequest , } # [pymethods] impl GetInstrumentRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct InstrumentData { inner : venues :: InstrumentData , } # [pymethods] impl InstrumentData { # [staticmethod] fn from_inner (inner : InstrumentData) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < PyObject > { Ok (self . inner . kind . clone () . into ()) } # [getter] fn tick_size (& self) -> PyResult < f64 > { Ok (self . inner . tick_size . clone () . into ()) } # [getter] fn contract_size (& self) -> PyResult < f64 > { Ok (self . inner . contract_size . clone () . into ()) } # [getter] fn min_trade_amount (& self) -> PyResult < f64 > { Ok (self . inner . min_trade_amount . clone () . into ()) } # [getter] fn price_index (& self) -> PyResult < String > { Ok (self . inner . price_index . clone () . into ()) } # [getter] fn rfq (& self) -> PyResult < bool > { Ok (self . inner . rfq . clone () . into ()) } # [getter] fn maker_commission (& self) -> PyResult < f64 > { Ok (self . inner . maker_commission . clone () . into ()) } # [getter] fn taker_commission (& self) -> PyResult < f64 > { Ok (self . inner . taker_commission . clone () . into ()) } # [getter] fn instrument_type (& self) -> PyResult < String > { Ok (self . inner . instrument_type . clone () . into ()) } # [getter] fn expiration_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . expiration_timestamp . clone () . into ()) } # [getter] fn creation_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . creation_timestamp . clone () . into ()) } # [getter] fn is_active (& self) -> PyResult < bool > { Ok (self . inner . is_active . clone () . into ()) } # [getter] fn instrument_id (& self) -> PyResult < u64 > { Ok (self . inner . instrument_id . clone () . into ()) } # [getter] fn settlement_period (& self) -> PyResult < String > { Ok (self . inner . settlement_period . clone () . into ()) } # [getter] fn future_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . future_type . clone () . into ()) } # [getter] fn max_leverage (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . max_leverage . clone () . into ()) } # [getter] fn max_liquidation_commission (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . max_liquidation_commission . clone () . into ()) } # [getter] fn block_trade_commission (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_trade_commission . clone () . into ()) } # [getter] fn block_trade_min_trade_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_trade_min_trade_amount . clone () . into ()) } # [getter] fn block_trade_tick_size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_trade_tick_size . clone () . into ()) } # [getter] fn settlement_currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . settlement_currency . clone () . into ()) } # [getter] fn base_currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . base_currency . clone () . into ()) } # [getter] fn counter_currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . counter_currency . clone () . into ()) } # [getter] fn quote_currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_currency . clone () . into ()) } # [getter] fn tick_size_steps (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . tick_size_steps . clone () . into ()) } # [getter] fn strike (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . strike . clone () . into ()) } # [getter] fn option_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . option_type . clone () . into ()) } } # [pymethods] impl RestClient { fn get_instrument <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_instrument () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetCombosRequest { inner : venues :: GetCombosRequest , } # [pymethods] impl GetCombosRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ComboInfo { inner : venues :: ComboInfo , } # [pymethods] impl ComboInfo { # [staticmethod] fn from_inner (inner : ComboInfo) -> Self { Self { inner } } # [getter] fn creation_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . creation_timestamp . clone () . into ()) } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn instrument_id (& self) -> PyResult < i64 > { Ok (self . inner . instrument_id . clone () . into ()) } # [getter] fn legs (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . legs . clone () . into ()) } # [getter] fn state (& self) -> PyResult < String > { Ok (self . inner . state . clone () . into ()) } # [getter] fn state_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . state_timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn get_combos <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_combos () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetLastTradesByInstrumentAndTimeRequest { inner : venues :: GetLastTradesByInstrumentAndTimeRequest , } # [pymethods] impl GetLastTradesByInstrumentAndTimeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn start_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . start_timestamp . clone () . into ()) } # [getter] fn end_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . end_timestamp . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn sorting (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sorting . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TradeEntry { inner : venues :: TradeEntry , } # [pymethods] impl TradeEntry { # [staticmethod] fn from_inner (inner : TradeEntry) -> Self { Self { inner } } # [getter] fn trade_id (& self) -> PyResult < String > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < String > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn index_price (& self) -> PyResult < f64 > { Ok (self . inner . index_price . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn trade_seq (& self) -> PyResult < u64 > { Ok (self . inner . trade_seq . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < f64 > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn tick_direction (& self) -> PyResult < u64 > { Ok (self . inner . tick_direction . clone () . into ()) } # [getter] fn contracts (& self) -> PyResult < f64 > { Ok (self . inner . contracts . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetLastTradesByInstrumentAndTimeResult { inner : venues :: GetLastTradesByInstrumentAndTimeResult , } # [pymethods] impl GetLastTradesByInstrumentAndTimeResult { # [staticmethod] fn from_inner (inner : GetLastTradesByInstrumentAndTimeResult) -> Self { Self { inner } } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } # [getter] fn has_more (& self) -> PyResult < bool > { Ok (self . inner . has_more . clone () . into ()) } } # [pymethods] impl RestClient { fn get_last_trades_by_instrument_and_time <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_last_trades_by_instrument_and_time () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetInstrumentsRequest { inner : venues :: GetInstrumentsRequest , } # [pymethods] impl GetInstrumentsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . kind . clone () . into ()) } # [getter] fn expired (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . expired . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct InstrumentData { inner : venues :: InstrumentData , } # [pymethods] impl InstrumentData { # [staticmethod] fn from_inner (inner : InstrumentData) -> Self { Self { inner } } # [getter] fn base_currency (& self) -> PyResult < String > { Ok (self . inner . base_currency . clone () . into ()) } # [getter] fn block_trade_commission (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_trade_commission . clone () . into ()) } # [getter] fn block_trade_min_trade_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_trade_min_trade_amount . clone () . into ()) } # [getter] fn block_trade_tick_size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_trade_tick_size . clone () . into ()) } # [getter] fn contract_size (& self) -> PyResult < f64 > { Ok (self . inner . contract_size . clone () . into ()) } # [getter] fn counter_currency (& self) -> PyResult < String > { Ok (self . inner . counter_currency . clone () . into ()) } # [getter] fn creation_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . creation_timestamp . clone () . into ()) } # [getter] fn expiration_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . expiration_timestamp . clone () . into ()) } # [getter] fn future_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . future_type . clone () . into ()) } # [getter] fn instrument_id (& self) -> PyResult < u64 > { Ok (self . inner . instrument_id . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn instrument_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_type . clone () . into ()) } # [getter] fn is_active (& self) -> PyResult < bool > { Ok (self . inner . is_active . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < PyObject > { Ok (self . inner . kind . clone () . into ()) } # [getter] fn maker_commission (& self) -> PyResult < f64 > { Ok (self . inner . maker_commission . clone () . into ()) } # [getter] fn max_leverage (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . max_leverage . clone () . into ()) } # [getter] fn max_liquidation_commission (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . max_liquidation_commission . clone () . into ()) } # [getter] fn min_trade_amount (& self) -> PyResult < f64 > { Ok (self . inner . min_trade_amount . clone () . into ()) } # [getter] fn option_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . option_type . clone () . into ()) } # [getter] fn price_index (& self) -> PyResult < String > { Ok (self . inner . price_index . clone () . into ()) } # [getter] fn quote_currency (& self) -> PyResult < String > { Ok (self . inner . quote_currency . clone () . into ()) } # [getter] fn rfq (& self) -> PyResult < bool > { Ok (self . inner . rfq . clone () . into ()) } # [getter] fn settlement_currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . settlement_currency . clone () . into ()) } # [getter] fn settlement_period (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . settlement_period . clone () . into ()) } # [getter] fn strike (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . strike . clone () . into ()) } # [getter] fn taker_commission (& self) -> PyResult < f64 > { Ok (self . inner . taker_commission . clone () . into ()) } # [getter] fn tick_size (& self) -> PyResult < f64 > { Ok (self . inner . tick_size . clone () . into ()) } # [getter] fn tick_size_steps (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . tick_size_steps . clone () . into ()) } } # [pymethods] impl RestClient { fn get_instruments <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_instruments () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetLastSettlementsByCurrencyRequest { inner : venues :: GetLastSettlementsByCurrencyRequest , } # [pymethods] impl GetLastSettlementsByCurrencyRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < PyObject > { Ok (self . inner . kind . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SettlementEntry { inner : venues :: SettlementEntry , } # [pymethods] impl SettlementEntry { # [staticmethod] fn from_inner (inner : SettlementEntry) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn settlement_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . settlement_price . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetLastSettlementsByCurrencyResult { inner : venues :: GetLastSettlementsByCurrencyResult , } # [pymethods] impl GetLastSettlementsByCurrencyResult { # [staticmethod] fn from_inner (inner : GetLastSettlementsByCurrencyResult) -> Self { Self { inner } } # [getter] fn settlements (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . settlements . clone () . into ()) } } # [pymethods] impl RestClient { fn get_last_settlements_by_currency <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_last_settlements_by_currency () . await }) } } # [pymethods] impl RestClient { fn get_supported_index_names <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_supported_index_names () . await }) } } # [pymethods] impl RestClient { fn get_time <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_time () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetLastTradesByCurrencyAndTimeRequest { inner : venues :: GetLastTradesByCurrencyAndTimeRequest , } # [pymethods] impl GetLastTradesByCurrencyAndTimeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < PyObject > { Ok (self . inner . kind . clone () . into ()) } # [getter] fn start_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . start_timestamp . clone () . into ()) } # [getter] fn end_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . end_timestamp . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn sorting (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sorting . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TradeEntry { inner : venues :: TradeEntry , } # [pymethods] impl TradeEntry { # [staticmethod] fn from_inner (inner : TradeEntry) -> Self { Self { inner } } # [getter] fn trade_id (& self) -> PyResult < String > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < String > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn index_price (& self) -> PyResult < f64 > { Ok (self . inner . index_price . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn trade_seq (& self) -> PyResult < u64 > { Ok (self . inner . trade_seq . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < f64 > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn tick_direction (& self) -> PyResult < u64 > { Ok (self . inner . tick_direction . clone () . into ()) } # [getter] fn contracts (& self) -> PyResult < f64 > { Ok (self . inner . contracts . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetLastTradesByCurrencyAndTimeResult { inner : venues :: GetLastTradesByCurrencyAndTimeResult , } # [pymethods] impl GetLastTradesByCurrencyAndTimeResult { # [staticmethod] fn from_inner (inner : GetLastTradesByCurrencyAndTimeResult) -> Self { Self { inner } } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } # [getter] fn has_more (& self) -> PyResult < bool > { Ok (self . inner . has_more . clone () . into ()) } } # [pymethods] impl RestClient { fn get_last_trades_by_currency_and_time <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_last_trades_by_currency_and_time () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetFundingRateValueRequest { inner : venues :: GetFundingRateValueRequest , } # [pymethods] impl GetFundingRateValueRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn start_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . start_timestamp . clone () . into ()) } # [getter] fn end_timestamp (& self) -> PyResult < u64 > { Ok (self . inner . end_timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn get_funding_rate_value <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_funding_rate_value () . await }) } } # [pyclass] # [derive (Clone)] pub struct SubmitTransferBetweenSubaccountsRequest { inner : venues :: SubmitTransferBetweenSubaccountsRequest , } # [pymethods] impl SubmitTransferBetweenSubaccountsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn destination (& self) -> PyResult < i64 > { Ok (self . inner . destination . clone () . into ()) } # [getter] fn source (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . source . clone () . into ()) } } # [pymethods] impl RestClient { fn submit_transfer_between_subaccounts <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . submit_transfer_between_subaccounts () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetSettlementHistoryByInstrumentRequest { inner : venues :: GetSettlementHistoryByInstrumentRequest , } # [pymethods] impl GetSettlementHistoryByInstrumentRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn r#type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . r#type . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn continuation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . continuation . clone () . into ()) } # [getter] fn search_start_timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . search_start_timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetSettlementHistoryByInstrumentResult { inner : venues :: GetSettlementHistoryByInstrumentResult , } # [pymethods] impl GetSettlementHistoryByInstrumentResult { # [staticmethod] fn from_inner (inner : GetSettlementHistoryByInstrumentResult) -> Self { Self { inner } } # [getter] fn continuation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . continuation . clone () . into ()) } # [getter] fn settlements (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . settlements . clone () . into ()) } } # [pymethods] impl RestClient { fn get_settlement_history_by_instrument <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_settlement_history_by_instrument () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelBlockRfqQuoteRequest { inner : venues :: CancelBlockRfqQuoteRequest , } # [pymethods] impl CancelBlockRfqQuoteRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn block_rfq_quote_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq_quote_id . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn block_rfq_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq_id . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_block_rfq_quote <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_block_rfq_quote () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetAddressBookRequest { inner : venues :: GetAddressBookRequest , } # [pymethods] impl GetAddressBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn address_type (& self) -> PyResult < PyObject > { Ok (self . inner . address_type . clone () . into ()) } } # [pymethods] impl RestClient { fn get_address_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_address_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelWithdrawalRequest { inner : venues :: CancelWithdrawalRequest , } # [pymethods] impl CancelWithdrawalRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_withdrawal <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_withdrawal () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelAllRequest { inner : venues :: CancelAllRequest , } # [pymethods] impl CancelAllRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn detailed (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . detailed . clone () . into ()) } # [getter] fn freeze_quotes (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . freeze_quotes . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_all <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all () . await }) } } # [pyclass] # [derive (Clone)] pub enum Role { Maker , Taker , } # [pyclass] # [derive (Clone)] pub enum Direction { Buy , Sell , } # [pyclass] # [derive (Clone)] pub struct Trade { inner : venues :: Trade , } # [pymethods] impl Trade { # [staticmethod] fn from_inner (inner : Trade) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . amount . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SimulateBlockTradeRequest { inner : venues :: SimulateBlockTradeRequest , } # [pymethods] impl SimulateBlockTradeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn role (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . role . clone () . into ()) } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } } # [pymethods] impl RestClient { fn simulate_block_trade <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . simulate_block_trade () . await }) } } # [pyclass] # [derive (Clone)] pub struct RemoveFromAddressBookRequest { inner : venues :: RemoveFromAddressBookRequest , } # [pymethods] impl RemoveFromAddressBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn address_type (& self) -> PyResult < PyObject > { Ok (self . inner . address_type . clone () . into ()) } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } } # [pymethods] impl RestClient { fn remove_from_address_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . remove_from_address_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelAllByCurrencyPairRequest { inner : venues :: CancelAllByCurrencyPairRequest , } # [pymethods] impl CancelAllByCurrencyPairRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < PyObject > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . kind . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn detailed (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . detailed . clone () . into ()) } # [getter] fn freeze_quotes (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . freeze_quotes . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_all_by_currency_pair <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_by_currency_pair () . await }) } } # [pyclass] # [derive (Clone)] pub struct DisableCancelOnDisconnectRequest { inner : venues :: DisableCancelOnDisconnectRequest , } # [pymethods] impl DisableCancelOnDisconnectRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn scope (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . scope . clone () . into ()) } } # [pymethods] impl RestClient { fn disable_cancel_on_disconnect <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . disable_cancel_on_disconnect () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelAllBlockRfqQuotesRequest { inner : venues :: CancelAllBlockRfqQuotesRequest , } # [pymethods] impl CancelAllBlockRfqQuotesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn block_rfq_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq_id . clone () . into ()) } # [getter] fn detailed (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . detailed . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_all_block_rfq_quotes <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_block_rfq_quotes () . await }) } } # [pyclass] # [derive (Clone)] pub struct MovePositionTrade { inner : venues :: MovePositionTrade , } # [pymethods] impl MovePositionTrade { # [staticmethod] fn from_inner (inner : MovePositionTrade) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct MovePositionsRequest { inner : venues :: MovePositionsRequest , } # [pymethods] impl MovePositionsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn source_uid (& self) -> PyResult < i64 > { Ok (self . inner . source_uid . clone () . into ()) } # [getter] fn target_uid (& self) -> PyResult < i64 > { Ok (self . inner . target_uid . clone () . into ()) } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct MovePositionTradeResult { inner : venues :: MovePositionTradeResult , } # [pymethods] impl MovePositionTradeResult { # [staticmethod] fn from_inner (inner : MovePositionTradeResult) -> Self { Self { inner } } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < String > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn source_uid (& self) -> PyResult < i64 > { Ok (self . inner . source_uid . clone () . into ()) } # [getter] fn target_uid (& self) -> PyResult < i64 > { Ok (self . inner . target_uid . clone () . into ()) } } # [pymethods] impl RestClient { fn move_positions <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . move_positions () . await }) } } # [pyclass] # [derive (Clone)] pub enum CurrencySelection { Multiple , Single , } # [pyclass] # [derive (Clone)] pub struct CancelAllByKindOrTypeRequest { inner : venues :: CancelAllByKindOrTypeRequest , } # [pymethods] impl CancelAllByKindOrTypeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . kind . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn detailed (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . detailed . clone () . into ()) } # [getter] fn freeze_quotes (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . freeze_quotes . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_all_by_kind_or_type <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_by_kind_or_type () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetTriggerOrderHistoryRequest { inner : venues :: GetTriggerOrderHistoryRequest , } # [pymethods] impl GetTriggerOrderHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn continuation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . continuation . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TriggerOrderEntry { inner : venues :: TriggerOrderEntry , } # [pymethods] impl TriggerOrderEntry { # [staticmethod] fn from_inner (inner : TriggerOrderEntry) -> Self { Self { inner } } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn is_secondary_oto (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_secondary_oto . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn last_update_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . last_update_timestamp . clone () . into ()) } # [getter] fn oco_ref (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . oco_ref . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn order_state (& self) -> PyResult < String > { Ok (self . inner . order_state . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn post_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . post_only . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn reduce_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reduce_only . clone () . into ()) } # [getter] fn request (& self) -> PyResult < String > { Ok (self . inner . request . clone () . into ()) } # [getter] fn source (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . source . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn trigger (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger . clone () . into ()) } # [getter] fn trigger_offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_offset . clone () . into ()) } # [getter] fn trigger_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_order_id . clone () . into ()) } # [getter] fn trigger_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetTriggerOrderHistoryResult { inner : venues :: GetTriggerOrderHistoryResult , } # [pymethods] impl GetTriggerOrderHistoryResult { # [staticmethod] fn from_inner (inner : GetTriggerOrderHistoryResult) -> Self { Self { inner } } # [getter] fn continuation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . continuation . clone () . into ()) } # [getter] fn entries (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . entries . clone () . into ()) } } # [pymethods] impl RestClient { fn get_trigger_order_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_trigger_order_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } # [getter] fn base_url (& self) -> PyResult < PyObject > { Ok (self . inner . base_url . clone () . into ()) } # [getter] fn client (& self) -> PyResult < PyObject > { Ok (self . inner . client . clone () . into ()) } # [getter] fn rate_limiter (& self) -> PyResult < PyObject > { Ok (self . inner . rate_limiter . clone () . into ()) } } # [pymethods] impl RestClient { fn sign_request (& self) -> PyResult < () > { self . inner . sign_request () ; Ok (()) } fn send_signed_request <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_signed_request () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelAllByCurrencyRequest { inner : venues :: CancelAllByCurrencyRequest , } # [pymethods] impl CancelAllByCurrencyRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . kind . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn detailed (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . detailed . clone () . into ()) } # [getter] fn freeze_quotes (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . freeze_quotes . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_all_by_currency <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_by_currency () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelAllByInstrumentRequest { inner : venues :: CancelAllByInstrumentRequest , } # [pymethods] impl CancelAllByInstrumentRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn detailed (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . detailed . clone () . into ()) } # [getter] fn include_combos (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . include_combos . clone () . into ()) } # [getter] fn freeze_quotes (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . freeze_quotes . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_all_by_instrument <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_by_instrument () . await }) } } # [pyclass] # [derive (Clone)] pub enum IndexName { BtcUsd , EthUsd , BtcUsdc , EthUsdc , AdaUsdc , AlgoUsdc , AvaxUsdc , BchUsdc , BnbUsdc , DogeUsdc , DotUsdc , LinkUsdc , LtcUsdc , NearUsdc , PaxgUsdc , ShibUsdc , SolUsdc , TrxUsdc , TrumpUsdc , UniUsdc , XrpUsdc , UsdeUsdc , BuidlUsdc , BtcdvolUsdc , EthdvolUsdc , BtcUsdt , EthUsdt , All , } # [pyclass] # [derive (Clone)] pub struct SetMmpConfigRequest { inner : venues :: SetMmpConfigRequest , } # [pymethods] impl SetMmpConfigRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn index_name (& self) -> PyResult < PyObject > { Ok (self . inner . index_name . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < i64 > { Ok (self . inner . interval . clone () . into ()) } # [getter] fn frozen_time (& self) -> PyResult < i64 > { Ok (self . inner . frozen_time . clone () . into ()) } # [getter] fn mmp_group (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_group . clone () . into ()) } # [getter] fn quantity_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quantity_limit . clone () . into ()) } # [getter] fn delta_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . delta_limit . clone () . into ()) } # [getter] fn vega_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . vega_limit . clone () . into ()) } # [getter] fn block_rfq (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq . clone () . into ()) } # [getter] fn trade_count_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trade_count_limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct MmpConfig { inner : venues :: MmpConfig , } # [pymethods] impl MmpConfig { # [staticmethod] fn from_inner (inner : MmpConfig) -> Self { Self { inner } } # [getter] fn block_rfq (& self) -> PyResult < bool > { Ok (self . inner . block_rfq . clone () . into ()) } # [getter] fn delta_limit (& self) -> PyResult < f64 > { Ok (self . inner . delta_limit . clone () . into ()) } # [getter] fn frozen_time (& self) -> PyResult < i64 > { Ok (self . inner . frozen_time . clone () . into ()) } # [getter] fn index_name (& self) -> PyResult < String > { Ok (self . inner . index_name . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < i64 > { Ok (self . inner . interval . clone () . into ()) } # [getter] fn mmp_group (& self) -> PyResult < String > { Ok (self . inner . mmp_group . clone () . into ()) } # [getter] fn quantity_limit (& self) -> PyResult < f64 > { Ok (self . inner . quantity_limit . clone () . into ()) } # [getter] fn trade_count_limit (& self) -> PyResult < i64 > { Ok (self . inner . trade_count_limit . clone () . into ()) } # [getter] fn vega_limit (& self) -> PyResult < f64 > { Ok (self . inner . vega_limit . clone () . into ()) } } # [pymethods] impl RestClient { fn set_mmp_config <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . set_mmp_config () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetBlockRfqMakersRequest { inner : venues :: GetBlockRfqMakersRequest , } # [pymethods] impl GetBlockRfqMakersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } } # [pymethods] impl RestClient { fn get_block_rfq_makers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_block_rfq_makers () . await }) } } # [pyclass] # [derive (Clone)] pub struct WithdrawRequest { inner : venues :: WithdrawRequest , } # [pymethods] impl WithdrawRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn priority (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . priority . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct WithdrawalData { inner : venues :: WithdrawalData , } # [pymethods] impl WithdrawalData { # [staticmethod] fn from_inner (inner : WithdrawalData) -> Self { Self { inner } } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn confirmed_timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . confirmed_timestamp . clone () . into ()) } # [getter] fn created_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . created_timestamp . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < f64 > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn priority (& self) -> PyResult < f64 > { Ok (self . inner . priority . clone () . into ()) } # [getter] fn state (& self) -> PyResult < PyObject > { Ok (self . inner . state . clone () . into ()) } # [getter] fn transaction_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . transaction_id . clone () . into ()) } # [getter] fn updated_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . updated_timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn withdraw <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . withdraw () . await }) } } # [pyclass] # [derive (Clone)] pub enum IndexName { BtcUsd , EthUsd , BtcUsdc , EthUsdc , AdaUsdc , AlgoUsdc , AvaxUsdc , BchUsdc , BnbUsdc , DogeUsdc , DotUsdc , LinkUsdc , LtcUsdc , NearUsdc , PaxgUsdc , ShibUsdc , SolUsdc , TrxUsdc , TrumpUsdc , UniUsdc , XrpUsdc , UsdeUsdc , BuidlUsdc , BtcdvolUsdc , EthdvolUsdc , BtcUsdt , EthUsdt , All , } # [pyclass] # [derive (Clone)] pub struct ResetMmpRequest { inner : venues :: ResetMmpRequest , } # [pymethods] impl ResetMmpRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn index_name (& self) -> PyResult < PyObject > { Ok (self . inner . index_name . clone () . into ()) } # [getter] fn mmp_group (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_group . clone () . into ()) } # [getter] fn block_rfq (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq . clone () . into ()) } } # [pymethods] impl RestClient { fn reset_mmp <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . reset_mmp () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateBlockRfqRequest { inner : venues :: CreateBlockRfqRequest , } # [pymethods] impl CreateBlockRfqRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn legs (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . legs . clone () . into ()) } # [getter] fn hedge (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . hedge . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn makers (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . makers . clone () . into ()) } # [getter] fn disclosed (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . disclosed . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ResponseLeg { inner : venues :: ResponseLeg , } # [pymethods] impl ResponseLeg { # [staticmethod] fn from_inner (inner : ResponseLeg) -> Self { Self { inner } } # [getter] fn direction (& self) -> PyResult < String > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn ratio (& self) -> PyResult < i64 > { Ok (self . inner . ratio . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ResponseHedge { inner : venues :: ResponseHedge , } # [pymethods] impl ResponseHedge { # [staticmethod] fn from_inner (inner : ResponseHedge) -> Self { Self { inner } } # [getter] fn amount (& self) -> PyResult < i64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < String > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateBlockRfqResult { inner : venues :: CreateBlockRfqResult , } # [pymethods] impl CreateBlockRfqResult { # [staticmethod] fn from_inner (inner : CreateBlockRfqResult) -> Self { Self { inner } } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn app_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . app_name . clone () . into ()) } # [getter] fn asks (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . asks . clone () . into ()) } # [getter] fn bids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . bids . clone () . into ()) } # [getter] fn block_rfq_id (& self) -> PyResult < i64 > { Ok (self . inner . block_rfq_id . clone () . into ()) } # [getter] fn combo_id (& self) -> PyResult < String > { Ok (self . inner . combo_id . clone () . into ()) } # [getter] fn creation_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . creation_timestamp . clone () . into ()) } # [getter] fn disclosed (& self) -> PyResult < bool > { Ok (self . inner . disclosed . clone () . into ()) } # [getter] fn expiration_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . expiration_timestamp . clone () . into ()) } # [getter] fn hedge (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . hedge . clone () . into ()) } # [getter] fn included_in_taker_rating (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . included_in_taker_rating . clone () . into ()) } # [getter] fn index_prices (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . index_prices . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn legs (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . legs . clone () . into ()) } # [getter] fn makers (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . makers . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < f64 > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn min_trade_amount (& self) -> PyResult < f64 > { Ok (self . inner . min_trade_amount . clone () . into ()) } # [getter] fn role (& self) -> PyResult < String > { Ok (self . inner . role . clone () . into ()) } # [getter] fn state (& self) -> PyResult < String > { Ok (self . inner . state . clone () . into ()) } } # [pymethods] impl RestClient { fn create_block_rfq <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_block_rfq () . await }) } } # [pyclass] # [derive (Clone)] pub struct AddToAddressBookRequest { inner : venues :: AddToAddressBookRequest , } # [pymethods] impl AddToAddressBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn address_type (& self) -> PyResult < PyObject > { Ok (self . inner . address_type . clone () . into ()) } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn label (& self) -> PyResult < String > { Ok (self . inner . label . clone () . into ()) } # [getter] fn beneficiary_vasp_name (& self) -> PyResult < String > { Ok (self . inner . beneficiary_vasp_name . clone () . into ()) } # [getter] fn beneficiary_vasp_did (& self) -> PyResult < String > { Ok (self . inner . beneficiary_vasp_did . clone () . into ()) } # [getter] fn beneficiary_vasp_website (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . beneficiary_vasp_website . clone () . into ()) } # [getter] fn beneficiary_first_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . beneficiary_first_name . clone () . into ()) } # [getter] fn beneficiary_last_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . beneficiary_last_name . clone () . into ()) } # [getter] fn beneficiary_company_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . beneficiary_company_name . clone () . into ()) } # [getter] fn beneficiary_address (& self) -> PyResult < String > { Ok (self . inner . beneficiary_address . clone () . into ()) } # [getter] fn agreed (& self) -> PyResult < bool > { Ok (self . inner . agreed . clone () . into ()) } # [getter] fn personal (& self) -> PyResult < bool > { Ok (self . inner . personal . clone () . into ()) } # [getter] fn extra_currencies (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . extra_currencies . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AddressBookEntry { inner : venues :: AddressBookEntry , } # [pymethods] impl AddressBookEntry { # [staticmethod] fn from_inner (inner : AddressBookEntry) -> Self { Self { inner } } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn agreed (& self) -> PyResult < bool > { Ok (self . inner . agreed . clone () . into ()) } # [getter] fn beneficiary_address (& self) -> PyResult < String > { Ok (self . inner . beneficiary_address . clone () . into ()) } # [getter] fn beneficiary_company_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . beneficiary_company_name . clone () . into ()) } # [getter] fn beneficiary_first_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . beneficiary_first_name . clone () . into ()) } # [getter] fn beneficiary_last_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . beneficiary_last_name . clone () . into ()) } # [getter] fn beneficiary_vasp_did (& self) -> PyResult < String > { Ok (self . inner . beneficiary_vasp_did . clone () . into ()) } # [getter] fn beneficiary_vasp_name (& self) -> PyResult < String > { Ok (self . inner . beneficiary_vasp_name . clone () . into ()) } # [getter] fn beneficiary_vasp_website (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . beneficiary_vasp_website . clone () . into ()) } # [getter] fn creation_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . creation_timestamp . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn info_required (& self) -> PyResult < bool > { Ok (self . inner . info_required . clone () . into ()) } # [getter] fn label (& self) -> PyResult < String > { Ok (self . inner . label . clone () . into ()) } # [getter] fn personal (& self) -> PyResult < bool > { Ok (self . inner . personal . clone () . into ()) } # [getter] fn requires_confirmation (& self) -> PyResult < bool > { Ok (self . inner . requires_confirmation . clone () . into ()) } # [getter] fn requires_confirmation_change (& self) -> PyResult < bool > { Ok (self . inner . requires_confirmation_change . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn address_type (& self) -> PyResult < PyObject > { Ok (self . inner . address_type . clone () . into ()) } # [getter] fn waiting_timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . waiting_timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn add_to_address_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . add_to_address_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetWithdrawalsRequest { inner : venues :: GetWithdrawalsRequest , } # [pymethods] impl GetWithdrawalsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetWithdrawalsResult { inner : venues :: GetWithdrawalsResult , } # [pymethods] impl GetWithdrawalsResult { # [staticmethod] fn from_inner (inner : GetWithdrawalsResult) -> Self { Self { inner } } # [getter] fn count (& self) -> PyResult < i64 > { Ok (self . inner . count . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_withdrawals <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_withdrawals () . await }) } } # [pyclass] # [derive (Clone)] pub enum CancelOnDisconnectScope { Connection , Account , } # [pyclass] # [derive (Clone)] pub struct EnableCancelOnDisconnectRequest { inner : venues :: EnableCancelOnDisconnectRequest , } # [pymethods] impl EnableCancelOnDisconnectRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn scope (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . scope . clone () . into ()) } } # [pymethods] impl RestClient { fn enable_cancel_on_disconnect <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . enable_cancel_on_disconnect () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetMarginsRequest { inner : venues :: GetMarginsRequest , } # [pymethods] impl GetMarginsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetMarginsResult { inner : venues :: GetMarginsResult , } # [pymethods] impl GetMarginsResult { # [staticmethod] fn from_inner (inner : GetMarginsResult) -> Self { Self { inner } } # [getter] fn buy (& self) -> PyResult < f64 > { Ok (self . inner . buy . clone () . into ()) } # [getter] fn max_price (& self) -> PyResult < f64 > { Ok (self . inner . max_price . clone () . into ()) } # [getter] fn min_price (& self) -> PyResult < f64 > { Ok (self . inner . min_price . clone () . into ()) } # [getter] fn sell (& self) -> PyResult < f64 > { Ok (self . inner . sell . clone () . into ()) } } # [pymethods] impl RestClient { fn get_margins <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_margins () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateDepositAddressRequest { inner : venues :: CreateDepositAddressRequest , } # [pymethods] impl CreateDepositAddressRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } } # [pymethods] impl RestClient { fn create_deposit_address <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_deposit_address () . await }) } } # [pyclass] # [derive (Clone)] pub enum OpenOrderType { All , Limit , TriggerAll , StopAll , StopLimit , StopMarket , TakeAll , TakeLimit , TakeMarket , TrailingAll , TrailingStop , } # [pyclass] # [derive (Clone)] pub struct GetOpenOrdersByCurrencyRequest { inner : venues :: GetOpenOrdersByCurrencyRequest , } # [pymethods] impl GetOpenOrdersByCurrencyRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . kind . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_type . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OpenOrder { inner : venues :: OpenOrder , } # [pymethods] impl OpenOrder { # [staticmethod] fn from_inner (inner : OpenOrder) -> Self { Self { inner } } # [getter] fn quote (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote . clone () . into ()) } # [getter] fn triggered (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . triggered . clone () . into ()) } # [getter] fn mobile (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mobile . clone () . into ()) } # [getter] fn app_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . app_name . clone () . into ()) } # [getter] fn implv (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . implv . clone () . into ()) } # [getter] fn refresh_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . refresh_amount . clone () . into ()) } # [getter] fn usd (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . usd . clone () . into ()) } # [getter] fn oto_order_ids (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . oto_order_ids . clone () . into ()) } # [getter] fn api (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . api . clone () . into ()) } # [getter] fn average_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . average_price . clone () . into ()) } # [getter] fn advanced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . advanced . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn post_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . post_only . clone () . into ()) } # [getter] fn filled_amount (& self) -> PyResult < f64 > { Ok (self . inner . filled_amount . clone () . into ()) } # [getter] fn trigger (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger . clone () . into ()) } # [getter] fn trigger_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_order_id . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn contracts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contracts . clone () . into ()) } # [getter] fn is_secondary_oto (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_secondary_oto . clone () . into ()) } # [getter] fn replaced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . replaced . clone () . into ()) } # [getter] fn mmp_group (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_group . clone () . into ()) } # [getter] fn mmp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp . clone () . into ()) } # [getter] fn last_update_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . last_update_timestamp . clone () . into ()) } # [getter] fn creation_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . creation_timestamp . clone () . into ()) } # [getter] fn cancel_reason (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cancel_reason . clone () . into ()) } # [getter] fn mmp_cancelled (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_cancelled . clone () . into ()) } # [getter] fn quote_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_id . clone () . into ()) } # [getter] fn order_state (& self) -> PyResult < PyObject > { Ok (self . inner . order_state . clone () . into ()) } # [getter] fn is_rebalance (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_rebalance . clone () . into ()) } # [getter] fn reject_post_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reject_post_only . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn is_liquidation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_liquidation . clone () . into ()) } # [getter] fn price (& self) -> PyResult < PyObject > { Ok (self . inner . price . clone () . into ()) } # [getter] fn web (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . web . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn trigger_reference_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_reference_price . clone () . into ()) } # [getter] fn display_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . display_amount . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn is_primary_otoco (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_primary_otoco . clone () . into ()) } # [getter] fn original_order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . original_order_type . clone () . into ()) } # [getter] fn block_trade (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_trade . clone () . into ()) } # [getter] fn trigger_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_price . clone () . into ()) } # [getter] fn oco_ref (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . oco_ref . clone () . into ()) } # [getter] fn trigger_offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_offset . clone () . into ()) } # [getter] fn quote_set_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_set_id . clone () . into ()) } # [getter] fn auto_replaced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . auto_replaced . clone () . into ()) } # [getter] fn reduce_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reduce_only . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn risk_reducing (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . risk_reducing . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn trigger_fill_condition (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_fill_condition . clone () . into ()) } # [getter] fn primary_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . primary_order_id . clone () . into ()) } } # [pymethods] impl RestClient { fn get_open_orders_by_currency <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_open_orders_by_currency () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelByLabelRequest { inner : venues :: CancelByLabelRequest , } # [pymethods] impl CancelByLabelRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn label (& self) -> PyResult < String > { Ok (self . inner . label . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_by_label <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_by_label () . await }) } } # [pyclass] # [derive (Clone)] pub struct SubmitTransferToSubaccountRequest { inner : venues :: SubmitTransferToSubaccountRequest , } # [pymethods] impl SubmitTransferToSubaccountRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn destination (& self) -> PyResult < i64 > { Ok (self . inner . destination . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SubaccountTransferData { inner : venues :: SubaccountTransferData , } # [pymethods] impl SubaccountTransferData { # [staticmethod] fn from_inner (inner : SubaccountTransferData) -> Self { Self { inner } } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn created_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . created_timestamp . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < String > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn other_side (& self) -> PyResult < String > { Ok (self . inner . other_side . clone () . into ()) } # [getter] fn state (& self) -> PyResult < String > { Ok (self . inner . state . clone () . into ()) } # [getter] fn transfer_type (& self) -> PyResult < String > { Ok (self . inner . transfer_type . clone () . into ()) } # [getter] fn updated_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . updated_timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn submit_transfer_to_subaccount <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . submit_transfer_to_subaccount () . await }) } } # [pyclass] # [derive (Clone)] pub enum Role { Maker , Taker , } # [pyclass] # [derive (Clone)] pub struct ApproveBlockTradeRequest { inner : venues :: ApproveBlockTradeRequest , } # [pymethods] impl ApproveBlockTradeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn nonce (& self) -> PyResult < String > { Ok (self . inner . nonce . clone () . into ()) } # [getter] fn role (& self) -> PyResult < PyObject > { Ok (self . inner . role . clone () . into ()) } } # [pymethods] impl RestClient { fn approve_block_trade <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . approve_block_trade () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetUserTradesByInstrumentRequest { inner : venues :: GetUserTradesByInstrumentRequest , } # [pymethods] impl GetUserTradesByInstrumentRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn start_seq (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_seq . clone () . into ()) } # [getter] fn end_seq (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_seq . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn start_timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_timestamp . clone () . into ()) } # [getter] fn end_timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_timestamp . clone () . into ()) } # [getter] fn historical (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . historical . clone () . into ()) } # [getter] fn sorting (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sorting . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetUserTradesByInstrumentResult { inner : venues :: GetUserTradesByInstrumentResult , } # [pymethods] impl GetUserTradesByInstrumentResult { # [staticmethod] fn from_inner (inner : GetUserTradesByInstrumentResult) -> Self { Self { inner } } # [getter] fn has_more (& self) -> PyResult < bool > { Ok (self . inner . has_more . clone () . into ()) } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } } # [pymethods] impl RestClient { fn get_user_trades_by_instrument <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_user_trades_by_instrument () . await }) } } # [pyclass] # [derive (Clone)] pub enum Role { Maker , Taker , } # [pyclass] # [derive (Clone)] pub enum Direction { Buy , Sell , } # [pyclass] # [derive (Clone)] pub struct Trade { inner : venues :: Trade , } # [pymethods] impl Trade { # [staticmethod] fn from_inner (inner : Trade) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . amount . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ExecuteBlockTradeRequest { inner : venues :: ExecuteBlockTradeRequest , } # [pymethods] impl ExecuteBlockTradeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn nonce (& self) -> PyResult < String > { Ok (self . inner . nonce . clone () . into ()) } # [getter] fn role (& self) -> PyResult < PyObject > { Ok (self . inner . role . clone () . into ()) } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } # [getter] fn counterparty_signature (& self) -> PyResult < String > { Ok (self . inner . counterparty_signature . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ExecutedTrade { inner : venues :: ExecutedTrade , } # [pymethods] impl ExecutedTrade { # [staticmethod] fn from_inner (inner : ExecutedTrade) -> Self { Self { inner } } # [getter] fn trade_id (& self) -> PyResult < String > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn tick_direction (& self) -> PyResult < i64 > { Ok (self . inner . tick_direction . clone () . into ()) } # [getter] fn fee_currency (& self) -> PyResult < String > { Ok (self . inner . fee_currency . clone () . into ()) } # [getter] fn api (& self) -> PyResult < bool > { Ok (self . inner . api . clone () . into ()) } # [getter] fn advanced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . advanced . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn liquidity (& self) -> PyResult < String > { Ok (self . inner . liquidity . clone () . into ()) } # [getter] fn post_only (& self) -> PyResult < bool > { Ok (self . inner . post_only . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < String > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn contracts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contracts . clone () . into ()) } # [getter] fn mmp (& self) -> PyResult < bool > { Ok (self . inner . mmp . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < f64 > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn quote_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_id . clone () . into ()) } # [getter] fn index_price (& self) -> PyResult < f64 > { Ok (self . inner . index_price . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn block_trade_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_trade_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn combo_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . combo_id . clone () . into ()) } # [getter] fn matching_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . matching_id . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn profit_loss (& self) -> PyResult < f64 > { Ok (self . inner . profit_loss . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn iv (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . iv . clone () . into ()) } # [getter] fn state (& self) -> PyResult < String > { Ok (self . inner . state . clone () . into ()) } # [getter] fn underlying_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . underlying_price . clone () . into ()) } # [getter] fn block_rfq_quote_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq_quote_id . clone () . into ()) } # [getter] fn quote_set_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_set_id . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < f64 > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn block_rfq_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq_id . clone () . into ()) } # [getter] fn combo_trade_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . combo_trade_id . clone () . into ()) } # [getter] fn reduce_only (& self) -> PyResult < bool > { Ok (self . inner . reduce_only . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn liquidation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . liquidation . clone () . into ()) } # [getter] fn trade_seq (& self) -> PyResult < i64 > { Ok (self . inner . trade_seq . clone () . into ()) } # [getter] fn risk_reducing (& self) -> PyResult < bool > { Ok (self . inner . risk_reducing . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn legs (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . legs . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ExecuteBlockTradeResult { inner : venues :: ExecuteBlockTradeResult , } # [pymethods] impl ExecuteBlockTradeResult { # [staticmethod] fn from_inner (inner : ExecuteBlockTradeResult) -> Self { Self { inner } } # [getter] fn app_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . app_name . clone () . into ()) } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } } # [pymethods] impl RestClient { fn execute_block_trade <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . execute_block_trade () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelOrderRequest { inner : venues :: CancelOrderRequest , } # [pymethods] impl CancelOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelledOrder { inner : venues :: CancelledOrder , } # [pymethods] impl CancelledOrder { # [staticmethod] fn from_inner (inner : CancelledOrder) -> Self { Self { inner } } # [getter] fn quote (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote . clone () . into ()) } # [getter] fn triggered (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . triggered . clone () . into ()) } # [getter] fn mobile (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mobile . clone () . into ()) } # [getter] fn app_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . app_name . clone () . into ()) } # [getter] fn implv (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . implv . clone () . into ()) } # [getter] fn refresh_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . refresh_amount . clone () . into ()) } # [getter] fn usd (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . usd . clone () . into ()) } # [getter] fn oto_order_ids (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . oto_order_ids . clone () . into ()) } # [getter] fn api (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . api . clone () . into ()) } # [getter] fn average_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . average_price . clone () . into ()) } # [getter] fn advanced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . advanced . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn post_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . post_only . clone () . into ()) } # [getter] fn filled_amount (& self) -> PyResult < f64 > { Ok (self . inner . filled_amount . clone () . into ()) } # [getter] fn trigger (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger . clone () . into ()) } # [getter] fn trigger_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_order_id . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn contracts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contracts . clone () . into ()) } # [getter] fn is_secondary_oto (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_secondary_oto . clone () . into ()) } # [getter] fn replaced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . replaced . clone () . into ()) } # [getter] fn mmp_group (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_group . clone () . into ()) } # [getter] fn mmp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp . clone () . into ()) } # [getter] fn last_update_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . last_update_timestamp . clone () . into ()) } # [getter] fn creation_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . creation_timestamp . clone () . into ()) } # [getter] fn cancel_reason (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cancel_reason . clone () . into ()) } # [getter] fn mmp_cancelled (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_cancelled . clone () . into ()) } # [getter] fn quote_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_id . clone () . into ()) } # [getter] fn order_state (& self) -> PyResult < PyObject > { Ok (self . inner . order_state . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn max_show (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . max_show . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn original_order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . original_order_type . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn reduce_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reduce_only . clone () . into ()) } # [getter] fn profit_loss (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . profit_loss . clone () . into ()) } # [getter] fn is_liquidation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_liquidation . clone () . into ()) } # [getter] fn auto_replaced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . auto_replaced . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn trigger_offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_offset . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_price . clone () . into ()) } # [getter] fn trigger_fill_condition (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_fill_condition . clone () . into ()) } # [getter] fn reject_post_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reject_post_only . clone () . into ()) } # [getter] fn commission (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . commission . clone () . into ()) } # [getter] fn post_condition (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . post_condition . clone () . into ()) } # [getter] fn otoco_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . otoco_order_id . clone () . into ()) } # [getter] fn otoco (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . otoco . clone () . into ()) } # [getter] fn bracketed (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . bracketed . clone () . into ()) } # [getter] fn take_profit_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . take_profit_price . clone () . into ()) } # [getter] fn stop_loss_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_loss_price . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetCancelOnDisconnectRequest { inner : venues :: GetCancelOnDisconnectRequest , } # [pymethods] impl GetCancelOnDisconnectRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn scope (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . scope . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelOnDisconnectResult { inner : venues :: CancelOnDisconnectResult , } # [pymethods] impl CancelOnDisconnectResult { # [staticmethod] fn from_inner (inner : CancelOnDisconnectResult) -> Self { Self { inner } } # [getter] fn enabled (& self) -> PyResult < bool > { Ok (self . inner . enabled . clone () . into ()) } # [getter] fn scope (& self) -> PyResult < String > { Ok (self . inner . scope . clone () . into ()) } } # [pymethods] impl RestClient { fn get_cancel_on_disconnect <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_cancel_on_disconnect () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetBlockRfqUserInfoRequest { inner : venues :: GetBlockRfqUserInfoRequest , } # [pymethods] impl GetBlockRfqUserInfoRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } } # [pyclass] # [derive (Clone)] pub struct UserInfo { inner : venues :: UserInfo , } # [pymethods] impl UserInfo { # [staticmethod] fn from_inner (inner : UserInfo) -> Self { Self { inner } } # [getter] fn identity (& self) -> PyResult < String > { Ok (self . inner . identity . clone () . into ()) } # [getter] fn is_maker (& self) -> PyResult < bool > { Ok (self . inner . is_maker . clone () . into ()) } # [getter] fn taker_rating (& self) -> PyResult < f64 > { Ok (self . inner . taker_rating . clone () . into ()) } # [getter] fn user_id (& self) -> PyResult < i64 > { Ok (self . inner . user_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetBlockRfqUserInfoResult { inner : venues :: GetBlockRfqUserInfoResult , } # [pymethods] impl GetBlockRfqUserInfoResult { # [staticmethod] fn from_inner (inner : GetBlockRfqUserInfoResult) -> Self { Self { inner } } # [getter] fn parent (& self) -> PyResult < PyObject > { Ok (self . inner . parent . clone () . into ()) } # [getter] fn users (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . users . clone () . into ()) } } # [pymethods] impl RestClient { fn get_block_rfq_user_info <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_block_rfq_user_info () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOrderStateByLabelRequest { inner : venues :: GetOrderStateByLabelRequest , } # [pymethods] impl GetOrderStateByLabelRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderStateByLabelInfo { inner : venues :: OrderStateByLabelInfo , } # [pymethods] impl OrderStateByLabelInfo { # [staticmethod] fn from_inner (inner : OrderStateByLabelInfo) -> Self { Self { inner } } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn order_state (& self) -> PyResult < PyObject > { Ok (self . inner . order_state . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn filled_amount (& self) -> PyResult < f64 > { Ok (self . inner . filled_amount . clone () . into ()) } # [getter] fn average_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . average_price . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn creation_timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . creation_timestamp . clone () . into ()) } # [getter] fn last_update_timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . last_update_timestamp . clone () . into ()) } # [getter] fn cancel_reason (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cancel_reason . clone () . into ()) } # [getter] fn trigger (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger . clone () . into ()) } # [getter] fn trigger_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_price . clone () . into ()) } # [getter] fn trigger_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_order_id . clone () . into ()) } # [getter] fn triggered (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . triggered . clone () . into ()) } # [getter] fn trigger_fill_condition (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_fill_condition . clone () . into ()) } # [getter] fn contracts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contracts . clone () . into ()) } # [getter] fn refresh_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . refresh_amount . clone () . into ()) } # [getter] fn display_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . display_amount . clone () . into ()) } # [getter] fn usd (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . usd . clone () . into ()) } # [getter] fn implv (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . implv . clone () . into ()) } # [getter] fn advanced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . advanced . clone () . into ()) } # [getter] fn oto_order_ids (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . oto_order_ids . clone () . into ()) } # [getter] fn quote (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote . clone () . into ()) } # [getter] fn quote_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_id . clone () . into ()) } # [getter] fn quote_set_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_set_id . clone () . into ()) } # [getter] fn mmp_group (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_group . clone () . into ()) } # [getter] fn mmp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp . clone () . into ()) } # [getter] fn mmp_cancelled (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_cancelled . clone () . into ()) } # [getter] fn is_secondary_oto (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_secondary_oto . clone () . into ()) } # [getter] fn is_primary_otoco (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_primary_otoco . clone () . into ()) } # [getter] fn oco_ref (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . oco_ref . clone () . into ()) } # [getter] fn primary_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . primary_order_id . clone () . into ()) } # [getter] fn post_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . post_only . clone () . into ()) } # [getter] fn reject_post_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reject_post_only . clone () . into ()) } # [getter] fn api (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . api . clone () . into ()) } # [getter] fn mobile (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mobile . clone () . into ()) } # [getter] fn app_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . app_name . clone () . into ()) } # [getter] fn web (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . web . clone () . into ()) } # [getter] fn replaced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . replaced . clone () . into ()) } # [getter] fn auto_replaced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . auto_replaced . clone () . into ()) } # [getter] fn risk_reducing (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . risk_reducing . clone () . into ()) } # [getter] fn reduce_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reduce_only . clone () . into ()) } # [getter] fn is_liquidation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_liquidation . clone () . into ()) } # [getter] fn is_rebalance (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_rebalance . clone () . into ()) } # [getter] fn block_trade (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_trade . clone () . into ()) } # [getter] fn trigger_reference_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_reference_price . clone () . into ()) } # [getter] fn trigger_offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_offset . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_state_by_label <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_state_by_label () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetUserTradesByInstrumentAndTimeRequest { inner : venues :: GetUserTradesByInstrumentAndTimeRequest , } # [pymethods] impl GetUserTradesByInstrumentAndTimeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn start_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . start_timestamp . clone () . into ()) } # [getter] fn end_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . end_timestamp . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn sorting (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sorting . clone () . into ()) } # [getter] fn historical (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . historical . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetUserTradesByInstrumentAndTimeResult { inner : venues :: GetUserTradesByInstrumentAndTimeResult , } # [pymethods] impl GetUserTradesByInstrumentAndTimeResult { # [staticmethod] fn from_inner (inner : GetUserTradesByInstrumentAndTimeResult) -> Self { Self { inner } } # [getter] fn has_more (& self) -> PyResult < bool > { Ok (self . inner . has_more . clone () . into ()) } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } } # [pymethods] impl RestClient { fn get_user_trades_by_instrument_and_time <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_user_trades_by_instrument_and_time () . await }) } } # [pyclass] # [derive (Clone)] pub enum ExecutionInstruction { AllOrNone , AnyPartOf , } # [pyclass] # [derive (Clone)] pub struct AddBlockRfqQuoteRequest { inner : venues :: AddBlockRfqQuoteRequest , } # [pymethods] impl AddBlockRfqQuoteRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn block_rfq_id (& self) -> PyResult < i64 > { Ok (self . inner . block_rfq_id . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn legs (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . legs . clone () . into ()) } # [getter] fn hedge (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . hedge . clone () . into ()) } # [getter] fn execution_instruction (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . execution_instruction . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn expires_at (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . expires_at . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ResponseLeg { inner : venues :: ResponseLeg , } # [pymethods] impl ResponseLeg { # [staticmethod] fn from_inner (inner : ResponseLeg) -> Self { Self { inner } } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn ratio (& self) -> PyResult < i64 > { Ok (self . inner . ratio . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ResponseHedge { inner : venues :: ResponseHedge , } # [pymethods] impl ResponseHedge { # [staticmethod] fn from_inner (inner : ResponseHedge) -> Self { Self { inner } } # [getter] fn amount (& self) -> PyResult < i64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AddBlockRfqQuoteResult { inner : venues :: AddBlockRfqQuoteResult , } # [pymethods] impl AddBlockRfqQuoteResult { # [staticmethod] fn from_inner (inner : AddBlockRfqQuoteResult) -> Self { Self { inner } } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn app_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . app_name . clone () . into ()) } # [getter] fn block_rfq_id (& self) -> PyResult < i64 > { Ok (self . inner . block_rfq_id . clone () . into ()) } # [getter] fn block_rfq_quote_id (& self) -> PyResult < i64 > { Ok (self . inner . block_rfq_quote_id . clone () . into ()) } # [getter] fn creation_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . creation_timestamp . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn execution_instruction (& self) -> PyResult < PyObject > { Ok (self . inner . execution_instruction . clone () . into ()) } # [getter] fn filled_amount (& self) -> PyResult < f64 > { Ok (self . inner . filled_amount . clone () . into ()) } # [getter] fn hedge (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . hedge . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn last_update_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . last_update_timestamp . clone () . into ()) } # [getter] fn legs (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . legs . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn quote_state (& self) -> PyResult < String > { Ok (self . inner . quote_state . clone () . into ()) } # [getter] fn quote_state_reason (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_state_reason . clone () . into ()) } # [getter] fn replaced (& self) -> PyResult < bool > { Ok (self . inner . replaced . clone () . into ()) } } # [pymethods] impl RestClient { fn add_block_rfq_quote <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . add_block_rfq_quote () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetUserTradesByCurrencyAndTimeRequest { inner : venues :: GetUserTradesByCurrencyAndTimeRequest , } # [pymethods] impl GetUserTradesByCurrencyAndTimeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . kind . clone () . into ()) } # [getter] fn start_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . start_timestamp . clone () . into ()) } # [getter] fn end_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . end_timestamp . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn sorting (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sorting . clone () . into ()) } # [getter] fn historical (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . historical . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetUserTradesByCurrencyAndTimeResult { inner : venues :: GetUserTradesByCurrencyAndTimeResult , } # [pymethods] impl GetUserTradesByCurrencyAndTimeResult { # [staticmethod] fn from_inner (inner : GetUserTradesByCurrencyAndTimeResult) -> Self { Self { inner } } # [getter] fn has_more (& self) -> PyResult < bool > { Ok (self . inner . has_more . clone () . into ()) } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } } # [pymethods] impl RestClient { fn get_user_trades_by_currency_and_time <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_user_trades_by_currency_and_time () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOpenOrdersByInstrumentRequest { inner : venues :: GetOpenOrdersByInstrumentRequest , } # [pymethods] impl GetOpenOrdersByInstrumentRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn r#type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . r#type . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OpenOrder { inner : venues :: OpenOrder , } # [pymethods] impl OpenOrder { # [staticmethod] fn from_inner (inner : OpenOrder) -> Self { Self { inner } } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn price (& self) -> PyResult < PyObject > { Ok (self . inner . price . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn order_state (& self) -> PyResult < PyObject > { Ok (self . inner . order_state . clone () . into ()) } # [getter] fn creation_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . creation_timestamp . clone () . into ()) } # [getter] fn last_update_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . last_update_timestamp . clone () . into ()) } # [getter] fn filled_amount (& self) -> PyResult < f64 > { Ok (self . inner . filled_amount . clone () . into ()) } # [getter] fn average_price (& self) -> PyResult < f64 > { Ok (self . inner . average_price . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn post_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . post_only . clone () . into ()) } # [getter] fn reduce_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reduce_only . clone () . into ()) } # [getter] fn trigger (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger . clone () . into ()) } # [getter] fn triggered (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . triggered . clone () . into ()) } # [getter] fn trigger_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_price . clone () . into ()) } # [getter] fn trigger_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_order_id . clone () . into ()) } # [getter] fn advanced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . advanced . clone () . into ()) } # [getter] fn usd (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . usd . clone () . into ()) } # [getter] fn implv (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . implv . clone () . into ()) } # [getter] fn contracts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contracts . clone () . into ()) } # [getter] fn display_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . display_amount . clone () . into ()) } # [getter] fn refresh_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . refresh_amount . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn is_liquidation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_liquidation . clone () . into ()) } # [getter] fn is_secondary_oto (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_secondary_oto . clone () . into ()) } # [getter] fn is_primary_otoco (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_primary_otoco . clone () . into ()) } # [getter] fn replaced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . replaced . clone () . into ()) } # [getter] fn auto_replaced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . auto_replaced . clone () . into ()) } # [getter] fn cancel_reason (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cancel_reason . clone () . into ()) } # [getter] fn mmp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp . clone () . into ()) } # [getter] fn mmp_group (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_group . clone () . into ()) } # [getter] fn mmp_cancelled (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_cancelled . clone () . into ()) } # [getter] fn quote (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote . clone () . into ()) } # [getter] fn quote_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_id . clone () . into ()) } # [getter] fn quote_set_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_set_id . clone () . into ()) } # [getter] fn oco_ref (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . oco_ref . clone () . into ()) } # [getter] fn oto_order_ids (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . oto_order_ids . clone () . into ()) } # [getter] fn primary_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . primary_order_id . clone () . into ()) } # [getter] fn app_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . app_name . clone () . into ()) } # [getter] fn api (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . api . clone () . into ()) } # [getter] fn web (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . web . clone () . into ()) } # [getter] fn mobile (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mobile . clone () . into ()) } # [getter] fn block_trade (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_trade . clone () . into ()) } # [getter] fn risk_reducing (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . risk_reducing . clone () . into ()) } # [getter] fn original_order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . original_order_type . clone () . into ()) } # [getter] fn reject_post_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reject_post_only . clone () . into ()) } # [getter] fn is_rebalance (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_rebalance . clone () . into ()) } # [getter] fn trigger_reference_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_reference_price . clone () . into ()) } # [getter] fn trigger_offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_offset . clone () . into ()) } # [getter] fn trigger_fill_condition (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_fill_condition . clone () . into ()) } } # [pymethods] impl RestClient { fn get_open_orders_by_instrument <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_open_orders_by_instrument () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetUserTradesByOrderRequest { inner : venues :: GetUserTradesByOrderRequest , } # [pymethods] impl GetUserTradesByOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn sorting (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sorting . clone () . into ()) } # [getter] fn historical (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . historical . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetUserTradesByOrderResult { inner : venues :: GetUserTradesByOrderResult , } # [pymethods] impl GetUserTradesByOrderResult { # [staticmethod] fn from_inner (inner : GetUserTradesByOrderResult) -> Self { Self { inner } } # [getter] fn has_more (& self) -> PyResult < bool > { Ok (self . inner . has_more . clone () . into ()) } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } } # [pymethods] impl RestClient { fn get_user_trades_by_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_user_trades_by_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct InvalidateBlockTradeSignatureRequest { inner : venues :: InvalidateBlockTradeSignatureRequest , } # [pymethods] impl InvalidateBlockTradeSignatureRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn signature (& self) -> PyResult < String > { Ok (self . inner . signature . clone () . into ()) } } # [pymethods] impl RestClient { fn invalidate_block_trade_signature <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . invalidate_block_trade_signature () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetTransfersRequest { inner : venues :: GetTransfersRequest , } # [pymethods] impl GetTransfersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetTransfersResult { inner : venues :: GetTransfersResult , } # [pymethods] impl GetTransfersResult { # [staticmethod] fn from_inner (inner : GetTransfersResult) -> Self { Self { inner } } # [getter] fn count (& self) -> PyResult < i64 > { Ok (self . inner . count . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_transfers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_transfers () . await }) } } # [pyclass] # [derive (Clone)] pub struct DepositData { inner : venues :: DepositData , } # [pymethods] impl DepositData { # [staticmethod] fn from_inner (inner : DepositData) -> Self { Self { inner } } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn clearance_state (& self) -> PyResult < PyObject > { Ok (self . inner . clearance_state . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn note (& self) -> PyResult < String > { Ok (self . inner . note . clone () . into ()) } # [getter] fn received_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . received_timestamp . clone () . into ()) } # [getter] fn refund_transaction_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . refund_transaction_id . clone () . into ()) } # [getter] fn source_address (& self) -> PyResult < String > { Ok (self . inner . source_address . clone () . into ()) } # [getter] fn state (& self) -> PyResult < PyObject > { Ok (self . inner . state . clone () . into ()) } # [getter] fn transaction_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . transaction_id . clone () . into ()) } # [getter] fn updated_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . updated_timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetDepositsRequest { inner : venues :: GetDepositsRequest , } # [pymethods] impl GetDepositsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetDepositsResult { inner : venues :: GetDepositsResult , } # [pymethods] impl GetDepositsResult { # [staticmethod] fn from_inner (inner : GetDepositsResult) -> Self { Self { inner } } # [getter] fn count (& self) -> PyResult < i64 > { Ok (self . inner . count . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_deposits <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_deposits () . await }) } } # [pyclass] # [derive (Clone)] pub struct UpdateInAddressBookRequest { inner : venues :: UpdateInAddressBookRequest , } # [pymethods] impl UpdateInAddressBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn address_type (& self) -> PyResult < PyObject > { Ok (self . inner . address_type . clone () . into ()) } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn beneficiary_vasp_name (& self) -> PyResult < String > { Ok (self . inner . beneficiary_vasp_name . clone () . into ()) } # [getter] fn beneficiary_vasp_did (& self) -> PyResult < String > { Ok (self . inner . beneficiary_vasp_did . clone () . into ()) } # [getter] fn beneficiary_vasp_website (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . beneficiary_vasp_website . clone () . into ()) } # [getter] fn beneficiary_first_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . beneficiary_first_name . clone () . into ()) } # [getter] fn beneficiary_last_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . beneficiary_last_name . clone () . into ()) } # [getter] fn beneficiary_company_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . beneficiary_company_name . clone () . into ()) } # [getter] fn beneficiary_address (& self) -> PyResult < String > { Ok (self . inner . beneficiary_address . clone () . into ()) } # [getter] fn agreed (& self) -> PyResult < bool > { Ok (self . inner . agreed . clone () . into ()) } # [getter] fn personal (& self) -> PyResult < bool > { Ok (self . inner . personal . clone () . into ()) } # [getter] fn label (& self) -> PyResult < String > { Ok (self . inner . label . clone () . into ()) } } # [pymethods] impl RestClient { fn update_in_address_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . update_in_address_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetUserTradesByCurrencyRequest { inner : venues :: GetUserTradesByCurrencyRequest , } # [pymethods] impl GetUserTradesByCurrencyRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . kind . clone () . into ()) } # [getter] fn start_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_id . clone () . into ()) } # [getter] fn end_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_id . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn start_timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_timestamp . clone () . into ()) } # [getter] fn end_timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_timestamp . clone () . into ()) } # [getter] fn sorting (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sorting . clone () . into ()) } # [getter] fn historical (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . historical . clone () . into ()) } # [getter] fn subaccount_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . subaccount_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct Trade { inner : venues :: Trade , } # [pymethods] impl Trade { # [staticmethod] fn from_inner (inner : Trade) -> Self { Self { inner } } # [getter] fn trade_id (& self) -> PyResult < String > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn tick_direction (& self) -> PyResult < PyObject > { Ok (self . inner . tick_direction . clone () . into ()) } # [getter] fn fee_currency (& self) -> PyResult < String > { Ok (self . inner . fee_currency . clone () . into ()) } # [getter] fn api (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . api . clone () . into ()) } # [getter] fn advanced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . advanced . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn liquidity (& self) -> PyResult < PyObject > { Ok (self . inner . liquidity . clone () . into ()) } # [getter] fn post_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . post_only . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn contracts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contracts . clone () . into ()) } # [getter] fn mmp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < f64 > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn quote_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_id . clone () . into ()) } # [getter] fn index_price (& self) -> PyResult < f64 > { Ok (self . inner . index_price . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn block_trade_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_trade_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn combo_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . combo_id . clone () . into ()) } # [getter] fn matching_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . matching_id . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn profit_loss (& self) -> PyResult < f64 > { Ok (self . inner . profit_loss . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn iv (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . iv . clone () . into ()) } # [getter] fn state (& self) -> PyResult < PyObject > { Ok (self . inner . state . clone () . into ()) } # [getter] fn underlying_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . underlying_price . clone () . into ()) } # [getter] fn block_rfq_quote_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq_quote_id . clone () . into ()) } # [getter] fn quote_set_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_set_id . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < f64 > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn block_rfq_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq_id . clone () . into ()) } # [getter] fn combo_trade_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . combo_trade_id . clone () . into ()) } # [getter] fn reduce_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reduce_only . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn liquidation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . liquidation . clone () . into ()) } # [getter] fn trade_seq (& self) -> PyResult < i64 > { Ok (self . inner . trade_seq . clone () . into ()) } # [getter] fn risk_reducing (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . risk_reducing . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn legs (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . legs . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetUserTradesByCurrencyResult { inner : venues :: GetUserTradesByCurrencyResult , } # [pymethods] impl GetUserTradesByCurrencyResult { # [staticmethod] fn from_inner (inner : GetUserTradesByCurrencyResult) -> Self { Self { inner } } # [getter] fn has_more (& self) -> PyResult < bool > { Ok (self . inner . has_more . clone () . into ()) } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } } # [pymethods] impl RestClient { fn get_user_trades_by_currency <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_user_trades_by_currency () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateComboTrade { inner : venues :: CreateComboTrade , } # [pymethods] impl CreateComboTrade { # [staticmethod] fn from_inner (inner : CreateComboTrade) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . amount . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < String > { Ok (self . inner . direction . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateComboRequest { inner : venues :: CreateComboRequest , } # [pymethods] impl CreateComboRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateComboResult { inner : venues :: CreateComboResult , } # [pymethods] impl CreateComboResult { # [staticmethod] fn from_inner (inner : CreateComboResult) -> Self { Self { inner } } # [getter] fn creation_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . creation_timestamp . clone () . into ()) } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn instrument_id (& self) -> PyResult < i64 > { Ok (self . inner . instrument_id . clone () . into ()) } # [getter] fn legs (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . legs . clone () . into ()) } # [getter] fn state (& self) -> PyResult < String > { Ok (self . inner . state . clone () . into ()) } # [getter] fn state_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . state_timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn create_combo <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_combo () . await }) } } # [pyclass] # [derive (Clone)] pub struct SetClearanceOriginatorRequest { inner : venues :: SetClearanceOriginatorRequest , } # [pymethods] impl SetClearanceOriginatorRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn deposit_id (& self) -> PyResult < PyObject > { Ok (self . inner . deposit_id . clone () . into ()) } # [getter] fn originator (& self) -> PyResult < PyObject > { Ok (self . inner . originator . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SetClearanceOriginatorResult { inner : venues :: SetClearanceOriginatorResult , } # [pymethods] impl SetClearanceOriginatorResult { # [staticmethod] fn from_inner (inner : SetClearanceOriginatorResult) -> Self { Self { inner } } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn clearance_state (& self) -> PyResult < String > { Ok (self . inner . clearance_state . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn note (& self) -> PyResult < String > { Ok (self . inner . note . clone () . into ()) } # [getter] fn received_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . received_timestamp . clone () . into ()) } # [getter] fn refund_transaction_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . refund_transaction_id . clone () . into ()) } # [getter] fn source_address (& self) -> PyResult < String > { Ok (self . inner . source_address . clone () . into ()) } # [getter] fn state (& self) -> PyResult < String > { Ok (self . inner . state . clone () . into ()) } # [getter] fn transaction_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . transaction_id . clone () . into ()) } # [getter] fn updated_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . updated_timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn set_clearance_originator <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . set_clearance_originator () . await }) } } # [pyclass] # [derive (Clone)] pub enum CancelType { Delta , QuoteSetId , Instrument , InstrumentKind , Currency , CurrencyPair , All , } # [pyclass] # [derive (Clone)] pub struct CancelQuotesRequest { inner : venues :: CancelQuotesRequest , } # [pymethods] impl CancelQuotesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn cancel_type (& self) -> PyResult < PyObject > { Ok (self . inner . cancel_type . clone () . into ()) } # [getter] fn detailed (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . detailed . clone () . into ()) } # [getter] fn freeze_quotes (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . freeze_quotes . clone () . into ()) } # [getter] fn min_delta (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . min_delta . clone () . into ()) } # [getter] fn max_delta (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . max_delta . clone () . into ()) } # [getter] fn quote_set_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_set_id . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . kind . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_quotes <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_quotes () . await }) } } # [pyclass] # [derive (Clone)] pub enum Side { Buy , Sell , } # [pyclass] # [derive (Clone)] pub struct SendRfqRequest { inner : venues :: SendRfqRequest , } # [pymethods] impl SendRfqRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . amount . clone () . into ()) } # [getter] fn side (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . side . clone () . into ()) } } # [pymethods] impl RestClient { fn send_rfq <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_rfq () . await }) } } # [pyclass] # [derive (Clone)] pub struct EditBlockRfqQuoteRequest { inner : venues :: EditBlockRfqQuoteRequest , } # [pymethods] impl EditBlockRfqQuoteRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn legs (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . legs . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn block_rfq_quote_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq_quote_id . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn hedge (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . hedge . clone () . into ()) } # [getter] fn block_rfq_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } } # [pymethods] impl RestClient { fn edit_block_rfq_quote <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . edit_block_rfq_quote () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOrderMarginByIdsRequest { inner : venues :: GetOrderMarginByIdsRequest , } # [pymethods] impl GetOrderMarginByIdsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn ids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . ids . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderMarginInfo { inner : venues :: OrderMarginInfo , } # [pymethods] impl OrderMarginInfo { # [staticmethod] fn from_inner (inner : OrderMarginInfo) -> Self { Self { inner } } # [getter] fn initial_margin (& self) -> PyResult < f64 > { Ok (self . inner . initial_margin . clone () . into ()) } # [getter] fn initial_margin_currency (& self) -> PyResult < String > { Ok (self . inner . initial_margin_currency . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_margin_by_ids <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_margin_by_ids () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetPendingBlockTradesRequest { inner : venues :: GetPendingBlockTradesRequest , } # [pymethods] impl GetPendingBlockTradesRequest { # [staticmethod] fn from_inner (inner : GetPendingBlockTradesRequest) -> Self { Self { inner } } } # [pyclass] # [derive (Clone)] pub struct PendingBlockTradeState { inner : venues :: PendingBlockTradeState , } # [pymethods] impl PendingBlockTradeState { # [staticmethod] fn from_inner (inner : PendingBlockTradeState) -> Self { Self { inner } } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn value (& self) -> PyResult < String > { Ok (self . inner . value . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct PendingBlockTradeTrade { inner : venues :: PendingBlockTradeTrade , } # [pymethods] impl PendingBlockTradeTrade { # [staticmethod] fn from_inner (inner : PendingBlockTradeTrade) -> Self { Self { inner } } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < PyObject > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct PendingBlockTrade { inner : venues :: PendingBlockTrade , } # [pymethods] impl PendingBlockTrade { # [staticmethod] fn from_inner (inner : PendingBlockTrade) -> Self { Self { inner } } # [getter] fn app_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . app_name . clone () . into ()) } # [getter] fn counterparty_state (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . counterparty_state . clone () . into ()) } # [getter] fn nonce (& self) -> PyResult < String > { Ok (self . inner . nonce . clone () . into ()) } # [getter] fn role (& self) -> PyResult < PyObject > { Ok (self . inner . role . clone () . into ()) } # [getter] fn state (& self) -> PyResult < PyObject > { Ok (self . inner . state . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } # [getter] fn user_id (& self) -> PyResult < i64 > { Ok (self . inner . user_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub enum PendingBlockTradeRole { Maker , Taker , } # [pymethods] impl RestClient { fn get_pending_block_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_pending_block_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetCurrentDepositAddressRequest { inner : venues :: GetCurrentDepositAddressRequest , } # [pymethods] impl GetCurrentDepositAddressRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } } # [pymethods] impl RestClient { fn get_current_deposit_address <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_current_deposit_address () . await }) } } # [pyclass] # [derive (Clone)] pub struct SubmitTransferToUserRequest { inner : venues :: SubmitTransferToUserRequest , } # [pymethods] impl SubmitTransferToUserRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn destination (& self) -> PyResult < String > { Ok (self . inner . destination . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TransferData { inner : venues :: TransferData , } # [pymethods] impl TransferData { # [staticmethod] fn from_inner (inner : TransferData) -> Self { Self { inner } } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn created_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . created_timestamp . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < String > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn other_side (& self) -> PyResult < String > { Ok (self . inner . other_side . clone () . into ()) } # [getter] fn state (& self) -> PyResult < String > { Ok (self . inner . state . clone () . into ()) } # [getter] fn transfer_type (& self) -> PyResult < String > { Ok (self . inner . transfer_type . clone () . into ()) } # [getter] fn updated_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . updated_timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn submit_transfer_to_user <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . submit_transfer_to_user () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetMmpStatusRequest { inner : venues :: GetMmpStatusRequest , } # [pymethods] impl GetMmpStatusRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn index_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . index_name . clone () . into ()) } # [getter] fn mmp_group (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_group . clone () . into ()) } # [getter] fn block_rfq (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct MmpStatus { inner : venues :: MmpStatus , } # [pymethods] impl MmpStatus { # [staticmethod] fn from_inner (inner : MmpStatus) -> Self { Self { inner } } # [getter] fn block_rfq (& self) -> PyResult < bool > { Ok (self . inner . block_rfq . clone () . into ()) } # [getter] fn frozen_until (& self) -> PyResult < i64 > { Ok (self . inner . frozen_until . clone () . into ()) } # [getter] fn index_name (& self) -> PyResult < String > { Ok (self . inner . index_name . clone () . into ()) } # [getter] fn mmp_group (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_group . clone () . into ()) } } # [pymethods] impl RestClient { fn get_mmp_status <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_mmp_status () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetBlockRfqQuotesRequest { inner : venues :: GetBlockRfqQuotesRequest , } # [pymethods] impl GetBlockRfqQuotesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn block_rfq_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq_id . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn block_rfq_quote_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . block_rfq_quote_id . clone () . into ()) } } # [pymethods] impl RestClient { fn get_block_rfq_quotes <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_block_rfq_quotes () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelBlockRfqRequest { inner : venues :: CancelBlockRfqRequest , } # [pymethods] impl CancelBlockRfqRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn block_rfq_id (& self) -> PyResult < i64 > { Ok (self . inner . block_rfq_id . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_block_rfq <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_block_rfq () . await }) } } # [pyclass] # [derive (Clone)] pub struct ErrorResponse { inner : venues :: ErrorResponse , } # [pymethods] impl ErrorResponse { # [staticmethod] fn from_inner (inner : ErrorResponse) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < i64 > { Ok (self . inner . code . clone () . into ()) } # [getter] fn message (& self) -> PyResult < String > { Ok (self . inner . message . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub enum AccountTier { Tier1 , Tier2 , Tier3 , Tier4 , } # [pyclass] # [derive (Clone)] pub enum EndpointType { NonMatchingEngine , MatchingEngine , PublicGetInstruments , PublicGetComboIds , PublicGetCombos , PublicGetComboDetails , PublicGetStatus , PublicHello , } # [pyclass] # [derive (Clone)] pub struct RateLimiter { inner : venues :: RateLimiter , } # [pymethods] impl RateLimiter { # [staticmethod] fn from_inner (inner : RateLimiter) -> Self { Self { inner } } } # [pyclass] # [derive (Clone)] pub struct RateLimitStatus { inner : venues :: RateLimitStatus , } # [pymethods] impl RateLimitStatus { # [staticmethod] fn from_inner (inner : RateLimitStatus) -> Self { Self { inner } } # [getter] fn available_credits (& self) -> PyResult < u64 > { Ok (self . inner . available_credits . clone () . into ()) } # [getter] fn max_credits (& self) -> PyResult < u64 > { Ok (self . inner . max_credits . clone () . into ()) } # [getter] fn credit_refill_rate (& self) -> PyResult < u64 > { Ok (self . inner . credit_refill_rate . clone () . into ()) } # [getter] fn account_tier (& self) -> PyResult < PyObject > { Ok (self . inner . account_tier . clone () . into ()) } # [getter] fn matching_engine_requests_in_window (& self) -> PyResult < u64 > { Ok (self . inner . matching_engine_requests_in_window . clone () . into ()) } # [getter] fn instruments_requests_in_window (& self) -> PyResult < u64 > { Ok (self . inner . instruments_requests_in_window . clone () . into ()) } } # [doc = " Create the Python module for deribit"] pub fn create_module (py : Python) -> PyResult <& PyModule > { let m = PyModule :: new (py , "deribit") ?; Ok (m) }