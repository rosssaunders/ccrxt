# ! [doc = " Python bindings for coinbaseexchange venue"] # ! [doc = ""] # ! [doc = " This module is automatically generated from the Rust source code."] # ! [doc = " Do not edit this file directly."] use pyo3 :: prelude ::*; use pyo3_asyncio ; use venues ; # [pyclass] # [derive (Clone)] pub enum OrderSide { Buy , Sell , } # [pyclass] # [derive (Clone)] pub enum OrderType { Limit , Market , Stop , } # [pyclass] # [derive (Clone)] pub enum TimeInForce { GoodTillCanceled , GoodTillTime , ImmediateOrCancel , FillOrKill , } # [pyclass] # [derive (Clone)] pub enum OrderStatus { Open , Pending , Rejected , Done , Active , Received , All , } # [pyclass] # [derive (Clone)] pub enum SelfTradePrevention { DecrementAndCancel , CancelOldest , CancelNewest , CancelBoth , } # [pyclass] # [derive (Clone)] pub enum StopDirection { Loss , Entry , } # [pyclass] # [derive (Clone)] pub enum Liquidity { M , T , O , } # [pyclass] # [derive (Clone)] pub struct GetProductCandlesRequest { inner : venues :: GetProductCandlesRequest , } # [pymethods] impl GetProductCandlesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn granularity (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . granularity . clone () . into ()) } # [getter] fn start (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start . clone () . into ()) } # [getter] fn end (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end . clone () . into ()) } } # [pymethods] impl RestClient { fn get_product_candles <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_product_candles () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetProductVolumeSummaryRequest { inner : venues :: GetProductVolumeSummaryRequest , } # [pymethods] impl GetProductVolumeSummaryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } } # [pymethods] impl RestClient { fn get_product_volume_summary <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_product_volume_summary () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetProductTradesRequest { inner : venues :: GetProductTradesRequest , } # [pymethods] impl GetProductTradesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn before (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . before . clone () . into ()) } # [getter] fn after (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . after . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct Trade { inner : venues :: Trade , } # [pymethods] impl Trade { # [staticmethod] fn from_inner (inner : Trade) -> Self { Self { inner } } # [getter] fn trade_id (& self) -> PyResult < u64 > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn size (& self) -> PyResult < String > { Ok (self . inner . size . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn time (& self) -> PyResult < PyObject > { Ok (self . inner . time . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct PaginationInfo { inner : venues :: PaginationInfo , } # [pymethods] impl PaginationInfo { # [staticmethod] fn from_inner (inner : PaginationInfo) -> Self { Self { inner } } # [getter] fn before (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . before . clone () . into ()) } # [getter] fn after (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . after . clone () . into ()) } } # [pymethods] impl RestClient { fn get_product_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_product_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } # [getter] fn base_url (& self) -> PyResult < PyObject > { Ok (self . inner . base_url . clone () . into ()) } # [getter] fn client (& self) -> PyResult < PyObject > { Ok (self . inner . client . clone () . into ()) } # [getter] fn rate_limiter (& self) -> PyResult < PyObject > { Ok (self . inner . rate_limiter . clone () . into ()) } } # [pymethods] impl RestClient { fn send_request_with_headers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_request_with_headers () . await }) } fn send_request <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_request () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetProductRequest { inner : venues :: GetProductRequest , } # [pymethods] impl GetProductRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } } # [pymethods] impl RestClient { fn get_product <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_product () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetProductTickerRequest { inner : venues :: GetProductTickerRequest , } # [pymethods] impl GetProductTickerRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } } # [pyclass] # [derive (Clone)] pub struct ProductTicker { inner : venues :: ProductTicker , } # [pymethods] impl ProductTicker { # [staticmethod] fn from_inner (inner : ProductTicker) -> Self { Self { inner } } # [getter] fn ask (& self) -> PyResult < String > { Ok (self . inner . ask . clone () . into ()) } # [getter] fn bid (& self) -> PyResult < String > { Ok (self . inner . bid . clone () . into ()) } # [getter] fn volume (& self) -> PyResult < String > { Ok (self . inner . volume . clone () . into ()) } # [getter] fn trade_id (& self) -> PyResult < u64 > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn size (& self) -> PyResult < String > { Ok (self . inner . size . clone () . into ()) } # [getter] fn time (& self) -> PyResult < PyObject > { Ok (self . inner . time . clone () . into ()) } # [getter] fn rfq_volume (& self) -> PyResult < String > { Ok (self . inner . rfq_volume . clone () . into ()) } # [getter] fn conversions_volume (& self) -> PyResult < String > { Ok (self . inner . conversions_volume . clone () . into ()) } } # [pymethods] impl RestClient { fn get_product_ticker <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_product_ticker () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetProductsRequest { inner : venues :: GetProductsRequest , } # [pymethods] impl GetProductsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn r#type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . r#type . clone () . into ()) } } # [pymethods] impl RestClient { fn get_products <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_products () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetProductBookRequest { inner : venues :: GetProductBookRequest , } # [pymethods] impl GetProductBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn level (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . level . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub enum OrderBookLevel { Aggregated , NonAggregated , } # [pyclass] # [derive (Clone)] pub struct AuctionInfo { inner : venues :: AuctionInfo , } # [pymethods] impl AuctionInfo { # [staticmethod] fn from_inner (inner : AuctionInfo) -> Self { Self { inner } } # [getter] fn open_price (& self) -> PyResult < String > { Ok (self . inner . open_price . clone () . into ()) } # [getter] fn open_size (& self) -> PyResult < String > { Ok (self . inner . open_size . clone () . into ()) } # [getter] fn best_bid_price (& self) -> PyResult < String > { Ok (self . inner . best_bid_price . clone () . into ()) } # [getter] fn best_bid_size (& self) -> PyResult < String > { Ok (self . inner . best_bid_size . clone () . into ()) } # [getter] fn best_ask_price (& self) -> PyResult < String > { Ok (self . inner . best_ask_price . clone () . into ()) } # [getter] fn best_ask_size (& self) -> PyResult < String > { Ok (self . inner . best_ask_size . clone () . into ()) } # [getter] fn auction_state (& self) -> PyResult < String > { Ok (self . inner . auction_state . clone () . into ()) } # [getter] fn can_open (& self) -> PyResult < String > { Ok (self . inner . can_open . clone () . into ()) } # [getter] fn time (& self) -> PyResult < PyObject > { Ok (self . inner . time . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetProductBookResponse { inner : venues :: GetProductBookResponse , } # [pymethods] impl GetProductBookResponse { # [staticmethod] fn from_inner (inner : GetProductBookResponse) -> Self { Self { inner } } # [getter] fn bids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . bids . clone () . into ()) } # [getter] fn asks (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . asks . clone () . into ()) } # [getter] fn sequence (& self) -> PyResult < f64 > { Ok (self . inner . sequence . clone () . into ()) } # [getter] fn auction_mode (& self) -> PyResult < bool > { Ok (self . inner . auction_mode . clone () . into ()) } # [getter] fn auction (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . auction . clone () . into ()) } # [getter] fn time (& self) -> PyResult < PyObject > { Ok (self . inner . time . clone () . into ()) } } # [pymethods] impl RestClient { fn get_product_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_product_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetProductStatsRequest { inner : venues :: GetProductStatsRequest , } # [pymethods] impl GetProductStatsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } } # [pyclass] # [derive (Clone)] pub struct ProductStats { inner : venues :: ProductStats , } # [pymethods] impl ProductStats { # [staticmethod] fn from_inner (inner : ProductStats) -> Self { Self { inner } } # [getter] fn open (& self) -> PyResult < String > { Ok (self . inner . open . clone () . into ()) } # [getter] fn high (& self) -> PyResult < String > { Ok (self . inner . high . clone () . into ()) } # [getter] fn low (& self) -> PyResult < String > { Ok (self . inner . low . clone () . into ()) } # [getter] fn last (& self) -> PyResult < String > { Ok (self . inner . last . clone () . into ()) } # [getter] fn volume (& self) -> PyResult < String > { Ok (self . inner . volume . clone () . into ()) } # [getter] fn volume_30day (& self) -> PyResult < String > { Ok (self . inner . volume_30day . clone () . into ()) } # [getter] fn rfq_volume_24hour (& self) -> PyResult < String > { Ok (self . inner . rfq_volume_24hour . clone () . into ()) } # [getter] fn rfq_volume_30day (& self) -> PyResult < String > { Ok (self . inner . rfq_volume_30day . clone () . into ()) } # [getter] fn conversions_volume_24hour (& self) -> PyResult < String > { Ok (self . inner . conversions_volume_24hour . clone () . into ()) } # [getter] fn conversions_volume_30day (& self) -> PyResult < String > { Ok (self . inner . conversions_volume_30day . clone () . into ()) } } # [pymethods] impl RestClient { fn get_product_stats <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_product_stats () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } # [getter] fn base_url (& self) -> PyResult < PyObject > { Ok (self . inner . base_url . clone () . into ()) } # [getter] fn client (& self) -> PyResult < PyObject > { Ok (self . inner . client . clone () . into ()) } # [getter] fn rate_limiter (& self) -> PyResult < PyObject > { Ok (self . inner . rate_limiter . clone () . into ()) } } # [pymethods] impl RestClient { fn sign_request (& self) -> PyResult < () > { self . inner . sign_request () ; Ok (()) } fn send_request_with_headers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_request_with_headers () . await }) } fn send_request_with_pagination <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_request_with_pagination () . await }) } fn send_request <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_request () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateOrderRequest { inner : venues :: CreateOrderRequest , } # [pymethods] impl CreateOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn profile_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . profile_id . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn product_id (& self) -> PyResult < String > { Ok (self . inner . product_id . clone () . into ()) } # [getter] fn stp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp . clone () . into ()) } # [getter] fn stop (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_price . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . size . clone () . into ()) } # [getter] fn funds (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . funds . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn cancel_after (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cancel_after . clone () . into ()) } # [getter] fn post_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . post_only . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_oid . clone () . into ()) } # [getter] fn max_floor (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . max_floor . clone () . into ()) } # [getter] fn stop_limit_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_limit_price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateOrderResponse { inner : venues :: CreateOrderResponse , } # [pymethods] impl CreateOrderResponse { # [staticmethod] fn from_inner (inner : CreateOrderResponse) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn size (& self) -> PyResult < String > { Ok (self . inner . size . clone () . into ()) } # [getter] fn product_id (& self) -> PyResult < String > { Ok (self . inner . product_id . clone () . into ()) } # [getter] fn profile_id (& self) -> PyResult < String > { Ok (self . inner . profile_id . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn funds (& self) -> PyResult < String > { Ok (self . inner . funds . clone () . into ()) } # [getter] fn specified_funds (& self) -> PyResult < String > { Ok (self . inner . specified_funds . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < PyObject > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn expire_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . expire_time . clone () . into ()) } # [getter] fn post_only (& self) -> PyResult < bool > { Ok (self . inner . post_only . clone () . into ()) } # [getter] fn created_at (& self) -> PyResult < PyObject > { Ok (self . inner . created_at . clone () . into ()) } # [getter] fn done_at (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . done_at . clone () . into ()) } # [getter] fn done_reason (& self) -> PyResult < String > { Ok (self . inner . done_reason . clone () . into ()) } # [getter] fn reject_reason (& self) -> PyResult < String > { Ok (self . inner . reject_reason . clone () . into ()) } # [getter] fn fill_fees (& self) -> PyResult < String > { Ok (self . inner . fill_fees . clone () . into ()) } # [getter] fn filled_size (& self) -> PyResult < String > { Ok (self . inner . filled_size . clone () . into ()) } # [getter] fn executed_value (& self) -> PyResult < String > { Ok (self . inner . executed_value . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn settled (& self) -> PyResult < bool > { Ok (self . inner . settled . clone () . into ()) } # [getter] fn stop (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < String > { Ok (self . inner . stop_price . clone () . into ()) } # [getter] fn funding_amount (& self) -> PyResult < String > { Ok (self . inner . funding_amount . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < String > { Ok (self . inner . client_oid . clone () . into ()) } # [getter] fn market_type (& self) -> PyResult < String > { Ok (self . inner . market_type . clone () . into ()) } # [getter] fn stop_limit_price (& self) -> PyResult < String > { Ok (self . inner . stop_limit_price . clone () . into ()) } } # [pymethods] impl RestClient { fn create_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct AccountBalance { inner : venues :: AccountBalance , } # [pymethods] impl AccountBalance { # [staticmethod] fn from_inner (inner : AccountBalance) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn balance (& self) -> PyResult < String > { Ok (self . inner . balance . clone () . into ()) } # [getter] fn hold (& self) -> PyResult < String > { Ok (self . inner . hold . clone () . into ()) } # [getter] fn available (& self) -> PyResult < String > { Ok (self . inner . available . clone () . into ()) } # [getter] fn profile_id (& self) -> PyResult < String > { Ok (self . inner . profile_id . clone () . into ()) } # [getter] fn trading_enabled (& self) -> PyResult < bool > { Ok (self . inner . trading_enabled . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetAccountBalancesRequest { inner : venues :: GetAccountBalancesRequest , } # [pymethods] impl GetAccountBalancesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn before (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . before . clone () . into ()) } # [getter] fn after (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . after . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetAccountBalancesResponse { inner : venues :: GetAccountBalancesResponse , } # [pymethods] impl GetAccountBalancesResponse { # [staticmethod] fn from_inner (inner : GetAccountBalancesResponse) -> Self { Self { inner } } # [getter] fn accounts (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . accounts . clone () . into ()) } # [getter] fn pagination (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . pagination . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct PaginationInfo { inner : venues :: PaginationInfo , } # [pymethods] impl PaginationInfo { # [staticmethod] fn from_inner (inner : PaginationInfo) -> Self { Self { inner } } # [getter] fn before (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . before . clone () . into ()) } # [getter] fn after (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . after . clone () . into ()) } } # [pymethods] impl RestClient { fn get_account_balances <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_account_balances () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelAllOrdersRequest { inner : venues :: CancelAllOrdersRequest , } # [pymethods] impl CancelAllOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn profile_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . profile_id . clone () . into ()) } # [getter] fn product_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . product_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelOrderRequest { inner : venues :: CancelOrderRequest , } # [pymethods] impl CancelOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn profile_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . profile_id . clone () . into ()) } # [getter] fn product_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . product_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub enum CancelOrderResponse { OrderId , ClientOrderId , } # [pymethods] impl RestClient { fn cancel_all_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_orders () . await }) } fn cancel_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetFillsRequest { inner : venues :: GetFillsRequest , } # [pymethods] impl GetFillsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn product_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . product_id . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn before (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . before . clone () . into ()) } # [getter] fn after (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . after . clone () . into ()) } # [getter] fn market_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . market_type . clone () . into ()) } # [getter] fn start_date (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_date . clone () . into ()) } # [getter] fn end_date (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_date . clone () . into ()) } } # [pymethods] impl RestClient { fn get_fills <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_fills () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOrdersRequest { inner : venues :: GetOrdersRequest , } # [pymethods] impl GetOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn profile_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . profile_id . clone () . into ()) } # [getter] fn product_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . product_id . clone () . into ()) } # [getter] fn sorted_by (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sorted_by . clone () . into ()) } # [getter] fn sorting (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sorting . clone () . into ()) } # [getter] fn start_date (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_date . clone () . into ()) } # [getter] fn end_date (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_date . clone () . into ()) } # [getter] fn before (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . before . clone () . into ()) } # [getter] fn after (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . after . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn market_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . market_type . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderRequest { inner : venues :: GetOrderRequest , } # [pymethods] impl GetOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn market_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . market_type . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct Order { inner : venues :: Order , } # [pymethods] impl Order { # [staticmethod] fn from_inner (inner : Order) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn size (& self) -> PyResult < String > { Ok (self . inner . size . clone () . into ()) } # [getter] fn product_id (& self) -> PyResult < String > { Ok (self . inner . product_id . clone () . into ()) } # [getter] fn profile_id (& self) -> PyResult < String > { Ok (self . inner . profile_id . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn funds (& self) -> PyResult < String > { Ok (self . inner . funds . clone () . into ()) } # [getter] fn specified_funds (& self) -> PyResult < String > { Ok (self . inner . specified_funds . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < PyObject > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn expire_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . expire_time . clone () . into ()) } # [getter] fn post_only (& self) -> PyResult < bool > { Ok (self . inner . post_only . clone () . into ()) } # [getter] fn created_at (& self) -> PyResult < PyObject > { Ok (self . inner . created_at . clone () . into ()) } # [getter] fn done_at (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . done_at . clone () . into ()) } # [getter] fn done_reason (& self) -> PyResult < String > { Ok (self . inner . done_reason . clone () . into ()) } # [getter] fn reject_reason (& self) -> PyResult < String > { Ok (self . inner . reject_reason . clone () . into ()) } # [getter] fn fill_fees (& self) -> PyResult < String > { Ok (self . inner . fill_fees . clone () . into ()) } # [getter] fn filled_size (& self) -> PyResult < String > { Ok (self . inner . filled_size . clone () . into ()) } # [getter] fn executed_value (& self) -> PyResult < String > { Ok (self . inner . executed_value . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn settled (& self) -> PyResult < bool > { Ok (self . inner . settled . clone () . into ()) } # [getter] fn stop (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < String > { Ok (self . inner . stop_price . clone () . into ()) } # [getter] fn funding_amount (& self) -> PyResult < String > { Ok (self . inner . funding_amount . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < String > { Ok (self . inner . client_oid . clone () . into ()) } # [getter] fn market_type (& self) -> PyResult < String > { Ok (self . inner . market_type . clone () . into ()) } # [getter] fn stop_limit_price (& self) -> PyResult < String > { Ok (self . inner . stop_limit_price . clone () . into ()) } } # [pymethods] impl RestClient { fn get_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_orders () . await }) } fn get_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct ErrorResponse { inner : venues :: ErrorResponse , } # [pymethods] impl ErrorResponse { # [staticmethod] fn from_inner (inner : ErrorResponse) -> Self { Self { inner } } # [getter] fn message (& self) -> PyResult < String > { Ok (self . inner . message . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub enum EndpointType { Public , Private , PrivateFills , PrivateLoans , } # [pyclass] # [derive (Clone)] pub struct RateLimit { inner : venues :: RateLimit , } # [pymethods] impl RateLimit { # [staticmethod] fn from_inner (inner : RateLimit) -> Self { Self { inner } } # [getter] fn max_requests_per_second (& self) -> PyResult < u64 > { Ok (self . inner . max_requests_per_second . clone () . into ()) } # [getter] fn max_burst (& self) -> PyResult < u64 > { Ok (self . inner . max_burst . clone () . into ()) } # [getter] fn window (& self) -> PyResult < PyObject > { Ok (self . inner . window . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RateLimiter { inner : venues :: RateLimiter , } # [pymethods] impl RateLimiter { # [staticmethod] fn from_inner (inner : RateLimiter) -> Self { Self { inner } } } # [doc = " Create the Python module for coinbaseexchange"] pub fn create_module (py : Python) -> PyResult <& PyModule > { let m = PyModule :: new (py , "coinbaseexchange") ?; Ok (m) }