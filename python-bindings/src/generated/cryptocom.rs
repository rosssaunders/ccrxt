# ! [doc = " Python bindings for cryptocom venue"] # ! [doc = ""] # ! [doc = " This module is automatically generated from the Rust source code."] # ! [doc = " Do not edit this file directly."] use pyo3 :: prelude ::*; use pyo3_asyncio ; use venues ; # [pyclass] # [derive (Clone)] pub struct ApiResult { inner : venues :: ApiResult , } # [pymethods] impl ApiResult { # [staticmethod] fn from_inner (inner : ApiResult) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < i64 > { Ok (self . inner . code . clone () . into ()) } # [getter] fn result (& self) -> PyResult < PyObject > { Ok (self . inner . result . clone () . into ()) } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn method (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . method . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub enum AnnouncementCategory { System , List , Delist , Event , Product , } # [pyclass] # [derive (Clone)] pub enum ProductType { Spot , Margin , Derivative , TradingArena , VipProgramme , MmProgramme , Supercharger , TradingBot , Documents , DefiStaking , Staking , LiquidStaking , Affiliate , Referral , CroLockup , AccountManagement , OtcConvert , Transfer , ZeroFeeToken , } # [pyclass] # [derive (Clone)] pub enum ImpactedStatus { Yes , Partial , Bau , } # [pyclass] # [derive (Clone)] pub enum InstrumentType { PerpetualSwap , Future , Spot , } # [pyclass] # [derive (Clone)] pub enum Timeframe { M1 , M5 , M15 , M30 , H1 , H2 , H4 , H12 , D1 , D7 , D14 , M1m , } # [pyclass] # [derive (Clone)] pub enum TradeSide { Buy , Sell , } # [pyclass] # [derive (Clone)] pub enum ValuationType { IndexPrice , MarkPrice , FundingHist , FundingRate , EstimatedFundingRate , } # [pyclass] # [derive (Clone)] pub enum OrderSide { Buy , Sell , } # [pyclass] # [derive (Clone)] pub enum OrderType { Limit , Market , StopLoss , StopLimit , TakeProfit , TakeProfitLimit , } # [pyclass] # [derive (Clone)] pub enum TimeInForce { GoodTillCancel , FillOrKill , ImmediateOrCancel , } # [pyclass] # [derive (Clone)] pub enum ExecInst { PostOnly , SmartPostOnly , } # [pyclass] # [derive (Clone)] pub enum ContingencyType { List , Oco , } # [pyclass] # [derive (Clone)] pub enum ResponseCode { NoError , Error , } # [pyclass] # [derive (Clone)] pub enum StpScope { MasterOrSubAccount , SubAccountOnly , } # [pyclass] # [derive (Clone)] pub enum StpInst { CancelMaker , CancelTaker , CancelBoth , } # [pyclass] # [derive (Clone)] pub enum RefPriceType { MarkPrice , IndexPrice , LastPrice , } # [pyclass] # [derive (Clone)] pub enum SpotMarginType { Spot , Margin , } # [pyclass] # [derive (Clone)] pub enum WithdrawalStatus { Pending , Processing , Rejected , PaymentInProgress , PaymentFailed , Completed , Cancelled , } # [pyclass] # [derive (Clone)] pub struct GetExpiredSettlementPriceRequest { inner : venues :: GetExpiredSettlementPriceRequest , } # [pymethods] impl GetExpiredSettlementPriceRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_type . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ExpiredSettlementPriceResult { inner : venues :: ExpiredSettlementPriceResult , } # [pymethods] impl ExpiredSettlementPriceResult { # [staticmethod] fn from_inner (inner : ExpiredSettlementPriceResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_expired_settlement_price <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_expired_settlement_price () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetTradesRequest { inner : venues :: GetTradesRequest , } # [pymethods] impl GetTradesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < PyObject > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TradesResult { inner : venues :: TradesResult , } # [pymethods] impl TradesResult { # [staticmethod] fn from_inner (inner : TradesResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub enum StringOrInt { String , Int , } # [pyclass] # [derive (Clone)] pub struct Trade { inner : venues :: Trade , } # [pymethods] impl Trade { # [staticmethod] fn from_inner (inner : Trade) -> Self { Self { inner } } # [getter] fn trade_id (& self) -> PyResult < PyObject > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn timestamp_ns (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . timestamp_ns . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn match_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . match_id . clone () . into ()) } } # [pymethods] impl RestClient { fn get_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } # [getter] fn base_url (& self) -> PyResult < PyObject > { Ok (self . inner . base_url . clone () . into ()) } # [getter] fn client (& self) -> PyResult < PyObject > { Ok (self . inner . client . clone () . into ()) } # [getter] fn rate_limiter (& self) -> PyResult < PyObject > { Ok (self . inner . rate_limiter . clone () . into ()) } } # [pymethods] impl RestClient { fn send_request <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_request () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetValuationsRequest { inner : venues :: GetValuationsRequest , } # [pymethods] impl GetValuationsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < PyObject > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn valuation_type (& self) -> PyResult < PyObject > { Ok (self . inner . valuation_type . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn start_ts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_ts . clone () . into ()) } # [getter] fn end_ts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_ts . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ValuationsResult { inner : venues :: ValuationsResult , } # [pymethods] impl ValuationsResult { # [staticmethod] fn from_inner (inner : ValuationsResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_valuations <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_valuations () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetBookRequest { inner : venues :: GetBookRequest , } # [pymethods] impl GetBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < PyObject > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn depth (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . depth . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BookResult { inner : venues :: BookResult , } # [pymethods] impl BookResult { # [staticmethod] fn from_inner (inner : BookResult) -> Self { Self { inner } } # [getter] fn depth (& self) -> PyResult < u64 > { Ok (self . inner . depth . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < PyObject > { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BookData { inner : venues :: BookData , } # [pymethods] impl BookData { # [staticmethod] fn from_inner (inner : BookData) -> Self { Self { inner } } # [getter] fn asks (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . asks . clone () . into ()) } # [getter] fn bids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . bids . clone () . into ()) } # [getter] fn t (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . t . clone () . into ()) } # [getter] fn tt (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . tt . clone () . into ()) } # [getter] fn u (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . u . clone () . into ()) } } # [pymethods] impl RestClient { fn get_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetAnnouncementsRequest { inner : venues :: GetAnnouncementsRequest , } # [pymethods] impl GetAnnouncementsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn category (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . category . clone () . into ()) } # [getter] fn product_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . product_type . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AnnouncementsResult { inner : venues :: AnnouncementsResult , } # [pymethods] impl AnnouncementsResult { # [staticmethod] fn from_inner (inner : AnnouncementsResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ImpactedParams { inner : venues :: ImpactedParams , } # [pymethods] impl ImpactedParams { # [staticmethod] fn from_inner (inner : ImpactedParams) -> Self { Self { inner } } # [getter] fn spot_trading_impacted (& self) -> PyResult < PyObject > { Ok (self . inner . spot_trading_impacted . clone () . into ()) } # [getter] fn derivative_trading_impacted (& self) -> PyResult < PyObject > { Ok (self . inner . derivative_trading_impacted . clone () . into ()) } # [getter] fn margin_trading_impacted (& self) -> PyResult < PyObject > { Ok (self . inner . margin_trading_impacted . clone () . into ()) } # [getter] fn otc_trading_impacted (& self) -> PyResult < PyObject > { Ok (self . inner . otc_trading_impacted . clone () . into ()) } # [getter] fn convert_impacted (& self) -> PyResult < PyObject > { Ok (self . inner . convert_impacted . clone () . into ()) } # [getter] fn staking_impacted (& self) -> PyResult < PyObject > { Ok (self . inner . staking_impacted . clone () . into ()) } # [getter] fn trading_bot_impacted (& self) -> PyResult < PyObject > { Ok (self . inner . trading_bot_impacted . clone () . into ()) } # [getter] fn crypto_wallet_impacted (& self) -> PyResult < PyObject > { Ok (self . inner . crypto_wallet_impacted . clone () . into ()) } # [getter] fn fiat_wallet_impacted (& self) -> PyResult < PyObject > { Ok (self . inner . fiat_wallet_impacted . clone () . into ()) } # [getter] fn login_impacted (& self) -> PyResult < PyObject > { Ok (self . inner . login_impacted . clone () . into ()) } } # [pymethods] impl RestClient { fn get_announcements <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_announcements () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetConversionRateRequest { inner : venues :: GetConversionRateRequest , } # [pymethods] impl GetConversionRateRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ConversionRateResult { inner : venues :: ConversionRateResult , } # [pymethods] impl ConversionRateResult { # [staticmethod] fn from_inner (inner : ConversionRateResult) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn conversion_rate (& self) -> PyResult < String > { Ok (self . inner . conversion_rate . clone () . into ()) } } # [pymethods] impl RestClient { fn get_conversion_rate <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_conversion_rate () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetCandlestickRequest { inner : venues :: GetCandlestickRequest , } # [pymethods] impl GetCandlestickRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < PyObject > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn timeframe (& self) -> PyResult < PyObject > { Ok (self . inner . timeframe . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn start_ts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_ts . clone () . into ()) } # [getter] fn end_ts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_ts . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CandlestickResult { inner : venues :: CandlestickResult , } # [pymethods] impl CandlestickResult { # [staticmethod] fn from_inner (inner : CandlestickResult) -> Self { Self { inner } } # [getter] fn interval (& self) -> PyResult < PyObject > { Ok (self . inner . interval . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < PyObject > { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CandlestickData { inner : venues :: CandlestickData , } # [pymethods] impl CandlestickData { # [staticmethod] fn from_inner (inner : CandlestickData) -> Self { Self { inner } } # [getter] fn o (& self) -> PyResult < String > { Ok (self . inner . o . clone () . into ()) } # [getter] fn h (& self) -> PyResult < String > { Ok (self . inner . h . clone () . into ()) } # [getter] fn l (& self) -> PyResult < String > { Ok (self . inner . l . clone () . into ()) } # [getter] fn c (& self) -> PyResult < String > { Ok (self . inner . c . clone () . into ()) } # [getter] fn v (& self) -> PyResult < String > { Ok (self . inner . v . clone () . into ()) } # [getter] fn t (& self) -> PyResult < u64 > { Ok (self . inner . t . clone () . into ()) } } # [pymethods] impl RestClient { fn get_candlestick <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_candlestick () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetInstrumentsRequest { inner : venues :: GetInstrumentsRequest , } # [pymethods] impl GetInstrumentsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_type . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct InstrumentsResult { inner : venues :: InstrumentsResult , } # [pymethods] impl InstrumentsResult { # [staticmethod] fn from_inner (inner : InstrumentsResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_instruments <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_instruments () . await }) } } # [pyclass] # [derive (Clone)] pub struct RiskParametersResult { inner : venues :: RiskParametersResult , } # [pymethods] impl RiskParametersResult { # [staticmethod] fn from_inner (inner : RiskParametersResult) -> Self { Self { inner } } # [getter] fn default_max_product_leverage_for_spot (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . default_max_product_leverage_for_spot . clone () . into ()) } # [getter] fn default_max_product_leverage_for_perps (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . default_max_product_leverage_for_perps . clone () . into ()) } # [getter] fn default_max_product_leverage_for_futures (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . default_max_product_leverage_for_futures . clone () . into ()) } # [getter] fn default_unit_margin_rate (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . default_unit_margin_rate . clone () . into ()) } # [getter] fn default_collateral_cap (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . default_collateral_cap . clone () . into ()) } # [getter] fn update_timestamp_ms (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . update_timestamp_ms . clone () . into ()) } # [getter] fn base_currency_config (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . base_currency_config . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BaseCurrencyConfig { inner : venues :: BaseCurrencyConfig , } # [pymethods] impl BaseCurrencyConfig { # [staticmethod] fn from_inner (inner : BaseCurrencyConfig) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn collateral_cap_notional (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . collateral_cap_notional . clone () . into ()) } # [getter] fn minimum_haircut (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . minimum_haircut . clone () . into ()) } # [getter] fn max_product_leverage_for_spot (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . max_product_leverage_for_spot . clone () . into ()) } # [getter] fn max_product_leverage_for_perps (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . max_product_leverage_for_perps . clone () . into ()) } # [getter] fn max_product_leverage_for_futures (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . max_product_leverage_for_futures . clone () . into ()) } # [getter] fn unit_margin_rate (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . unit_margin_rate . clone () . into ()) } # [getter] fn max_short_sell_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . max_short_sell_limit . clone () . into ()) } # [getter] fn order_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_limit . clone () . into ()) } # [getter] fn max_order_notional_usd (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . max_order_notional_usd . clone () . into ()) } # [getter] fn min_order_notional_usd (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . min_order_notional_usd . clone () . into ()) } # [getter] fn extra (& self) -> PyResult < PyObject > { Ok (self . inner . extra . clone () . into ()) } } # [pymethods] impl RestClient { fn get_risk_parameters <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_risk_parameters () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetInsuranceRequest { inner : venues :: GetInsuranceRequest , } # [pymethods] impl GetInsuranceRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < PyObject > { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct InsuranceResult { inner : venues :: InsuranceResult , } # [pymethods] impl InsuranceResult { # [staticmethod] fn from_inner (inner : InsuranceResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_insurance <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_insurance () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetTickersRequest { inner : venues :: GetTickersRequest , } # [pymethods] impl GetTickersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TickersResult { inner : venues :: TickersResult , } # [pymethods] impl TickersResult { # [staticmethod] fn from_inner (inner : TickersResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct Ticker { inner : venues :: Ticker , } # [pymethods] impl Ticker { # [staticmethod] fn from_inner (inner : Ticker) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn high_price_24h (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . high_price_24h . clone () . into ()) } # [getter] fn low_price_24h (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . low_price_24h . clone () . into ()) } # [getter] fn last_trade_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . last_trade_price . clone () . into ()) } # [getter] fn volume_24h (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . volume_24h . clone () . into ()) } # [getter] fn volume_24h_value (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . volume_24h_value . clone () . into ()) } # [getter] fn open_interest (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . open_interest . clone () . into ()) } # [getter] fn price_change_24h (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price_change_24h . clone () . into ()) } # [getter] fn best_bid_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . best_bid_price . clone () . into ()) } # [getter] fn best_ask_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . best_ask_price . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn get_tickers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_tickers () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOrderListRequest { inner : venues :: GetOrderListRequest , } # [pymethods] impl GetOrderListRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn contingency_type (& self) -> PyResult < PyObject > { Ok (self . inner . contingency_type . clone () . into ()) } # [getter] fn list_id (& self) -> PyResult < String > { Ok (self . inner . list_id . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderDetails { inner : venues :: OrderDetails , } # [pymethods] impl OrderDetails { # [staticmethod] fn from_inner (inner : OrderDetails) -> Self { Self { inner } } # [getter] fn account_id (& self) -> PyResult < String > { Ok (self . inner . account_id . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_oid . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < PyObject > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn exec_inst (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . exec_inst . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn order_value (& self) -> PyResult < String > { Ok (self . inner . order_value . clone () . into ()) } # [getter] fn avg_price (& self) -> PyResult < String > { Ok (self . inner . avg_price . clone () . into ()) } # [getter] fn trigger_price (& self) -> PyResult < String > { Ok (self . inner . trigger_price . clone () . into ()) } # [getter] fn cumulative_quantity (& self) -> PyResult < String > { Ok (self . inner . cumulative_quantity . clone () . into ()) } # [getter] fn cumulative_value (& self) -> PyResult < String > { Ok (self . inner . cumulative_value . clone () . into ()) } # [getter] fn cumulative_fee (& self) -> PyResult < String > { Ok (self . inner . cumulative_fee . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn update_user_id (& self) -> PyResult < String > { Ok (self . inner . update_user_id . clone () . into ()) } # [getter] fn order_date (& self) -> PyResult < String > { Ok (self . inner . order_date . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn fee_instrument_name (& self) -> PyResult < String > { Ok (self . inner . fee_instrument_name . clone () . into ()) } # [getter] fn list_id (& self) -> PyResult < String > { Ok (self . inner . list_id . clone () . into ()) } # [getter] fn contingency_type (& self) -> PyResult < PyObject > { Ok (self . inner . contingency_type . clone () . into ()) } # [getter] fn trigger_price_type (& self) -> PyResult < String > { Ok (self . inner . trigger_price_type . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < u64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn create_time_ns (& self) -> PyResult < String > { Ok (self . inner . create_time_ns . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < u64 > { Ok (self . inner . update_time . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderListResult { inner : venues :: GetOrderListResult , } # [pymethods] impl GetOrderListResult { # [staticmethod] fn from_inner (inner : GetOrderListResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_list <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_list () . await }) } } # [pyclass] # [derive (Clone)] pub struct AmendOrderRequest { inner : venues :: AmendOrderRequest , } # [pymethods] impl AmendOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn orig_client_oid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . orig_client_oid . clone () . into ()) } # [getter] fn new_price (& self) -> PyResult < String > { Ok (self . inner . new_price . clone () . into ()) } # [getter] fn new_quantity (& self) -> PyResult < String > { Ok (self . inner . new_quantity . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AmendOrderResponse { inner : venues :: AmendOrderResponse , } # [pymethods] impl AmendOrderResponse { # [staticmethod] fn from_inner (inner : AmendOrderResponse) -> Self { Self { inner } } # [getter] fn client_oid (& self) -> PyResult < String > { Ok (self . inner . client_oid . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } } # [pymethods] impl RestClient { fn amend_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . amend_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetRewardHistoryRequest { inner : venues :: GetRewardHistoryRequest , } # [pymethods] impl GetRewardHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RewardHistoryEntry { inner : venues :: RewardHistoryEntry , } # [pymethods] impl RewardHistoryEntry { # [staticmethod] fn from_inner (inner : RewardHistoryEntry) -> Self { Self { inner } } # [getter] fn staking_inst_name (& self) -> PyResult < String > { Ok (self . inner . staking_inst_name . clone () . into ()) } # [getter] fn underlying_inst_name (& self) -> PyResult < String > { Ok (self . inner . underlying_inst_name . clone () . into ()) } # [getter] fn reward_inst_name (& self) -> PyResult < String > { Ok (self . inner . reward_inst_name . clone () . into ()) } # [getter] fn reward_quantity (& self) -> PyResult < String > { Ok (self . inner . reward_quantity . clone () . into ()) } # [getter] fn staked_balance (& self) -> PyResult < String > { Ok (self . inner . staked_balance . clone () . into ()) } # [getter] fn event_timestamp_ms (& self) -> PyResult < String > { Ok (self . inner . event_timestamp_ms . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetRewardHistoryResult { inner : venues :: GetRewardHistoryResult , } # [pymethods] impl GetRewardHistoryResult { # [staticmethod] fn from_inner (inner : GetRewardHistoryResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_reward_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_reward_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelOrderListItem { inner : venues :: CancelOrderListItem , } # [pymethods] impl CancelOrderListItem { # [staticmethod] fn from_inner (inner : CancelOrderListItem) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelOrderListRequest { inner : venues :: CancelOrderListRequest , } # [pymethods] impl CancelOrderListRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn contingency_type (& self) -> PyResult < PyObject > { Ok (self . inner . contingency_type . clone () . into ()) } # [getter] fn order_list (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . order_list . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderCancellationResult { inner : venues :: OrderCancellationResult , } # [pymethods] impl OrderCancellationResult { # [staticmethod] fn from_inner (inner : OrderCancellationResult) -> Self { Self { inner } } # [getter] fn index (& self) -> PyResult < u64 > { Ok (self . inner . index . clone () . into ()) } # [getter] fn code (& self) -> PyResult < i64 > { Ok (self . inner . code . clone () . into ()) } # [getter] fn message (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . message . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelOrderListResponse { inner : venues :: CancelOrderListResponse , } # [pymethods] impl CancelOrderListResponse { # [staticmethod] fn from_inner (inner : CancelOrderListResponse) -> Self { Self { inner } } # [getter] fn result_list (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . result_list . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_order_list <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_order_list () . await }) } } # [pyclass] # [derive (Clone)] pub struct NetworkInfo { inner : venues :: NetworkInfo , } # [pymethods] impl NetworkInfo { # [staticmethod] fn from_inner (inner : NetworkInfo) -> Self { Self { inner } } # [getter] fn network_id (& self) -> PyResult < String > { Ok (self . inner . network_id . clone () . into ()) } # [getter] fn withdraw_enabled (& self) -> PyResult < bool > { Ok (self . inner . withdraw_enabled . clone () . into ()) } # [getter] fn deposit_enabled (& self) -> PyResult < bool > { Ok (self . inner . deposit_enabled . clone () . into ()) } # [getter] fn withdrawal_fee (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . withdrawal_fee . clone () . into ()) } # [getter] fn min_withdrawal_amount (& self) -> PyResult < f64 > { Ok (self . inner . min_withdrawal_amount . clone () . into ()) } # [getter] fn confirmation_required (& self) -> PyResult < u64 > { Ok (self . inner . confirmation_required . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CurrencyInfo { inner : venues :: CurrencyInfo , } # [pymethods] impl CurrencyInfo { # [staticmethod] fn from_inner (inner : CurrencyInfo) -> Self { Self { inner } } # [getter] fn full_name (& self) -> PyResult < String > { Ok (self . inner . full_name . clone () . into ()) } # [getter] fn default_network (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . default_network . clone () . into ()) } # [getter] fn network_list (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . network_list . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetCurrencyNetworksResponse { inner : venues :: GetCurrencyNetworksResponse , } # [pymethods] impl GetCurrencyNetworksResponse { # [staticmethod] fn from_inner (inner : GetCurrencyNetworksResponse) -> Self { Self { inner } } # [getter] fn update_time (& self) -> PyResult < u64 > { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn currency_map (& self) -> PyResult < PyObject > { Ok (self . inner . currency_map . clone () . into ()) } } # [pymethods] impl RestClient { fn get_currency_networks <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_currency_networks () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOpenConvertRequest { inner : venues :: GetOpenConvertRequest , } # [pymethods] impl GetOpenConvertRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OpenConvertEntry { inner : venues :: OpenConvertEntry , } # [pymethods] impl OpenConvertEntry { # [staticmethod] fn from_inner (inner : OpenConvertEntry) -> Self { Self { inner } } # [getter] fn from_instrument_name (& self) -> PyResult < String > { Ok (self . inner . from_instrument_name . clone () . into ()) } # [getter] fn to_instrument_name (& self) -> PyResult < String > { Ok (self . inner . to_instrument_name . clone () . into ()) } # [getter] fn expected_rate (& self) -> PyResult < String > { Ok (self . inner . expected_rate . clone () . into ()) } # [getter] fn from_quantity (& self) -> PyResult < String > { Ok (self . inner . from_quantity . clone () . into ()) } # [getter] fn slippage_tolerance_bps (& self) -> PyResult < String > { Ok (self . inner . slippage_tolerance_bps . clone () . into ()) } # [getter] fn actual_rate (& self) -> PyResult < String > { Ok (self . inner . actual_rate . clone () . into ()) } # [getter] fn to_quantity (& self) -> PyResult < String > { Ok (self . inner . to_quantity . clone () . into ()) } # [getter] fn convert_id (& self) -> PyResult < u64 > { Ok (self . inner . convert_id . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn create_timestamp_ms (& self) -> PyResult < String > { Ok (self . inner . create_timestamp_ms . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOpenConvertResult { inner : venues :: GetOpenConvertResult , } # [pymethods] impl GetOpenConvertResult { # [staticmethod] fn from_inner (inner : GetOpenConvertResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_open_convert <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_open_convert () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetTradesRequest { inner : venues :: GetTradesRequest , } # [pymethods] impl GetTradesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TradeEntry { inner : venues :: TradeEntry , } # [pymethods] impl TradeEntry { # [staticmethod] fn from_inner (inner : TradeEntry) -> Self { Self { inner } } # [getter] fn account_id (& self) -> PyResult < String > { Ok (self . inner . account_id . clone () . into ()) } # [getter] fn event_date (& self) -> PyResult < String > { Ok (self . inner . event_date . clone () . into ()) } # [getter] fn journal_type (& self) -> PyResult < String > { Ok (self . inner . journal_type . clone () . into ()) } # [getter] fn traded_quantity (& self) -> PyResult < String > { Ok (self . inner . traded_quantity . clone () . into ()) } # [getter] fn traded_price (& self) -> PyResult < String > { Ok (self . inner . traded_price . clone () . into ()) } # [getter] fn fees (& self) -> PyResult < String > { Ok (self . inner . fees . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn trade_id (& self) -> PyResult < String > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn trade_match_id (& self) -> PyResult < String > { Ok (self . inner . trade_match_id . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < String > { Ok (self . inner . client_oid . clone () . into ()) } # [getter] fn taker_side (& self) -> PyResult < String > { Ok (self . inner . taker_side . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn fee_instrument_name (& self) -> PyResult < String > { Ok (self . inner . fee_instrument_name . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < u64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn create_time_ns (& self) -> PyResult < String > { Ok (self . inner . create_time_ns . clone () . into ()) } # [getter] fn transact_time_ns (& self) -> PyResult < String > { Ok (self . inner . transact_time_ns . clone () . into ()) } # [getter] fn match_count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . match_count . clone () . into ()) } # [getter] fn match_index (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . match_index . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetTradesResponse { inner : venues :: GetTradesResponse , } # [pymethods] impl GetTradesResponse { # [staticmethod] fn from_inner (inner : GetTradesResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct ChangeAccountSettingsRequest { inner : venues :: ChangeAccountSettingsRequest , } # [pymethods] impl ChangeAccountSettingsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn stp_scope (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_scope . clone () . into ()) } # [getter] fn stp_inst (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_inst . clone () . into ()) } # [getter] fn stp_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_id . clone () . into ()) } # [getter] fn leverage (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . leverage . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ChangeAccountSettingsResult { inner : venues :: ChangeAccountSettingsResult , } # [pymethods] impl ChangeAccountSettingsResult { # [staticmethod] fn from_inner (inner : ChangeAccountSettingsResult) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < i64 > { Ok (self . inner . code . clone () . into ()) } } # [pymethods] impl RestClient { fn change_account_settings <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . change_account_settings () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOrderHistoryRequest { inner : venues :: GetOrderHistoryRequest , } # [pymethods] impl GetOrderHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderHistoryEntry { inner : venues :: OrderHistoryEntry , } # [pymethods] impl OrderHistoryEntry { # [staticmethod] fn from_inner (inner : OrderHistoryEntry) -> Self { Self { inner } } # [getter] fn account_id (& self) -> PyResult < String > { Ok (self . inner . account_id . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < String > { Ok (self . inner . client_oid . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < String > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn exec_inst (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . exec_inst . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn limit_price (& self) -> PyResult < String > { Ok (self . inner . limit_price . clone () . into ()) } # [getter] fn order_value (& self) -> PyResult < String > { Ok (self . inner . order_value . clone () . into ()) } # [getter] fn maker_fee_rate (& self) -> PyResult < String > { Ok (self . inner . maker_fee_rate . clone () . into ()) } # [getter] fn taker_fee_rate (& self) -> PyResult < String > { Ok (self . inner . taker_fee_rate . clone () . into ()) } # [getter] fn avg_price (& self) -> PyResult < String > { Ok (self . inner . avg_price . clone () . into ()) } # [getter] fn cumulative_quantity (& self) -> PyResult < String > { Ok (self . inner . cumulative_quantity . clone () . into ()) } # [getter] fn cumulative_value (& self) -> PyResult < String > { Ok (self . inner . cumulative_value . clone () . into ()) } # [getter] fn cumulative_fee (& self) -> PyResult < String > { Ok (self . inner . cumulative_fee . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn update_user_id (& self) -> PyResult < String > { Ok (self . inner . update_user_id . clone () . into ()) } # [getter] fn order_date (& self) -> PyResult < String > { Ok (self . inner . order_date . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < u64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn create_time_ns (& self) -> PyResult < String > { Ok (self . inner . create_time_ns . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < u64 > { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn fee_instrument_name (& self) -> PyResult < String > { Ok (self . inner . fee_instrument_name . clone () . into ()) } # [getter] fn reason (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reason . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderHistoryResponse { inner : venues :: GetOrderHistoryResponse , } # [pymethods] impl GetOrderHistoryResponse { # [staticmethod] fn from_inner (inner : GetOrderHistoryResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct PositionBalance { inner : venues :: PositionBalance , } # [pymethods] impl PositionBalance { # [staticmethod] fn from_inner (inner : PositionBalance) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn market_value (& self) -> PyResult < String > { Ok (self . inner . market_value . clone () . into ()) } # [getter] fn collateral_eligible (& self) -> PyResult < String > { Ok (self . inner . collateral_eligible . clone () . into ()) } # [getter] fn haircut (& self) -> PyResult < String > { Ok (self . inner . haircut . clone () . into ()) } # [getter] fn collateral_amount (& self) -> PyResult < String > { Ok (self . inner . collateral_amount . clone () . into ()) } # [getter] fn max_withdrawal_balance (& self) -> PyResult < String > { Ok (self . inner . max_withdrawal_balance . clone () . into ()) } # [getter] fn reserved_qty (& self) -> PyResult < String > { Ok (self . inner . reserved_qty . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UserBalance { inner : venues :: UserBalance , } # [pymethods] impl UserBalance { # [staticmethod] fn from_inner (inner : UserBalance) -> Self { Self { inner } } # [getter] fn total_available_balance (& self) -> PyResult < String > { Ok (self . inner . total_available_balance . clone () . into ()) } # [getter] fn total_margin_balance (& self) -> PyResult < String > { Ok (self . inner . total_margin_balance . clone () . into ()) } # [getter] fn total_initial_margin (& self) -> PyResult < String > { Ok (self . inner . total_initial_margin . clone () . into ()) } # [getter] fn total_position_im (& self) -> PyResult < String > { Ok (self . inner . total_position_im . clone () . into ()) } # [getter] fn total_haircut (& self) -> PyResult < String > { Ok (self . inner . total_haircut . clone () . into ()) } # [getter] fn total_maintenance_margin (& self) -> PyResult < String > { Ok (self . inner . total_maintenance_margin . clone () . into ()) } # [getter] fn total_position_cost (& self) -> PyResult < String > { Ok (self . inner . total_position_cost . clone () . into ()) } # [getter] fn total_cash_balance (& self) -> PyResult < String > { Ok (self . inner . total_cash_balance . clone () . into ()) } # [getter] fn total_collateral_value (& self) -> PyResult < String > { Ok (self . inner . total_collateral_value . clone () . into ()) } # [getter] fn total_session_unrealized_pnl (& self) -> PyResult < String > { Ok (self . inner . total_session_unrealized_pnl . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn total_session_realized_pnl (& self) -> PyResult < String > { Ok (self . inner . total_session_realized_pnl . clone () . into ()) } # [getter] fn is_liquidating (& self) -> PyResult < bool > { Ok (self . inner . is_liquidating . clone () . into ()) } # [getter] fn total_effective_leverage (& self) -> PyResult < String > { Ok (self . inner . total_effective_leverage . clone () . into ()) } # [getter] fn position_limit (& self) -> PyResult < String > { Ok (self . inner . position_limit . clone () . into ()) } # [getter] fn used_position_limit (& self) -> PyResult < String > { Ok (self . inner . used_position_limit . clone () . into ()) } # [getter] fn position_balances (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . position_balances . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UserBalanceResult { inner : venues :: UserBalanceResult , } # [pymethods] impl UserBalanceResult { # [staticmethod] fn from_inner (inner : UserBalanceResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_user_balance <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_user_balance () . await }) } } # [pyclass] # [derive (Clone)] pub struct AccountSettings { inner : venues :: AccountSettings , } # [pymethods] impl AccountSettings { # [staticmethod] fn from_inner (inner : AccountSettings) -> Self { Self { inner } } # [getter] fn leverage (& self) -> PyResult < u64 > { Ok (self . inner . leverage . clone () . into ()) } # [getter] fn stp_id (& self) -> PyResult < u64 > { Ok (self . inner . stp_id . clone () . into ()) } # [getter] fn stp_scope (& self) -> PyResult < String > { Ok (self . inner . stp_scope . clone () . into ()) } # [getter] fn stp_inst (& self) -> PyResult < String > { Ok (self . inner . stp_inst . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetAccountSettingsResult { inner : venues :: GetAccountSettingsResult , } # [pymethods] impl GetAccountSettingsResult { # [staticmethod] fn from_inner (inner : GetAccountSettingsResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetAccountSettingsRequest { inner : venues :: GetAccountSettingsRequest , } # [pymethods] impl GetAccountSettingsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } } # [pymethods] impl RestClient { fn get_account_settings <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_account_settings () . await }) } } # [pyclass] # [derive (Clone)] pub struct ConvertRequest { inner : venues :: ConvertRequest , } # [pymethods] impl ConvertRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn from_instrument_name (& self) -> PyResult < String > { Ok (self . inner . from_instrument_name . clone () . into ()) } # [getter] fn to_instrument_name (& self) -> PyResult < String > { Ok (self . inner . to_instrument_name . clone () . into ()) } # [getter] fn expected_rate (& self) -> PyResult < String > { Ok (self . inner . expected_rate . clone () . into ()) } # [getter] fn from_quantity (& self) -> PyResult < String > { Ok (self . inner . from_quantity . clone () . into ()) } # [getter] fn slippage_tolerance_bps (& self) -> PyResult < String > { Ok (self . inner . slippage_tolerance_bps . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ConvertResult { inner : venues :: ConvertResult , } # [pymethods] impl ConvertResult { # [staticmethod] fn from_inner (inner : ConvertResult) -> Self { Self { inner } } # [getter] fn from_instrument_name (& self) -> PyResult < String > { Ok (self . inner . from_instrument_name . clone () . into ()) } # [getter] fn to_instrument_name (& self) -> PyResult < String > { Ok (self . inner . to_instrument_name . clone () . into ()) } # [getter] fn expected_rate (& self) -> PyResult < String > { Ok (self . inner . expected_rate . clone () . into ()) } # [getter] fn from_quantity (& self) -> PyResult < String > { Ok (self . inner . from_quantity . clone () . into ()) } # [getter] fn slippage_tolerance_bps (& self) -> PyResult < String > { Ok (self . inner . slippage_tolerance_bps . clone () . into ()) } # [getter] fn convert_id (& self) -> PyResult < String > { Ok (self . inner . convert_id . clone () . into ()) } # [getter] fn reason (& self) -> PyResult < String > { Ok (self . inner . reason . clone () . into ()) } } # [pymethods] impl RestClient { fn convert <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . convert () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn sign_request (& self) -> PyResult < () > { self . inner . sign_request () ; Ok (()) } fn send_signed_request <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_signed_request () . await }) } fn send_signed_request_int <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_signed_request_int () . await }) } } # [pyclass] # [derive (Clone)] pub enum CancelOrderType { Limit , Trigger , All , } # [pyclass] # [derive (Clone)] pub struct CancelAllOrdersRequest { inner : venues :: CancelAllOrdersRequest , } # [pymethods] impl CancelAllOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_type . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelAllOrdersResult { inner : venues :: CancelAllOrdersResult , } # [pymethods] impl CancelAllOrdersResult { # [staticmethod] fn from_inner (inner : CancelAllOrdersResult) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < i64 > { Ok (self . inner . code . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_all_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetConvertHistoryRequest { inner : venues :: GetConvertHistoryRequest , } # [pymethods] impl GetConvertHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ConvertHistoryEntry { inner : venues :: ConvertHistoryEntry , } # [pymethods] impl ConvertHistoryEntry { # [staticmethod] fn from_inner (inner : ConvertHistoryEntry) -> Self { Self { inner } } # [getter] fn from_instrument_name (& self) -> PyResult < String > { Ok (self . inner . from_instrument_name . clone () . into ()) } # [getter] fn to_instrument_name (& self) -> PyResult < String > { Ok (self . inner . to_instrument_name . clone () . into ()) } # [getter] fn expected_rate (& self) -> PyResult < String > { Ok (self . inner . expected_rate . clone () . into ()) } # [getter] fn from_quantity (& self) -> PyResult < String > { Ok (self . inner . from_quantity . clone () . into ()) } # [getter] fn slippage_tolerance_bps (& self) -> PyResult < String > { Ok (self . inner . slippage_tolerance_bps . clone () . into ()) } # [getter] fn actual_rate (& self) -> PyResult < String > { Ok (self . inner . actual_rate . clone () . into ()) } # [getter] fn to_quantity (& self) -> PyResult < String > { Ok (self . inner . to_quantity . clone () . into ()) } # [getter] fn convert_id (& self) -> PyResult < u64 > { Ok (self . inner . convert_id . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn create_timestamp_ms (& self) -> PyResult < String > { Ok (self . inner . create_timestamp_ms . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetConvertHistoryResult { inner : venues :: GetConvertHistoryResult , } # [pymethods] impl GetConvertHistoryResult { # [staticmethod] fn from_inner (inner : GetConvertHistoryResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_convert_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_convert_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelOcoOrderRequest { inner : venues :: CancelOcoOrderRequest , } # [pymethods] impl CancelOcoOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn contingency_type (& self) -> PyResult < PyObject > { Ok (self . inner . contingency_type . clone () . into ()) } # [getter] fn list_id (& self) -> PyResult < String > { Ok (self . inner . list_id . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelOcoOrderResult { inner : venues :: CancelOcoOrderResult , } # [pymethods] impl CancelOcoOrderResult { # [staticmethod] fn from_inner (inner : CancelOcoOrderResult) -> Self { Self { inner } } # [getter] fn list_id (& self) -> PyResult < String > { Ok (self . inner . list_id . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_oco_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_oco_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateOrderRequest { inner : venues :: CreateOrderRequest , } # [pymethods] impl CreateOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn notional (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . notional . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_oid . clone () . into ()) } # [getter] fn exec_inst (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . exec_inst . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn ref_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . ref_price . clone () . into ()) } # [getter] fn ref_price_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . ref_price_type . clone () . into ()) } # [getter] fn spot_margin (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . spot_margin . clone () . into ()) } # [getter] fn stp_scope (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_scope . clone () . into ()) } # [getter] fn stp_inst (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_inst . clone () . into ()) } # [getter] fn stp_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_id . clone () . into ()) } # [getter] fn fee_instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . fee_instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateOrderResult { inner : venues :: CreateOrderResult , } # [pymethods] impl CreateOrderResult { # [staticmethod] fn from_inner (inner : CreateOrderResult) -> Self { Self { inner } } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < String > { Ok (self . inner . client_oid . clone () . into ()) } } # [pymethods] impl RestClient { fn create_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct StakeRequest { inner : venues :: StakeRequest , } # [pymethods] impl StakeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct StakeResponse { inner : venues :: StakeResponse , } # [pymethods] impl StakeResponse { # [staticmethod] fn from_inner (inner : StakeResponse) -> Self { Self { inner } } # [getter] fn staking_id (& self) -> PyResult < String > { Ok (self . inner . staking_id . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn underlying_inst_name (& self) -> PyResult < String > { Ok (self . inner . underlying_inst_name . clone () . into ()) } # [getter] fn pre_stake_charge_rate_in_bps (& self) -> PyResult < String > { Ok (self . inner . pre_stake_charge_rate_in_bps . clone () . into ()) } # [getter] fn pre_stake_charge (& self) -> PyResult < String > { Ok (self . inner . pre_stake_charge . clone () . into ()) } # [getter] fn reason (& self) -> PyResult < String > { Ok (self . inner . reason . clone () . into ()) } } # [pymethods] impl RestClient { fn stake <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . stake () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetDepositHistoryRequest { inner : venues :: GetDepositHistoryRequest , } # [pymethods] impl GetDepositHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn start_ts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_ts . clone () . into ()) } # [getter] fn end_ts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_ts . clone () . into ()) } # [getter] fn page_size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page_size . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DepositHistoryEntry { inner : venues :: DepositHistoryEntry , } # [pymethods] impl DepositHistoryEntry { # [staticmethod] fn from_inner (inner : DepositHistoryEntry) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < f64 > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < u64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetDepositHistoryResponse { inner : venues :: GetDepositHistoryResponse , } # [pymethods] impl GetDepositHistoryResponse { # [staticmethod] fn from_inner (inner : GetDepositHistoryResponse) -> Self { Self { inner } } # [getter] fn deposit_list (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . deposit_list . clone () . into ()) } } # [pymethods] impl RestClient { fn get_deposit_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_deposit_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetWithdrawalHistoryRequest { inner : venues :: GetWithdrawalHistoryRequest , } # [pymethods] impl GetWithdrawalHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn start_ts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_ts . clone () . into ()) } # [getter] fn end_ts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_ts . clone () . into ()) } # [getter] fn page_size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page_size . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct WithdrawalHistoryEntry { inner : venues :: WithdrawalHistoryEntry , } # [pymethods] impl WithdrawalHistoryEntry { # [staticmethod] fn from_inner (inner : WithdrawalHistoryEntry) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < f64 > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < u64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn client_wid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_wid . clone () . into ()) } # [getter] fn txid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . txid . clone () . into ()) } # [getter] fn network_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . network_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetWithdrawalHistoryResponse { inner : venues :: GetWithdrawalHistoryResponse , } # [pymethods] impl GetWithdrawalHistoryResponse { # [staticmethod] fn from_inner (inner : GetWithdrawalHistoryResponse) -> Self { Self { inner } } # [getter] fn withdrawal_list (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . withdrawal_list . clone () . into ()) } } # [pymethods] impl RestClient { fn get_withdrawal_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_withdrawal_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct SubaccountBalance { inner : venues :: SubaccountBalance , } # [pymethods] impl SubaccountBalance { # [staticmethod] fn from_inner (inner : SubaccountBalance) -> Self { Self { inner } } # [getter] fn account (& self) -> PyResult < String > { Ok (self . inner . account . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn total_available_balance (& self) -> PyResult < String > { Ok (self . inner . total_available_balance . clone () . into ()) } # [getter] fn total_margin_balance (& self) -> PyResult < String > { Ok (self . inner . total_margin_balance . clone () . into ()) } # [getter] fn total_initial_margin (& self) -> PyResult < String > { Ok (self . inner . total_initial_margin . clone () . into ()) } # [getter] fn total_maintenance_margin (& self) -> PyResult < String > { Ok (self . inner . total_maintenance_margin . clone () . into ()) } # [getter] fn total_position_cost (& self) -> PyResult < String > { Ok (self . inner . total_position_cost . clone () . into ()) } # [getter] fn total_cash_balance (& self) -> PyResult < String > { Ok (self . inner . total_cash_balance . clone () . into ()) } # [getter] fn total_collateral_value (& self) -> PyResult < String > { Ok (self . inner . total_collateral_value . clone () . into ()) } # [getter] fn total_session_unrealized_pnl (& self) -> PyResult < String > { Ok (self . inner . total_session_unrealized_pnl . clone () . into ()) } # [getter] fn total_session_realized_pnl (& self) -> PyResult < String > { Ok (self . inner . total_session_realized_pnl . clone () . into ()) } # [getter] fn total_effective_leverage (& self) -> PyResult < String > { Ok (self . inner . total_effective_leverage . clone () . into ()) } # [getter] fn position_limit (& self) -> PyResult < String > { Ok (self . inner . position_limit . clone () . into ()) } # [getter] fn used_position_limit (& self) -> PyResult < String > { Ok (self . inner . used_position_limit . clone () . into ()) } # [getter] fn is_liquidating (& self) -> PyResult < bool > { Ok (self . inner . is_liquidating . clone () . into ()) } # [getter] fn position_balances (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . position_balances . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetSubaccountBalancesResult { inner : venues :: GetSubaccountBalancesResult , } # [pymethods] impl GetSubaccountBalancesResult { # [staticmethod] fn from_inner (inner : GetSubaccountBalancesResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_subaccount_balances <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_subaccount_balances () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetInstrumentFeeRateRequest { inner : venues :: GetInstrumentFeeRateRequest , } # [pymethods] impl GetInstrumentFeeRateRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } } # [pymethods] impl RestClient { fn get_instrument_fee_rate <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_instrument_fee_rate () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOrderDetailRequest { inner : venues :: GetOrderDetailRequest , } # [pymethods] impl GetOrderDetailRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_oid . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderDetail { inner : venues :: OrderDetail , } # [pymethods] impl OrderDetail { # [staticmethod] fn from_inner (inner : OrderDetail) -> Self { Self { inner } } # [getter] fn account_id (& self) -> PyResult < String > { Ok (self . inner . account_id . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < String > { Ok (self . inner . client_oid . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < String > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn exec_inst (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . exec_inst . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn limit_price (& self) -> PyResult < String > { Ok (self . inner . limit_price . clone () . into ()) } # [getter] fn order_value (& self) -> PyResult < String > { Ok (self . inner . order_value . clone () . into ()) } # [getter] fn maker_fee_rate (& self) -> PyResult < String > { Ok (self . inner . maker_fee_rate . clone () . into ()) } # [getter] fn taker_fee_rate (& self) -> PyResult < String > { Ok (self . inner . taker_fee_rate . clone () . into ()) } # [getter] fn avg_price (& self) -> PyResult < String > { Ok (self . inner . avg_price . clone () . into ()) } # [getter] fn cumulative_quantity (& self) -> PyResult < String > { Ok (self . inner . cumulative_quantity . clone () . into ()) } # [getter] fn cumulative_value (& self) -> PyResult < String > { Ok (self . inner . cumulative_value . clone () . into ()) } # [getter] fn cumulative_fee (& self) -> PyResult < String > { Ok (self . inner . cumulative_fee . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn update_user_id (& self) -> PyResult < String > { Ok (self . inner . update_user_id . clone () . into ()) } # [getter] fn order_date (& self) -> PyResult < String > { Ok (self . inner . order_date . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn fee_instrument_name (& self) -> PyResult < String > { Ok (self . inner . fee_instrument_name . clone () . into ()) } # [getter] fn reason (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reason . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < u64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn create_time_ns (& self) -> PyResult < String > { Ok (self . inner . create_time_ns . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < u64 > { Ok (self . inner . update_time . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_detail <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_detail () . await }) } } # [pyclass] # [derive (Clone)] pub struct ChangeAccountLeverageRequest { inner : venues :: ChangeAccountLeverageRequest , } # [pymethods] impl ChangeAccountLeverageRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn account_id (& self) -> PyResult < String > { Ok (self . inner . account_id . clone () . into ()) } # [getter] fn leverage (& self) -> PyResult < u64 > { Ok (self . inner . leverage . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ChangeAccountLeverageResult { inner : venues :: ChangeAccountLeverageResult , } # [pymethods] impl ChangeAccountLeverageResult { # [staticmethod] fn from_inner (inner : ChangeAccountLeverageResult) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < i64 > { Ok (self . inner . code . clone () . into ()) } } # [pymethods] impl RestClient { fn change_account_leverage <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . change_account_leverage () . await }) } } # [pyclass] # [derive (Clone)] pub struct BalanceHistoryEntry { inner : venues :: BalanceHistoryEntry , } # [pymethods] impl BalanceHistoryEntry { # [staticmethod] fn from_inner (inner : BalanceHistoryEntry) -> Self { Self { inner } } # [getter] fn t (& self) -> PyResult < u64 > { Ok (self . inner . t . clone () . into ()) } # [getter] fn c (& self) -> PyResult < String > { Ok (self . inner . c . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetUserBalanceHistoryRequest { inner : venues :: GetUserBalanceHistoryRequest , } # [pymethods] impl GetUserBalanceHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn timeframe (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . timeframe . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetUserBalanceHistoryResult { inner : venues :: GetUserBalanceHistoryResult , } # [pymethods] impl GetUserBalanceHistoryResult { # [staticmethod] fn from_inner (inner : GetUserBalanceHistoryResult) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_user_balance_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_user_balance_history () . await }) } } # [pyclass] # [derive (Clone)] pub enum ClosePositionType { Limit , Market , } # [pyclass] # [derive (Clone)] pub struct ClosePositionRequest { inner : venues :: ClosePositionRequest , } # [pymethods] impl ClosePositionRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ClosePositionResponse { inner : venues :: ClosePositionResponse , } # [pymethods] impl ClosePositionResponse { # [staticmethod] fn from_inner (inner : ClosePositionResponse) -> Self { Self { inner } } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < String > { Ok (self . inner . client_oid . clone () . into ()) } } # [pymethods] impl RestClient { fn close_position <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . close_position () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetStakeHistoryRequest { inner : venues :: GetStakeHistoryRequest , } # [pymethods] impl GetStakeHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct StakeHistoryEntry { inner : venues :: StakeHistoryEntry , } # [pymethods] impl StakeHistoryEntry { # [staticmethod] fn from_inner (inner : StakeHistoryEntry) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn underlying_inst_name (& self) -> PyResult < String > { Ok (self . inner . underlying_inst_name . clone () . into ()) } # [getter] fn cycle_id (& self) -> PyResult < String > { Ok (self . inner . cycle_id . clone () . into ()) } # [getter] fn staking_id (& self) -> PyResult < String > { Ok (self . inner . staking_id . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn account (& self) -> PyResult < String > { Ok (self . inner . account . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn create_timestamp_ms (& self) -> PyResult < String > { Ok (self . inner . create_timestamp_ms . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetStakeHistoryResult { inner : venues :: GetStakeHistoryResult , } # [pymethods] impl GetStakeHistoryResult { # [staticmethod] fn from_inner (inner : GetStakeHistoryResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_stake_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_stake_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelOrderRequest { inner : venues :: CancelOrderRequest , } # [pymethods] impl CancelOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_oid . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelOrderResponse { inner : venues :: CancelOrderResponse , } # [pymethods] impl CancelOrderResponse { # [staticmethod] fn from_inner (inner : CancelOrderResponse) -> Self { Self { inner } } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < String > { Ok (self . inner . client_oid . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetTransactionsRequest { inner : venues :: GetTransactionsRequest , } # [pymethods] impl GetTransactionsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn journal_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . journal_type . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TransactionEntry { inner : venues :: TransactionEntry , } # [pymethods] impl TransactionEntry { # [staticmethod] fn from_inner (inner : TransactionEntry) -> Self { Self { inner } } # [getter] fn account_id (& self) -> PyResult < String > { Ok (self . inner . account_id . clone () . into ()) } # [getter] fn event_date (& self) -> PyResult < String > { Ok (self . inner . event_date . clone () . into ()) } # [getter] fn journal_type (& self) -> PyResult < String > { Ok (self . inner . journal_type . clone () . into ()) } # [getter] fn journal_id (& self) -> PyResult < String > { Ok (self . inner . journal_id . clone () . into ()) } # [getter] fn transaction_qty (& self) -> PyResult < String > { Ok (self . inner . transaction_qty . clone () . into ()) } # [getter] fn transaction_cost (& self) -> PyResult < String > { Ok (self . inner . transaction_cost . clone () . into ()) } # [getter] fn realized_pnl (& self) -> PyResult < String > { Ok (self . inner . realized_pnl . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn trade_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn trade_match_id (& self) -> PyResult < String > { Ok (self . inner . trade_match_id . clone () . into ()) } # [getter] fn event_timestamp_ms (& self) -> PyResult < u64 > { Ok (self . inner . event_timestamp_ms . clone () . into ()) } # [getter] fn event_timestamp_ns (& self) -> PyResult < String > { Ok (self . inner . event_timestamp_ns . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < String > { Ok (self . inner . client_oid . clone () . into ()) } # [getter] fn taker_side (& self) -> PyResult < String > { Ok (self . inner . taker_side . clone () . into ()) } # [getter] fn side (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . side . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetTransactionsResponse { inner : venues :: GetTransactionsResponse , } # [pymethods] impl GetTransactionsResponse { # [staticmethod] fn from_inner (inner : GetTransactionsResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_transactions <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_transactions () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetDepositAddressRequest { inner : venues :: GetDepositAddressRequest , } # [pymethods] impl GetDepositAddressRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetDepositAddressResponse { inner : venues :: GetDepositAddressResponse , } # [pymethods] impl GetDepositAddressResponse { # [staticmethod] fn from_inner (inner : GetDepositAddressResponse) -> Self { Self { inner } } # [getter] fn deposit_address_list (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . deposit_address_list . clone () . into ()) } } # [pymethods] impl RestClient { fn get_deposit_address <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_deposit_address () . await }) } } # [pyclass] # [derive (Clone)] pub struct UnstakeRequest { inner : venues :: UnstakeRequest , } # [pymethods] impl UnstakeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnstakeResponse { inner : venues :: UnstakeResponse , } # [pymethods] impl UnstakeResponse { # [staticmethod] fn from_inner (inner : UnstakeResponse) -> Self { Self { inner } } # [getter] fn staking_id (& self) -> PyResult < String > { Ok (self . inner . staking_id . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn underlying_inst_name (& self) -> PyResult < String > { Ok (self . inner . underlying_inst_name . clone () . into ()) } # [getter] fn reason (& self) -> PyResult < String > { Ok (self . inner . reason . clone () . into ()) } } # [pymethods] impl RestClient { fn unstake <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . unstake () . await }) } } # [pyclass] # [derive (Clone)] pub enum OrderStatus { New , Pending , Active , } # [pyclass] # [derive (Clone)] pub struct GetOpenOrdersRequest { inner : venues :: GetOpenOrdersRequest , } # [pymethods] impl GetOpenOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OpenOrder { inner : venues :: OpenOrder , } # [pymethods] impl OpenOrder { # [staticmethod] fn from_inner (inner : OpenOrder) -> Self { Self { inner } } # [getter] fn account_id (& self) -> PyResult < String > { Ok (self . inner . account_id . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < String > { Ok (self . inner . client_oid . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < String > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn exec_inst (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . exec_inst . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn limit_price (& self) -> PyResult < String > { Ok (self . inner . limit_price . clone () . into ()) } # [getter] fn order_value (& self) -> PyResult < String > { Ok (self . inner . order_value . clone () . into ()) } # [getter] fn maker_fee_rate (& self) -> PyResult < String > { Ok (self . inner . maker_fee_rate . clone () . into ()) } # [getter] fn taker_fee_rate (& self) -> PyResult < String > { Ok (self . inner . taker_fee_rate . clone () . into ()) } # [getter] fn avg_price (& self) -> PyResult < String > { Ok (self . inner . avg_price . clone () . into ()) } # [getter] fn cumulative_quantity (& self) -> PyResult < String > { Ok (self . inner . cumulative_quantity . clone () . into ()) } # [getter] fn cumulative_value (& self) -> PyResult < String > { Ok (self . inner . cumulative_value . clone () . into ()) } # [getter] fn cumulative_fee (& self) -> PyResult < String > { Ok (self . inner . cumulative_fee . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn update_user_id (& self) -> PyResult < String > { Ok (self . inner . update_user_id . clone () . into ()) } # [getter] fn order_date (& self) -> PyResult < String > { Ok (self . inner . order_date . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < u64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn create_time_ns (& self) -> PyResult < String > { Ok (self . inner . create_time_ns . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < u64 > { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn fee_instrument_name (& self) -> PyResult < String > { Ok (self . inner . fee_instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOpenOrdersResult { inner : venues :: GetOpenOrdersResult , } # [pymethods] impl GetOpenOrdersResult { # [staticmethod] fn from_inner (inner : GetOpenOrdersResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_open_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_open_orders () . await }) } } # [pymethods] impl RestClient { fn get_fee_rate <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_fee_rate () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateSubaccountTransferRequest { inner : venues :: CreateSubaccountTransferRequest , } # [pymethods] impl CreateSubaccountTransferRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn from (& self) -> PyResult < String > { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < String > { Ok (self . inner . to . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateSubaccountTransferResult { inner : venues :: CreateSubaccountTransferResult , } # [pymethods] impl CreateSubaccountTransferResult { # [staticmethod] fn from_inner (inner : CreateSubaccountTransferResult) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < PyObject > { Ok (self . inner . code . clone () . into ()) } } # [pymethods] impl RestClient { fn create_subaccount_transfer <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_subaccount_transfer () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOpenStakeRequest { inner : venues :: GetOpenStakeRequest , } # [pymethods] impl GetOpenStakeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OpenStakeEntry { inner : venues :: OpenStakeEntry , } # [pymethods] impl OpenStakeEntry { # [staticmethod] fn from_inner (inner : OpenStakeEntry) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn underlying_inst_name (& self) -> PyResult < String > { Ok (self . inner . underlying_inst_name . clone () . into ()) } # [getter] fn cycle_id (& self) -> PyResult < String > { Ok (self . inner . cycle_id . clone () . into ()) } # [getter] fn staking_id (& self) -> PyResult < String > { Ok (self . inner . staking_id . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn account (& self) -> PyResult < String > { Ok (self . inner . account . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn create_timestamp_ms (& self) -> PyResult < String > { Ok (self . inner . create_timestamp_ms . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOpenStakeResult { inner : venues :: GetOpenStakeResult , } # [pymethods] impl GetOpenStakeResult { # [staticmethod] fn from_inner (inner : GetOpenStakeResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_open_stake <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_open_stake () . await }) } } # [pyclass] # [derive (Clone)] pub struct Account { inner : venues :: Account , } # [pymethods] impl Account { # [staticmethod] fn from_inner (inner : Account) -> Self { Self { inner } } # [getter] fn uuid (& self) -> PyResult < String > { Ok (self . inner . uuid . clone () . into ()) } # [getter] fn master_account_uuid (& self) -> PyResult < String > { Ok (self . inner . master_account_uuid . clone () . into ()) } # [getter] fn margin_account_uuid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . margin_account_uuid . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn enabled (& self) -> PyResult < bool > { Ok (self . inner . enabled . clone () . into ()) } # [getter] fn tradable (& self) -> PyResult < bool > { Ok (self . inner . tradable . clone () . into ()) } # [getter] fn name (& self) -> PyResult < String > { Ok (self . inner . name . clone () . into ()) } # [getter] fn email (& self) -> PyResult < String > { Ok (self . inner . email . clone () . into ()) } # [getter] fn mobile_number (& self) -> PyResult < String > { Ok (self . inner . mobile_number . clone () . into ()) } # [getter] fn country_code (& self) -> PyResult < String > { Ok (self . inner . country_code . clone () . into ()) } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn margin_access (& self) -> PyResult < String > { Ok (self . inner . margin_access . clone () . into ()) } # [getter] fn derivatives_access (& self) -> PyResult < String > { Ok (self . inner . derivatives_access . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < u64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < u64 > { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn two_fa_enabled (& self) -> PyResult < bool > { Ok (self . inner . two_fa_enabled . clone () . into ()) } # [getter] fn kyc_level (& self) -> PyResult < String > { Ok (self . inner . kyc_level . clone () . into ()) } # [getter] fn suspended (& self) -> PyResult < bool > { Ok (self . inner . suspended . clone () . into ()) } # [getter] fn terminated (& self) -> PyResult < bool > { Ok (self . inner . terminated . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetAccountsResponse { inner : venues :: GetAccountsResponse , } # [pymethods] impl GetAccountsResponse { # [staticmethod] fn from_inner (inner : GetAccountsResponse) -> Self { Self { inner } } # [getter] fn master_account (& self) -> PyResult < PyObject > { Ok (self . inner . master_account . clone () . into ()) } # [getter] fn sub_account_list (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . sub_account_list . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetAccountsRequest { inner : venues :: GetAccountsRequest , } # [pymethods] impl GetAccountsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn page_size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page_size . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } } # [pymethods] impl RestClient { fn get_accounts <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_accounts () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetStakingInstrumentsResult { inner : venues :: GetStakingInstrumentsResult , } # [pymethods] impl GetStakingInstrumentsResult { # [staticmethod] fn from_inner (inner : GetStakingInstrumentsResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_staking_instruments <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_staking_instruments () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateWithdrawalRequest { inner : venues :: CreateWithdrawalRequest , } # [pymethods] impl CreateWithdrawalRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn client_wid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_wid . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn address_tag (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . address_tag . clone () . into ()) } # [getter] fn network_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . network_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateWithdrawalResponse { inner : venues :: CreateWithdrawalResponse , } # [pymethods] impl CreateWithdrawalResponse { # [staticmethod] fn from_inner (inner : CreateWithdrawalResponse) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < u64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < f64 > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn client_wid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_wid . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < u64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn network_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . network_id . clone () . into ()) } } # [pymethods] impl RestClient { fn create_withdrawal <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_withdrawal () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOrderHistoryByCurrencyRequest { inner : venues :: GetOrderHistoryByCurrencyRequest , } # [pymethods] impl GetOrderHistoryByCurrencyRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn kind (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . kind . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn include_old (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . include_old . clone () . into ()) } # [getter] fn include_unfilled (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . include_unfilled . clone () . into ()) } # [getter] fn with_continuation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . with_continuation . clone () . into ()) } # [getter] fn continuation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . continuation . clone () . into ()) } # [getter] fn historical (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . historical . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderHistoryByCurrencyResponse { inner : venues :: GetOrderHistoryByCurrencyResponse , } # [pymethods] impl GetOrderHistoryByCurrencyResponse { # [staticmethod] fn from_inner (inner : GetOrderHistoryByCurrencyResponse) -> Self { Self { inner } } # [getter] fn result (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . result . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderHistoryByCurrencyWithContinuationResponse { inner : venues :: GetOrderHistoryByCurrencyWithContinuationResponse , } # [pymethods] impl GetOrderHistoryByCurrencyWithContinuationResponse { # [staticmethod] fn from_inner (inner : GetOrderHistoryByCurrencyWithContinuationResponse) -> Self { Self { inner } } # [getter] fn result (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . result . clone () . into ()) } # [getter] fn continuation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . continuation . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_history_by_currency <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_history_by_currency () . await }) } } # [pyclass] # [derive (Clone)] pub struct OrderListItem { inner : venues :: OrderListItem , } # [pymethods] impl OrderListItem { # [staticmethod] fn from_inner (inner : OrderListItem) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn notional (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . notional . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_oid . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn exec_inst (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . exec_inst . clone () . into ()) } # [getter] fn trigger_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_price . clone () . into ()) } # [getter] fn stp_scope (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_scope . clone () . into ()) } # [getter] fn stp_inst (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_inst . clone () . into ()) } # [getter] fn stp_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_id . clone () . into ()) } # [getter] fn fee_instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . fee_instrument_name . clone () . into ()) } # [getter] fn ref_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . ref_price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateOrderListRequest { inner : venues :: CreateOrderListRequest , } # [pymethods] impl CreateOrderListRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn contingency_type (& self) -> PyResult < PyObject > { Ok (self . inner . contingency_type . clone () . into ()) } # [getter] fn order_list (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . order_list . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderCreationResult { inner : venues :: OrderCreationResult , } # [pymethods] impl OrderCreationResult { # [staticmethod] fn from_inner (inner : OrderCreationResult) -> Self { Self { inner } } # [getter] fn index (& self) -> PyResult < u64 > { Ok (self . inner . index . clone () . into ()) } # [getter] fn code (& self) -> PyResult < i64 > { Ok (self . inner . code . clone () . into ()) } # [getter] fn message (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . message . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_oid . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateOrderListResponse { inner : venues :: CreateOrderListResponse , } # [pymethods] impl CreateOrderListResponse { # [staticmethod] fn from_inner (inner : CreateOrderListResponse) -> Self { Self { inner } } # [getter] fn result_list (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . result_list . clone () . into ()) } } # [pymethods] impl RestClient { fn create_order_list <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_order_list () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetStakingPositionRequest { inner : venues :: GetStakingPositionRequest , } # [pymethods] impl GetStakingPositionRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct StakingPosition { inner : venues :: StakingPosition , } # [pymethods] impl StakingPosition { # [staticmethod] fn from_inner (inner : StakingPosition) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn underlying_inst_name (& self) -> PyResult < String > { Ok (self . inner . underlying_inst_name . clone () . into ()) } # [getter] fn staked_quantity (& self) -> PyResult < String > { Ok (self . inner . staked_quantity . clone () . into ()) } # [getter] fn pending_staked_quantity (& self) -> PyResult < String > { Ok (self . inner . pending_staked_quantity . clone () . into ()) } # [getter] fn pending_unstaked_quantity (& self) -> PyResult < String > { Ok (self . inner . pending_unstaked_quantity . clone () . into ()) } # [getter] fn reward_eligible_quantity (& self) -> PyResult < String > { Ok (self . inner . reward_eligible_quantity . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetStakingPositionResult { inner : venues :: GetStakingPositionResult , } # [pymethods] impl GetStakingPositionResult { # [staticmethod] fn from_inner (inner : GetStakingPositionResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_staking_position <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_staking_position () . await }) } } # [pyclass] # [derive (Clone)] pub struct Position { inner : venues :: Position , } # [pymethods] impl Position { # [staticmethod] fn from_inner (inner : Position) -> Self { Self { inner } } # [getter] fn account_id (& self) -> PyResult < String > { Ok (self . inner . account_id . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn cost (& self) -> PyResult < String > { Ok (self . inner . cost . clone () . into ()) } # [getter] fn open_position_pnl (& self) -> PyResult < String > { Ok (self . inner . open_position_pnl . clone () . into ()) } # [getter] fn open_pos_cost (& self) -> PyResult < String > { Ok (self . inner . open_pos_cost . clone () . into ()) } # [getter] fn session_pnl (& self) -> PyResult < String > { Ok (self . inner . session_pnl . clone () . into ()) } # [getter] fn update_timestamp_ms (& self) -> PyResult < u64 > { Ok (self . inner . update_timestamp_ms . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn position_type (& self) -> PyResult < String > { Ok (self . inner . position_type . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetPositionsResult { inner : venues :: GetPositionsResult , } # [pymethods] impl GetPositionsResult { # [staticmethod] fn from_inner (inner : GetPositionsResult) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetPositionsRequest { inner : venues :: GetPositionsRequest , } # [pymethods] impl GetPositionsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . instrument_name . clone () . into ()) } } # [pymethods] impl RestClient { fn get_positions <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_positions () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateOcoOrderRequest { inner : venues :: CreateOcoOrderRequest , } # [pymethods] impl CreateOcoOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn contingency_type (& self) -> PyResult < String > { Ok (self . inner . contingency_type . clone () . into ()) } # [getter] fn order_list (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . order_list . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OcoOrderItem { inner : venues :: OcoOrderItem , } # [pymethods] impl OcoOrderItem { # [staticmethod] fn from_inner (inner : OcoOrderItem) -> Self { Self { inner } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn ref_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . ref_price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateOcoOrderResult { inner : venues :: CreateOcoOrderResult , } # [pymethods] impl CreateOcoOrderResult { # [staticmethod] fn from_inner (inner : CreateOcoOrderResult) -> Self { Self { inner } } # [getter] fn list_id (& self) -> PyResult < String > { Ok (self . inner . list_id . clone () . into ()) } } # [pymethods] impl RestClient { fn create_oco_order_list <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_oco_order_list () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOrderHistoryByInstrumentRequest { inner : venues :: GetOrderHistoryByInstrumentRequest , } # [pymethods] impl GetOrderHistoryByInstrumentRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn include_old (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . include_old . clone () . into ()) } # [getter] fn include_unfilled (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . include_unfilled . clone () . into ()) } # [getter] fn with_continuation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . with_continuation . clone () . into ()) } # [getter] fn continuation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . continuation . clone () . into ()) } # [getter] fn historical (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . historical . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderHistoryByInstrumentEntry { inner : venues :: OrderHistoryByInstrumentEntry , } # [pymethods] impl OrderHistoryByInstrumentEntry { # [staticmethod] fn from_inner (inner : OrderHistoryByInstrumentEntry) -> Self { Self { inner } } # [getter] fn quote (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote . clone () . into ()) } # [getter] fn triggered (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . triggered . clone () . into ()) } # [getter] fn mobile (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mobile . clone () . into ()) } # [getter] fn app_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . app_name . clone () . into ()) } # [getter] fn implv (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . implv . clone () . into ()) } # [getter] fn refresh_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . refresh_amount . clone () . into ()) } # [getter] fn usd (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . usd . clone () . into ()) } # [getter] fn oto_order_ids (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . oto_order_ids . clone () . into ()) } # [getter] fn api (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . api . clone () . into ()) } # [getter] fn average_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . average_price . clone () . into ()) } # [getter] fn advanced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . advanced . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn post_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . post_only . clone () . into ()) } # [getter] fn filled_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . filled_amount . clone () . into ()) } # [getter] fn trigger (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger . clone () . into ()) } # [getter] fn trigger_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trigger_order_id . clone () . into ()) } # [getter] fn direction (& self) -> PyResult < String > { Ok (self . inner . direction . clone () . into ()) } # [getter] fn contracts (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contracts . clone () . into ()) } # [getter] fn is_secondary_oto (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_secondary_oto . clone () . into ()) } # [getter] fn replaced (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . replaced . clone () . into ()) } # [getter] fn mmp_group (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp_group . clone () . into ()) } # [getter] fn mmp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . mmp . clone () . into ()) } # [getter] fn last_update_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . last_update_timestamp . clone () . into ()) } # [getter] fn creation_timestamp (& self) -> PyResult < i64 > { Ok (self . inner . creation_timestamp . clone () . into ()) } # [getter] fn order_state (& self) -> PyResult < String > { Ok (self . inner . order_state . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < String > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn instrument_name (& self) -> PyResult < String > { Ok (self . inner . instrument_name . clone () . into ()) } # [getter] fn cumulative_amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cumulative_amount . clone () . into ()) } # [getter] fn cumulative_fee (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cumulative_fee . clone () . into ()) } # [getter] fn client_oid (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_oid . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderHistoryByInstrumentResponse { inner : venues :: GetOrderHistoryByInstrumentResponse , } # [pymethods] impl GetOrderHistoryByInstrumentResponse { # [staticmethod] fn from_inner (inner : GetOrderHistoryByInstrumentResponse) -> Self { Self { inner } } # [getter] fn result (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . result . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderHistoryByInstrumentWithContinuationResponse { inner : venues :: GetOrderHistoryByInstrumentWithContinuationResponse , } # [pymethods] impl GetOrderHistoryByInstrumentWithContinuationResponse { # [staticmethod] fn from_inner (inner : GetOrderHistoryByInstrumentWithContinuationResponse) -> Self { Self { inner } } # [getter] fn result (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . result . clone () . into ()) } # [getter] fn continuation (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . continuation . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_history_by_instrument <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_history_by_instrument () . await }) } } # [pyclass] # [derive (Clone)] pub struct ErrorResponse { inner : venues :: ErrorResponse , } # [pymethods] impl ErrorResponse { # [staticmethod] fn from_inner (inner : ErrorResponse) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < i64 > { Ok (self . inner . code . clone () . into ()) } # [getter] fn message (& self) -> PyResult < String > { Ok (self . inner . message . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub enum EndpointType { PrivateCreateOrder , PrivateCancelOrder , PrivateCancelAllOrders , PrivateGetOrderDetail , PrivateGetTrades , PrivateGetOrderHistory , PrivateGetTransactions , PrivateOther , PublicGetAnnouncements , PublicGetRiskParameters , PublicGetInstruments , PublicGetBook , PublicGetTicker , PublicGetTickers , PublicGetTrades , PublicGetValuations , PublicGetCandlestick , PublicGetExpiredSettlementPrice , PublicGetInsurance , PublicStaking , PrivateStaking , UserApi , MarketData , } # [pyclass] # [derive (Clone)] pub struct RateLimit { inner : venues :: RateLimit , } # [pymethods] impl RateLimit { # [staticmethod] fn from_inner (inner : RateLimit) -> Self { Self { inner } } # [getter] fn max_requests (& self) -> PyResult < u64 > { Ok (self . inner . max_requests . clone () . into ()) } # [getter] fn window (& self) -> PyResult < PyObject > { Ok (self . inner . window . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RateLimiter { inner : venues :: RateLimiter , } # [pymethods] impl RateLimiter { # [staticmethod] fn from_inner (inner : RateLimiter) -> Self { Self { inner } } } # [doc = " Create the Python module for cryptocom"] pub fn create_module (py : Python) -> PyResult <& PyModule > { let m = PyModule :: new (py , "cryptocom") ?; Ok (m) }