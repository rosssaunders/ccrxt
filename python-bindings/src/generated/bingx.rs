# ! [doc = " Python bindings for bingx venue"] # ! [doc = ""] # ! [doc = " This module is automatically generated from the Rust source code."] # ! [doc = " Do not edit this file directly."] use pyo3 :: prelude ::*; use pyo3_asyncio ; use venues ; # [pyclass] # [derive (Clone)] pub enum AccountType { Spot , StdFutures , CoinMPerp , UsdtMPerp , CopyTrading , Grid , Earn , C2C , } # [pyclass] # [derive (Clone)] pub enum DepositStatus { InProgress , Completed , ChainUploaded , } # [pyclass] # [derive (Clone)] pub enum WithdrawStatus { UnderReview , Failed , Completed , } # [pyclass] # [derive (Clone)] pub enum TransferType { FundToStandardFutures , StandardFuturesToFund , FundToPerpetualFutures , PerpetualFuturesToFund , StandardToPerpetualFutures , PerpetualToStandardFutures , FundToGrid , GridToFund , FundToCopyTrade , StandardFuturesToCopyTrade , PerpetualFuturesToCopyTrade , CopyTradeToFund , CopyTradeToStandardFutures , CopyTradeToPerpetualFutures , FundToSpot , SpotToFund , } # [pyclass] # [derive (Clone)] pub enum WalletType { Fund , Standard , Perpetual , Spot , } # [pyclass] # [derive (Clone)] pub enum UserAccountType { Uid , Phone , Email , } # [pyclass] # [derive (Clone)] pub enum OrderType { Market , Limit , TakeStopLimit , TakeStopMarket , TriggerLimit , TriggerMarket , } # [pyclass] # [derive (Clone)] pub enum OrderSide { Buy , Sell , } # [pyclass] # [derive (Clone)] pub enum OrderStatus { New , Pending , PartiallyFilled , Filled , Canceled , Failed , } # [pyclass] # [derive (Clone)] pub enum TimeInForce { Gtc , Ioc , Fok , PostOnly , } # [pyclass] # [derive (Clone)] pub enum ApiPermission { SpotTrading , Read , PerpetualFuturesTrading , UniversalTransfer , Withdrawal , SubAccountInternalTransfer , } # [pyclass] # [derive (Clone)] pub enum CancelReplaceMode { StopOnFailure , AllowFailure , } # [pyclass] # [derive (Clone)] pub enum OcoOrderType { OcoLimit , OcoTps , } # [pyclass] # [derive (Clone)] pub enum CancelAllAfterStatus { Activated , Closed , Failed , } # [pyclass] # [derive (Clone)] pub enum CancelAllAfterType { Activate , Close , } # [pyclass] # [derive (Clone)] pub enum TransferStatus { PendingReview , Failed , Completed , } # [pyclass] # [derive (Clone)] pub enum AddressStatus { Activated , Applied , NotApplied , } # [pyclass] # [derive (Clone)] pub enum SubAccountType { Master , SubAccount , Spot , } # [pyclass] # [derive (Clone)] pub enum SubAccountTransferType { ToSub , MainCapitalToSubCapital , MainCapitalToSubContract , MainCapitalToSubSwap , MainContractToSubCapital , MainContractToSubContract , MainContractToSubSwap , MainSwapToSubCapital , MainSwapToSubContract , MainSwapToSubSwap , SubCapitalToMainCapital , SubCapitalToMainContract , SubCapitalToMainSwap , SubContractToMainCapital , SubContractToMainContract , SubContractToMainSwap , SubSwapToMainCapital , SubSwapToMainContract , SubSwapToMainSwap , } # [pyclass] # [derive (Clone)] pub enum NewTransferAccount { Fund , Spot , StdFutures , CoinMPerp , UsdtMPerp , } # [pyclass] # [derive (Clone)] pub enum RecordType { Out , In , } # [pyclass] # [derive (Clone)] pub enum CancelRestriction { New , Pending , PartiallyFilled , } # [pyclass] # [derive (Clone)] pub enum OcoOrderStatus { Response , ExecStarted , AllDone , Executing , Done , } # [pyclass] # [derive (Clone)] pub enum SubAccountStatus { Normal , Frozen , Suspended , } # [pyclass] # [derive (Clone)] pub enum RiskLevel { Low , Medium , High , Critical , } # [pyclass] # [derive (Clone)] pub enum RiskStatus { Active , Resolved , Mitigated , } # [pyclass] # [derive (Clone)] pub enum ApiKeyStatus { Active , Inactive , Suspended , } # [pyclass] # [derive (Clone)] pub enum SubAccountTransferDirection { ToSub , ToMaster , } # [pyclass] # [derive (Clone)] pub enum Interval { OneMinute , ThreeMinutes , FiveMinutes , FifteenMinutes , ThirtyMinutes , OneHour , TwoHours , FourHours , SixHours , EightHours , TwelveHours , OneDay , ThreeDays , OneWeek , OneMonth , } # [pyclass] # [derive (Clone)] pub enum SymbolStatus { Offline , Online , PreOpen , TradingSuspended , } # [pyclass] # [derive (Clone)] pub enum DepthType { Step0 , Step1 , Step2 , Step3 , Step4 , Step5 , } # [pyclass] # [derive (Clone)] pub struct GetOrderBookAggregationRequest { inner : venues :: GetOrderBookAggregationRequest , } # [pymethods] impl GetOrderBookAggregationRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderBookAggregationResponse { inner : venues :: GetOrderBookAggregationResponse , } # [pymethods] impl GetOrderBookAggregationResponse { # [staticmethod] fn from_inner (inner : GetOrderBookAggregationResponse) -> Self { Self { inner } } # [getter] fn bids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . bids . clone () . into ()) } # [getter] fn asks (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . asks . clone () . into ()) } # [getter] fn ts (& self) -> PyResult < i64 > { Ok (self . inner . ts . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_book_aggregation <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_book_aggregation () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } # [getter] fn base_url (& self) -> PyResult < PyObject > { Ok (self . inner . base_url . clone () . into ()) } # [getter] fn client (& self) -> PyResult < PyObject > { Ok (self . inner . client . clone () . into ()) } # [getter] fn rate_limiter (& self) -> PyResult < PyObject > { Ok (self . inner . rate_limiter . clone () . into ()) } } # [pymethods] impl RestClient { fn send_request <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_request () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetHistoricalKlineRequest { inner : venues :: GetHistoricalKlineRequest , } # [pymethods] impl GetHistoricalKlineRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < PyObject > { Ok (self . inner . interval . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_historical_kline <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_historical_kline () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOldTradeRequest { inner : venues :: GetOldTradeRequest , } # [pymethods] impl GetOldTradeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn from_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OldTrade { inner : venues :: OldTrade , } # [pymethods] impl OldTrade { # [staticmethod] fn from_inner (inner : OldTrade) -> Self { Self { inner } } # [getter] fn tid (& self) -> PyResult < String > { Ok (self . inner . tid . clone () . into ()) } # [getter] fn t (& self) -> PyResult < i64 > { Ok (self . inner . t . clone () . into ()) } # [getter] fn ms (& self) -> PyResult < i64 > { Ok (self . inner . ms . clone () . into ()) } # [getter] fn s (& self) -> PyResult < String > { Ok (self . inner . s . clone () . into ()) } # [getter] fn p (& self) -> PyResult < f64 > { Ok (self . inner . p . clone () . into ()) } # [getter] fn v (& self) -> PyResult < f64 > { Ok (self . inner . v . clone () . into ()) } } # [pymethods] impl RestClient { fn get_old_trade <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_old_trade () . await }) } } # [pyclass] # [derive (Clone)] pub struct Get24hrTickerRequest { inner : venues :: Get24hrTickerRequest , } # [pymethods] impl Get24hrTickerRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct Ticker24hr { inner : venues :: Ticker24hr , } # [pymethods] impl Ticker24hr { # [staticmethod] fn from_inner (inner : Ticker24hr) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn open_price (& self) -> PyResult < f64 > { Ok (self . inner . open_price . clone () . into ()) } # [getter] fn high_price (& self) -> PyResult < f64 > { Ok (self . inner . high_price . clone () . into ()) } # [getter] fn low_price (& self) -> PyResult < f64 > { Ok (self . inner . low_price . clone () . into ()) } # [getter] fn last_price (& self) -> PyResult < f64 > { Ok (self . inner . last_price . clone () . into ()) } # [getter] fn price_change (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price_change . clone () . into ()) } # [getter] fn volume (& self) -> PyResult < f64 > { Ok (self . inner . volume . clone () . into ()) } # [getter] fn quote_volume (& self) -> PyResult < f64 > { Ok (self . inner . quote_volume . clone () . into ()) } # [getter] fn open_time (& self) -> PyResult < i64 > { Ok (self . inner . open_time . clone () . into ()) } # [getter] fn close_time (& self) -> PyResult < i64 > { Ok (self . inner . close_time . clone () . into ()) } # [getter] fn count (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count . clone () . into ()) } # [getter] fn ask_price (& self) -> PyResult < f64 > { Ok (self . inner . ask_price . clone () . into ()) } # [getter] fn ask_qty (& self) -> PyResult < f64 > { Ok (self . inner . ask_qty . clone () . into ()) } # [getter] fn bid_price (& self) -> PyResult < f64 > { Ok (self . inner . bid_price . clone () . into ()) } # [getter] fn bid_qty (& self) -> PyResult < f64 > { Ok (self . inner . bid_qty . clone () . into ()) } # [getter] fn price_change_percent (& self) -> PyResult < String > { Ok (self . inner . price_change_percent . clone () . into ()) } } # [pymethods] impl RestClient { fn get_24hr_ticker <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_24hr_ticker () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetKlineRequest { inner : venues :: GetKlineRequest , } # [pymethods] impl GetKlineRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < PyObject > { Ok (self . inner . interval . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pymethods] impl RestClient { fn get_kline <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_kline () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetServerTimeRequest { inner : venues :: GetServerTimeRequest , } # [pymethods] impl GetServerTimeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } } # [pyclass] # [derive (Clone)] pub struct GetServerTimeResponse { inner : venues :: GetServerTimeResponse , } # [pymethods] impl GetServerTimeResponse { # [staticmethod] fn from_inner (inner : GetServerTimeResponse) -> Self { Self { inner } } # [getter] fn server_time (& self) -> PyResult < i64 > { Ok (self . inner . server_time . clone () . into ()) } } # [pymethods] impl RestClient { fn get_server_time <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_server_time () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetSymbolOrderBookTickerRequest { inner : venues :: GetSymbolOrderBookTickerRequest , } # [pymethods] impl GetSymbolOrderBookTickerRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderBookTicker { inner : venues :: OrderBookTicker , } # [pymethods] impl OrderBookTicker { # [staticmethod] fn from_inner (inner : OrderBookTicker) -> Self { Self { inner } } # [getter] fn event_type (& self) -> PyResult < String > { Ok (self . inner . event_type . clone () . into ()) } # [getter] fn time (& self) -> PyResult < i64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn bid_price (& self) -> PyResult < String > { Ok (self . inner . bid_price . clone () . into ()) } # [getter] fn bid_volume (& self) -> PyResult < String > { Ok (self . inner . bid_volume . clone () . into ()) } # [getter] fn ask_price (& self) -> PyResult < String > { Ok (self . inner . ask_price . clone () . into ()) } # [getter] fn ask_volume (& self) -> PyResult < String > { Ok (self . inner . ask_volume . clone () . into ()) } } # [pymethods] impl RestClient { fn get_symbol_order_book_ticker <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_symbol_order_book_ticker () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetRecentTradesRequest { inner : venues :: GetRecentTradesRequest , } # [pymethods] impl GetRecentTradesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct Trade { inner : venues :: Trade , } # [pymethods] impl Trade { # [staticmethod] fn from_inner (inner : Trade) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn qty (& self) -> PyResult < f64 > { Ok (self . inner . qty . clone () . into ()) } # [getter] fn time (& self) -> PyResult < i64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn buyer_maker (& self) -> PyResult < bool > { Ok (self . inner . buyer_maker . clone () . into ()) } } # [pymethods] impl RestClient { fn get_recent_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_recent_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOrderBookRequest { inner : venues :: GetOrderBookRequest , } # [pymethods] impl GetOrderBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderBookResponse { inner : venues :: GetOrderBookResponse , } # [pymethods] impl GetOrderBookResponse { # [staticmethod] fn from_inner (inner : GetOrderBookResponse) -> Self { Self { inner } } # [getter] fn bids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . bids . clone () . into ()) } # [getter] fn asks (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . asks . clone () . into ()) } # [getter] fn ts (& self) -> PyResult < i64 > { Ok (self . inner . ts . clone () . into ()) } # [getter] fn last_update_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . last_update_id . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetSymbolPriceTickerRequest { inner : venues :: GetSymbolPriceTickerRequest , } # [pymethods] impl GetSymbolPriceTickerRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SymbolTicker { inner : venues :: SymbolTicker , } # [pymethods] impl SymbolTicker { # [staticmethod] fn from_inner (inner : SymbolTicker) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TradeData { inner : venues :: TradeData , } # [pymethods] impl TradeData { # [staticmethod] fn from_inner (inner : TradeData) -> Self { Self { inner } } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn trade_id (& self) -> PyResult < String > { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn trade_type (& self) -> PyResult < i64 > { Ok (self . inner . trade_type . clone () . into ()) } # [getter] fn volume (& self) -> PyResult < String > { Ok (self . inner . volume . clone () . into ()) } } # [pymethods] impl RestClient { fn get_symbol_price_ticker <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_symbol_price_ticker () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetSymbolsRequest { inner : venues :: GetSymbolsRequest , } # [pymethods] impl GetSymbolsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetSymbolsResponse { inner : venues :: GetSymbolsResponse , } # [pymethods] impl GetSymbolsResponse { # [staticmethod] fn from_inner (inner : GetSymbolsResponse) -> Self { Self { inner } } # [getter] fn symbols (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . symbols . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct Symbol { inner : venues :: Symbol , } # [pymethods] impl Symbol { # [staticmethod] fn from_inner (inner : Symbol) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn tick_size (& self) -> PyResult < f64 > { Ok (self . inner . tick_size . clone () . into ()) } # [getter] fn step_size (& self) -> PyResult < f64 > { Ok (self . inner . step_size . clone () . into ()) } # [getter] fn min_qty (& self) -> PyResult < f64 > { Ok (self . inner . min_qty . clone () . into ()) } # [getter] fn max_qty (& self) -> PyResult < f64 > { Ok (self . inner . max_qty . clone () . into ()) } # [getter] fn min_notional (& self) -> PyResult < f64 > { Ok (self . inner . min_notional . clone () . into ()) } # [getter] fn max_notional (& self) -> PyResult < f64 > { Ok (self . inner . max_notional . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn api_state_buy (& self) -> PyResult < bool > { Ok (self . inner . api_state_buy . clone () . into ()) } # [getter] fn api_state_sell (& self) -> PyResult < bool > { Ok (self . inner . api_state_sell . clone () . into ()) } # [getter] fn time_online (& self) -> PyResult < i64 > { Ok (self . inner . time_online . clone () . into ()) } # [getter] fn off_time (& self) -> PyResult < i64 > { Ok (self . inner . off_time . clone () . into ()) } # [getter] fn maintain_time (& self) -> PyResult < i64 > { Ok (self . inner . maintain_time . clone () . into ()) } } # [pymethods] impl RestClient { fn get_symbols <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_symbols () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetDepositAddressRequest { inner : venues :: GetDepositAddressRequest , } # [pymethods] impl GetDepositAddressRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn coin (& self) -> PyResult < String > { Ok (self . inner . coin . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetDepositAddressResponse { inner : venues :: GetDepositAddressResponse , } # [pymethods] impl GetDepositAddressResponse { # [staticmethod] fn from_inner (inner : GetDepositAddressResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } # [getter] fn total (& self) -> PyResult < i64 > { Ok (self . inner . total . clone () . into ()) } } # [pymethods] impl RestClient { fn get_deposit_address <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_deposit_address () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOpenOcoOrdersRequest { inner : venues :: GetOpenOcoOrdersRequest , } # [pymethods] impl GetOpenOcoOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn page_index (& self) -> PyResult < i64 > { Ok (self . inner . page_index . clone () . into ()) } # [getter] fn page_size (& self) -> PyResult < i64 > { Ok (self . inner . page_size . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOpenOcoOrdersResponse { inner : venues :: GetOpenOcoOrdersResponse , } # [pymethods] impl GetOpenOcoOrdersResponse { # [staticmethod] fn from_inner (inner : GetOpenOcoOrdersResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OpenOcoOrder { inner : venues :: OpenOcoOrder , } # [pymethods] impl OpenOcoOrder { # [staticmethod] fn from_inner (inner : OpenOcoOrder) -> Self { Self { inner } } # [getter] fn transaction_time (& self) -> PyResult < i64 > { Ok (self . inner . transaction_time . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn trigger_price (& self) -> PyResult < f64 > { Ok (self . inner . trigger_price . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < f64 > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn order_list_id (& self) -> PyResult < String > { Ok (self . inner . order_list_id . clone () . into ()) } } # [pymethods] impl RestClient { fn get_open_oco_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_open_oco_orders () . await }) } } # [pyclass] # [derive (Clone)] pub enum AccountType { Spot , StdFutures , CoinMPerp , UsdtmPerp , CopyTrading , Grid , Eran , C2c , } # [pyclass] # [derive (Clone)] pub struct GetAllAccountBalanceRequest { inner : venues :: GetAllAccountBalanceRequest , } # [pymethods] impl GetAllAccountBalanceRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn account_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . account_type . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AccountBalanceOverview { inner : venues :: AccountBalanceOverview , } # [pymethods] impl AccountBalanceOverview { # [staticmethod] fn from_inner (inner : AccountBalanceOverview) -> Self { Self { inner } } # [getter] fn account_type (& self) -> PyResult < PyObject > { Ok (self . inner . account_type . clone () . into ()) } # [getter] fn usdt_balance (& self) -> PyResult < String > { Ok (self . inner . usdt_balance . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetAllAccountBalanceResponse { inner : venues :: GetAllAccountBalanceResponse , } # [pymethods] impl GetAllAccountBalanceResponse { # [staticmethod] fn from_inner (inner : GetAllAccountBalanceResponse) -> Self { Self { inner } } # [getter] fn accounts (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . accounts . clone () . into ()) } } # [pymethods] impl RestClient { fn get_all_account_balance <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_all_account_balance () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelMultipleOrdersResponseItem { inner : venues :: CancelMultipleOrdersResponseItem , } # [pymethods] impl CancelMultipleOrdersResponseItem { # [staticmethod] fn from_inner (inner : CancelMultipleOrdersResponseItem) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < i64 > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn orig_qty (& self) -> PyResult < String > { Ok (self . inner . orig_qty . clone () . into ()) } # [getter] fn executed_qty (& self) -> PyResult < String > { Ok (self . inner . executed_qty . clone () . into ()) } # [getter] fn cummulative_quote_qty (& self) -> PyResult < String > { Ok (self . inner . cummulative_quote_qty . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelMultipleOrdersRequest { inner : venues :: CancelMultipleOrdersRequest , } # [pymethods] impl CancelMultipleOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn process (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . process . clone () . into ()) } # [getter] fn order_ids (& self) -> PyResult < String > { Ok (self . inner . order_ids . clone () . into ()) } # [getter] fn client_order_ids (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_order_ids . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelMultipleOrdersResponse { inner : venues :: CancelMultipleOrdersResponse , } # [pymethods] impl CancelMultipleOrdersResponse { # [staticmethod] fn from_inner (inner : CancelMultipleOrdersResponse) -> Self { Self { inner } } # [getter] fn orders (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . orders . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_multiple_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_multiple_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetWithdrawRecordsRequest { inner : venues :: GetWithdrawRecordsRequest , } # [pymethods] impl GetWithdrawRecordsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . id . clone () . into ()) } # [getter] fn coin (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . coin . clone () . into ()) } # [getter] fn withdraw_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . withdraw_order_id . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetWithdrawRecordsResponse { inner : venues :: GetWithdrawRecordsResponse , } # [pymethods] impl GetWithdrawRecordsResponse { # [staticmethod] fn from_inner (inner : GetWithdrawRecordsResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_withdraw_records <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_withdraw_records () . await }) } } # [pyclass] # [derive (Clone)] pub struct Trade { inner : venues :: Trade , } # [pymethods] impl Trade { # [staticmethod] fn from_inner (inner : Trade) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < i64 > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn qty (& self) -> PyResult < String > { Ok (self . inner . qty . clone () . into ()) } # [getter] fn quote_qty (& self) -> PyResult < String > { Ok (self . inner . quote_qty . clone () . into ()) } # [getter] fn commission (& self) -> PyResult < f64 > { Ok (self . inner . commission . clone () . into ()) } # [getter] fn commission_asset (& self) -> PyResult < String > { Ok (self . inner . commission_asset . clone () . into ()) } # [getter] fn time (& self) -> PyResult < i64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn is_buyer (& self) -> PyResult < bool > { Ok (self . inner . is_buyer . clone () . into ()) } # [getter] fn is_maker (& self) -> PyResult < bool > { Ok (self . inner . is_maker . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetTradeHistoryRequest { inner : venues :: GetTradeHistoryRequest , } # [pymethods] impl GetTradeHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn from_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from_id . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetTradeHistoryResponse { inner : venues :: GetTradeHistoryResponse , } # [pymethods] impl GetTradeHistoryResponse { # [staticmethod] fn from_inner (inner : GetTradeHistoryResponse) -> Self { Self { inner } } # [getter] fn trades (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . trades . clone () . into ()) } } # [pymethods] impl RestClient { fn get_trade_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_trade_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct FreezeSubAccountRequest { inner : venues :: FreezeSubAccountRequest , } # [pymethods] impl FreezeSubAccountRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn sub_uid (& self) -> PyResult < String > { Ok (self . inner . sub_uid . clone () . into ()) } # [getter] fn is_freeze (& self) -> PyResult < bool > { Ok (self . inner . is_freeze . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FreezeSubAccountResponse { inner : venues :: FreezeSubAccountResponse , } # [pymethods] impl FreezeSubAccountResponse { # [staticmethod] fn from_inner (inner : FreezeSubAccountResponse) -> Self { Self { inner } } # [getter] fn success (& self) -> PyResult < bool > { Ok (self . inner . success . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FreezeSubAccountData { inner : venues :: FreezeSubAccountData , } # [pymethods] impl FreezeSubAccountData { # [staticmethod] fn from_inner (inner : FreezeSubAccountData) -> Self { Self { inner } } # [getter] fn sub_uid (& self) -> PyResult < String > { Ok (self . inner . sub_uid . clone () . into ()) } # [getter] fn email (& self) -> PyResult < String > { Ok (self . inner . email . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < i64 > { Ok (self . inner . update_time . clone () . into ()) } } # [pymethods] impl RestClient { fn freeze_sub_account <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . freeze_sub_account () . await }) } } # [pyclass] # [derive (Clone)] pub struct HistoricalOrder { inner : venues :: HistoricalOrder , } # [pymethods] impl HistoricalOrder { # [staticmethod] fn from_inner (inner : HistoricalOrder) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < i64 > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn orig_qty (& self) -> PyResult < String > { Ok (self . inner . orig_qty . clone () . into ()) } # [getter] fn executed_qty (& self) -> PyResult < String > { Ok (self . inner . executed_qty . clone () . into ()) } # [getter] fn cummulative_quote_qty (& self) -> PyResult < String > { Ok (self . inner . cummulative_quote_qty . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn time (& self) -> PyResult < i64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < i64 > { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn orig_quote_order_qty (& self) -> PyResult < String > { Ok (self . inner . orig_quote_order_qty . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < f64 > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_price . clone () . into ()) } # [getter] fn avg_price (& self) -> PyResult < String > { Ok (self . inner . avg_price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderHistoryRequest { inner : venues :: GetOrderHistoryRequest , } # [pymethods] impl GetOrderHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn page_index (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page_index . clone () . into ()) } # [getter] fn page_size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page_size . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOrderHistoryResponse { inner : venues :: GetOrderHistoryResponse , } # [pymethods] impl GetOrderHistoryResponse { # [staticmethod] fn from_inner (inner : GetOrderHistoryResponse) -> Self { Self { inner } } # [getter] fn orders (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . orders . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetCurrencyConfigRequest { inner : venues :: GetCurrencyConfigRequest , } # [pymethods] impl GetCurrencyConfigRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn coin (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . coin . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct NetworkInfo { inner : venues :: NetworkInfo , } # [pymethods] impl NetworkInfo { # [staticmethod] fn from_inner (inner : NetworkInfo) -> Self { Self { inner } } # [getter] fn name (& self) -> PyResult < String > { Ok (self . inner . name . clone () . into ()) } # [getter] fn network (& self) -> PyResult < String > { Ok (self . inner . network . clone () . into ()) } # [getter] fn deposit_enable (& self) -> PyResult < bool > { Ok (self . inner . deposit_enable . clone () . into ()) } # [getter] fn deposit_min (& self) -> PyResult < String > { Ok (self . inner . deposit_min . clone () . into ()) } # [getter] fn min_confirm (& self) -> PyResult < i64 > { Ok (self . inner . min_confirm . clone () . into ()) } # [getter] fn is_default (& self) -> PyResult < bool > { Ok (self . inner . is_default . clone () . into ()) } # [getter] fn withdraw_enable (& self) -> PyResult < bool > { Ok (self . inner . withdraw_enable . clone () . into ()) } # [getter] fn withdraw_fee (& self) -> PyResult < String > { Ok (self . inner . withdraw_fee . clone () . into ()) } # [getter] fn withdraw_max (& self) -> PyResult < String > { Ok (self . inner . withdraw_max . clone () . into ()) } # [getter] fn withdraw_min (& self) -> PyResult < String > { Ok (self . inner . withdraw_min . clone () . into ()) } # [getter] fn withdraw_desc (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . withdraw_desc . clone () . into ()) } # [getter] fn withdraw_precision (& self) -> PyResult < i64 > { Ok (self . inner . withdraw_precision . clone () . into ()) } # [getter] fn deposit_precision (& self) -> PyResult < i64 > { Ok (self . inner . deposit_precision . clone () . into ()) } # [getter] fn contract_address (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract_address . clone () . into ()) } # [getter] fn need_tag_or_memo (& self) -> PyResult < bool > { Ok (self . inner . need_tag_or_memo . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CurrencyConfig { inner : venues :: CurrencyConfig , } # [pymethods] impl CurrencyConfig { # [staticmethod] fn from_inner (inner : CurrencyConfig) -> Self { Self { inner } } # [getter] fn coin (& self) -> PyResult < String > { Ok (self . inner . coin . clone () . into ()) } # [getter] fn name (& self) -> PyResult < String > { Ok (self . inner . name . clone () . into ()) } # [getter] fn network_list (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . network_list . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetCurrencyConfigResponse { inner : venues :: GetCurrencyConfigResponse , } # [pymethods] impl GetCurrencyConfigResponse { # [staticmethod] fn from_inner (inner : GetCurrencyConfigResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_currency_config <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_currency_config () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetSubAccountListRequest { inner : venues :: GetSubAccountListRequest , } # [pymethods] impl GetSubAccountListRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn email (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . email . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . size . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetSubAccountListResponse { inner : venues :: GetSubAccountListResponse , } # [pymethods] impl GetSubAccountListResponse { # [staticmethod] fn from_inner (inner : GetSubAccountListResponse) -> Self { Self { inner } } # [getter] fn sub_accounts (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . sub_accounts . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SubAccountInfo { inner : venues :: SubAccountInfo , } # [pymethods] impl SubAccountInfo { # [staticmethod] fn from_inner (inner : SubAccountInfo) -> Self { Self { inner } } # [getter] fn email (& self) -> PyResult < String > { Ok (self . inner . email . clone () . into ()) } # [getter] fn sub_account_id (& self) -> PyResult < String > { Ok (self . inner . sub_account_id . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn activated (& self) -> PyResult < bool > { Ok (self . inner . activated . clone () . into ()) } # [getter] fn mobile (& self) -> PyResult < bool > { Ok (self . inner . mobile . clone () . into ()) } # [getter] fn gauth (& self) -> PyResult < bool > { Ok (self . inner . gauth . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < i64 > { Ok (self . inner . create_time . clone () . into ()) } } # [pymethods] impl RestClient { fn get_sub_account_list <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_sub_account_list () . await }) } } # [pyclass] # [derive (Clone)] pub struct QueryOcoOrderRequest { inner : venues :: QueryOcoOrderRequest , } # [pymethods] impl QueryOcoOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn order_list_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_list_id . clone () . into ()) } # [getter] fn orig_client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . orig_client_order_id . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct QueryOcoOrderResponse { inner : venues :: QueryOcoOrderResponse , } # [pymethods] impl QueryOcoOrderResponse { # [staticmethod] fn from_inner (inner : QueryOcoOrderResponse) -> Self { Self { inner } } # [getter] fn order_list_id (& self) -> PyResult < i64 > { Ok (self . inner . order_list_id . clone () . into ()) } # [getter] fn contingency_type (& self) -> PyResult < String > { Ok (self . inner . contingency_type . clone () . into ()) } # [getter] fn list_status_type (& self) -> PyResult < PyObject > { Ok (self . inner . list_status_type . clone () . into ()) } # [getter] fn list_order_status (& self) -> PyResult < PyObject > { Ok (self . inner . list_order_status . clone () . into ()) } # [getter] fn list_client_order_id (& self) -> PyResult < String > { Ok (self . inner . list_client_order_id . clone () . into ()) } # [getter] fn transaction_time (& self) -> PyResult < i64 > { Ok (self . inner . transaction_time . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn orders (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . orders . clone () . into ()) } # [getter] fn order_reports (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . order_reports . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OcoSubOrder { inner : venues :: OcoSubOrder , } # [pymethods] impl OcoSubOrder { # [staticmethod] fn from_inner (inner : OcoSubOrder) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < i64 > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OcoOrderReport { inner : venues :: OcoOrderReport , } # [pymethods] impl OcoOrderReport { # [staticmethod] fn from_inner (inner : OcoOrderReport) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < i64 > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn order_list_id (& self) -> PyResult < i64 > { Ok (self . inner . order_list_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn transaction_time (& self) -> PyResult < i64 > { Ok (self . inner . transaction_time . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn orig_qty (& self) -> PyResult < String > { Ok (self . inner . orig_qty . clone () . into ()) } # [getter] fn executed_qty (& self) -> PyResult < String > { Ok (self . inner . executed_qty . clone () . into ()) } # [getter] fn cummulative_quote_qty (& self) -> PyResult < String > { Ok (self . inner . cummulative_quote_qty . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < String > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn r#type (& self) -> PyResult < String > { Ok (self . inner . r#type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_price . clone () . into ()) } } # [pymethods] impl RestClient { fn query_oco_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . query_oco_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct InternalTransferApplyRequest { inner : venues :: InternalTransferApplyRequest , } # [pymethods] impl InternalTransferApplyRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn coin (& self) -> PyResult < String > { Ok (self . inner . coin . clone () . into ()) } # [getter] fn user_account_type (& self) -> PyResult < i64 > { Ok (self . inner . user_account_type . clone () . into ()) } # [getter] fn user_account (& self) -> PyResult < String > { Ok (self . inner . user_account . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn calling_code (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . calling_code . clone () . into ()) } # [getter] fn wallet_type (& self) -> PyResult < i64 > { Ok (self . inner . wallet_type . clone () . into ()) } # [getter] fn transfer_client_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . transfer_client_id . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct InternalTransferApplyResponse { inner : venues :: InternalTransferApplyResponse , } # [pymethods] impl InternalTransferApplyResponse { # [staticmethod] fn from_inner (inner : InternalTransferApplyResponse) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn transfer_client_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . transfer_client_id . clone () . into ()) } } # [pymethods] impl RestClient { fn internal_transfer_apply <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . internal_transfer_apply () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetBalancesRequest { inner : venues :: GetBalancesRequest , } # [pymethods] impl GetBalancesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetBalancesResponse { inner : venues :: GetBalancesResponse , } # [pymethods] impl GetBalancesResponse { # [staticmethod] fn from_inner (inner : GetBalancesResponse) -> Self { Self { inner } } # [getter] fn balances (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . balances . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct Balance { inner : venues :: Balance , } # [pymethods] impl Balance { # [staticmethod] fn from_inner (inner : Balance) -> Self { Self { inner } } # [getter] fn asset (& self) -> PyResult < String > { Ok (self . inner . asset . clone () . into ()) } # [getter] fn display_name (& self) -> PyResult < String > { Ok (self . inner . display_name . clone () . into ()) } # [getter] fn free (& self) -> PyResult < String > { Ok (self . inner . free . clone () . into ()) } # [getter] fn locked (& self) -> PyResult < String > { Ok (self . inner . locked . clone () . into ()) } } # [pymethods] impl RestClient { fn get_balances <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_balances () . await }) } } # [pyclass] # [derive (Clone)] pub struct AssetTransferRequest { inner : venues :: AssetTransferRequest , } # [pymethods] impl AssetTransferRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn transfer_type (& self) -> PyResult < PyObject > { Ok (self . inner . transfer_type . clone () . into ()) } # [getter] fn asset (& self) -> PyResult < String > { Ok (self . inner . asset . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AssetTransferResponse { inner : venues :: AssetTransferResponse , } # [pymethods] impl AssetTransferResponse { # [staticmethod] fn from_inner (inner : AssetTransferResponse) -> Self { Self { inner } } # [getter] fn tran_id (& self) -> PyResult < i64 > { Ok (self . inner . tran_id . clone () . into ()) } } # [pymethods] impl RestClient { fn asset_transfer <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . asset_transfer () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } # [getter] fn base_url (& self) -> PyResult < PyObject > { Ok (self . inner . base_url . clone () . into ()) } # [getter] fn client (& self) -> PyResult < PyObject > { Ok (self . inner . client . clone () . into ()) } # [getter] fn rate_limiter (& self) -> PyResult < PyObject > { Ok (self . inner . rate_limiter . clone () . into ()) } } # [pymethods] impl RestClient { fn sign_request (& self) -> PyResult < () > { self . inner . sign_request () ; Ok (()) } fn send_request <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_request () . await }) } fn send_signed_request <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . send_signed_request () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOcoOrderRequest { inner : venues :: GetOcoOrderRequest , } # [pymethods] impl GetOcoOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn order_list_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_list_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOcoOrderResponse { inner : venues :: GetOcoOrderResponse , } # [pymethods] impl GetOcoOrderResponse { # [staticmethod] fn from_inner (inner : GetOcoOrderResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OcoOrderInfo { inner : venues :: OcoOrderInfo , } # [pymethods] impl OcoOrderInfo { # [staticmethod] fn from_inner (inner : OcoOrderInfo) -> Self { Self { inner } } # [getter] fn transaction_time (& self) -> PyResult < i64 > { Ok (self . inner . transaction_time . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn trigger_price (& self) -> PyResult < f64 > { Ok (self . inner . trigger_price . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < f64 > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn order_list_id (& self) -> PyResult < String > { Ok (self . inner . order_list_id . clone () . into ()) } } # [pymethods] impl RestClient { fn get_oco_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_oco_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct QueryOrderRequest { inner : venues :: QueryOrderRequest , } # [pymethods] impl QueryOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderDetails { inner : venues :: OrderDetails , } # [pymethods] impl OrderDetails { # [staticmethod] fn from_inner (inner : OrderDetails) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < i64 > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn orig_qty (& self) -> PyResult < String > { Ok (self . inner . orig_qty . clone () . into ()) } # [getter] fn executed_qty (& self) -> PyResult < String > { Ok (self . inner . executed_qty . clone () . into ()) } # [getter] fn cummulative_quote_qty (& self) -> PyResult < String > { Ok (self . inner . cummulative_quote_qty . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn time (& self) -> PyResult < i64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < i64 > { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn orig_quote_order_qty (& self) -> PyResult < String > { Ok (self . inner . orig_quote_order_qty . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < String > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn fee_asset (& self) -> PyResult < String > { Ok (self . inner . fee_asset . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_price . clone () . into ()) } # [getter] fn avg_price (& self) -> PyResult < String > { Ok (self . inner . avg_price . clone () . into ()) } } # [pymethods] impl RestClient { fn query_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . query_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelAllOrdersRequest { inner : venues :: CancelAllOrdersRequest , } # [pymethods] impl CancelAllOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelAllOrdersResponse { inner : venues :: CancelAllOrdersResponse , } # [pymethods] impl CancelAllOrdersResponse { # [staticmethod] fn from_inner (inner : CancelAllOrdersResponse) -> Self { Self { inner } } # [getter] fn orders (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . orders . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CanceledOrderInfo { inner : venues :: CanceledOrderInfo , } # [pymethods] impl CanceledOrderInfo { # [staticmethod] fn from_inner (inner : CanceledOrderInfo) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < i64 > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn orig_qty (& self) -> PyResult < String > { Ok (self . inner . orig_qty . clone () . into ()) } # [getter] fn executed_qty (& self) -> PyResult < String > { Ok (self . inner . executed_qty . clone () . into ()) } # [getter] fn cummulative_quote_qty (& self) -> PyResult < String > { Ok (self . inner . cummulative_quote_qty . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < String > { Ok (self . inner . stop_price . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_all_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct WithdrawRequest { inner : venues :: WithdrawRequest , } # [pymethods] impl WithdrawRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn coin (& self) -> PyResult < String > { Ok (self . inner . coin . clone () . into ()) } # [getter] fn network (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . network . clone () . into ()) } # [getter] fn address (& self) -> PyResult < String > { Ok (self . inner . address . clone () . into ()) } # [getter] fn address_tag (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . address_tag . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < f64 > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn wallet_type (& self) -> PyResult < PyObject > { Ok (self . inner . wallet_type . clone () . into ()) } # [getter] fn withdraw_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . withdraw_order_id . clone () . into ()) } # [getter] fn vasp_entity_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . vasp_entity_id . clone () . into ()) } # [getter] fn recipient_last_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recipient_last_name . clone () . into ()) } # [getter] fn recipient_first_name (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recipient_first_name . clone () . into ()) } # [getter] fn date_of_birth (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . date_of_birth . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct WithdrawResponse { inner : venues :: WithdrawResponse , } # [pymethods] impl WithdrawResponse { # [staticmethod] fn from_inner (inner : WithdrawResponse) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn withdraw_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . withdraw_order_id . clone () . into ()) } } # [pymethods] impl RestClient { fn withdraw <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . withdraw () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelOcoOrderRequest { inner : venues :: CancelOcoOrderRequest , } # [pymethods] impl CancelOcoOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelOcoOrderResponse { inner : venues :: CancelOcoOrderResponse , } # [pymethods] impl CancelOcoOrderResponse { # [staticmethod] fn from_inner (inner : CancelOcoOrderResponse) -> Self { Self { inner } } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_oco_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_oco_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct PlaceMultipleOrdersRequest { inner : venues :: PlaceMultipleOrdersRequest , } # [pymethods] impl PlaceMultipleOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } # [getter] fn sync (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sync . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderData { inner : venues :: OrderData , } # [pymethods] impl OrderData { # [staticmethod] fn from_inner (inner : OrderData) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn quote_order_qty (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_order_qty . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn new_client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . new_client_order_id . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . time_in_force . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct PlaceMultipleOrdersResponse { inner : venues :: PlaceMultipleOrdersResponse , } # [pymethods] impl PlaceMultipleOrdersResponse { # [staticmethod] fn from_inner (inner : PlaceMultipleOrdersResponse) -> Self { Self { inner } } # [getter] fn orders (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . orders . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BatchOrderResponse { inner : venues :: BatchOrderResponse , } # [pymethods] impl BatchOrderResponse { # [staticmethod] fn from_inner (inner : BatchOrderResponse) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < i64 > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn transact_time (& self) -> PyResult < i64 > { Ok (self . inner . transact_time . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn orig_qty (& self) -> PyResult < String > { Ok (self . inner . orig_qty . clone () . into ()) } # [getter] fn executed_qty (& self) -> PyResult < String > { Ok (self . inner . executed_qty . clone () . into ()) } # [getter] fn cummulative_quote_qty (& self) -> PyResult < String > { Ok (self . inner . cummulative_quote_qty . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } } # [pymethods] impl RestClient { fn place_multiple_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . place_multiple_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetAssetTransferRecordsRequest { inner : venues :: GetAssetTransferRecordsRequest , } # [pymethods] impl GetAssetTransferRecordsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn transfer_type (& self) -> PyResult < PyObject > { Ok (self . inner . transfer_type . clone () . into ()) } # [getter] fn tran_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . tran_id . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn current (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . current . clone () . into ()) } # [getter] fn size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . size . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetAssetTransferRecordsResponse { inner : venues :: GetAssetTransferRecordsResponse , } # [pymethods] impl GetAssetTransferRecordsResponse { # [staticmethod] fn from_inner (inner : GetAssetTransferRecordsResponse) -> Self { Self { inner } } # [getter] fn total (& self) -> PyResult < i64 > { Ok (self . inner . total . clone () . into ()) } # [getter] fn rows (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . rows . clone () . into ()) } } # [pymethods] impl RestClient { fn get_asset_transfer_records <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_asset_transfer_records () . await }) } } # [pyclass] # [derive (Clone)] pub struct InternalTransferRecordsRequest { inner : venues :: InternalTransferRecordsRequest , } # [pymethods] impl InternalTransferRecordsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn transfer_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . transfer_id . clone () . into ()) } # [getter] fn asset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . asset . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . size . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct InternalTransferRecordsResponse { inner : venues :: InternalTransferRecordsResponse , } # [pymethods] impl InternalTransferRecordsResponse { # [staticmethod] fn from_inner (inner : InternalTransferRecordsResponse) -> Self { Self { inner } } # [getter] fn success (& self) -> PyResult < bool > { Ok (self . inner . success . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct InternalTransferRecordsData { inner : venues :: InternalTransferRecordsData , } # [pymethods] impl InternalTransferRecordsData { # [staticmethod] fn from_inner (inner : InternalTransferRecordsData) -> Self { Self { inner } } # [getter] fn records (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . records . clone () . into ()) } # [getter] fn total_count (& self) -> PyResult < i64 > { Ok (self . inner . total_count . clone () . into ()) } # [getter] fn page (& self) -> PyResult < i64 > { Ok (self . inner . page . clone () . into ()) } # [getter] fn size (& self) -> PyResult < i64 > { Ok (self . inner . size . clone () . into ()) } } # [pymethods] impl RestClient { fn get_internal_transfer_records <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_internal_transfer_records () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeleteSubAccountApiKeyRequest { inner : venues :: DeleteSubAccountApiKeyRequest , } # [pymethods] impl DeleteSubAccountApiKeyRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn sub_uid (& self) -> PyResult < i64 > { Ok (self . inner . sub_uid . clone () . into ()) } # [getter] fn api_key (& self) -> PyResult < String > { Ok (self . inner . api_key . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeleteSubAccountApiKeyResponse { inner : venues :: DeleteSubAccountApiKeyResponse , } # [pymethods] impl DeleteSubAccountApiKeyResponse { # [staticmethod] fn from_inner (inner : DeleteSubAccountApiKeyResponse) -> Self { Self { inner } } # [getter] fn success (& self) -> PyResult < bool > { Ok (self . inner . success . clone () . into ()) } } # [pymethods] impl RestClient { fn delete_sub_account_api_key <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . delete_sub_account_api_key () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetDepositRecordsRequest { inner : venues :: GetDepositRecordsRequest , } # [pymethods] impl GetDepositRecordsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn coin (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . coin . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetDepositRecordsResponse { inner : venues :: GetDepositRecordsResponse , } # [pymethods] impl GetDepositRecordsResponse { # [staticmethod] fn from_inner (inner : GetDepositRecordsResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_deposit_records <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_deposit_records () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateSubAccountRequest { inner : venues :: CreateSubAccountRequest , } # [pymethods] impl CreateSubAccountRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn sub_account_string (& self) -> PyResult < String > { Ok (self . inner . sub_account_string . clone () . into ()) } # [getter] fn note (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . note . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < i64 > { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateSubAccountResponse { inner : venues :: CreateSubAccountResponse , } # [pymethods] impl CreateSubAccountResponse { # [staticmethod] fn from_inner (inner : CreateSubAccountResponse) -> Self { Self { inner } } # [getter] fn sub_uid (& self) -> PyResult < i64 > { Ok (self . inner . sub_uid . clone () . into ()) } # [getter] fn sub_account_string (& self) -> PyResult < String > { Ok (self . inner . sub_account_string . clone () . into ()) } # [getter] fn note (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . note . clone () . into ()) } } # [pymethods] impl RestClient { fn create_sub_account <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_sub_account () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetFundBalanceRequest { inner : venues :: GetFundBalanceRequest , } # [pymethods] impl GetFundBalanceRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetFundBalanceResponse { inner : venues :: GetFundBalanceResponse , } # [pymethods] impl GetFundBalanceResponse { # [staticmethod] fn from_inner (inner : GetFundBalanceResponse) -> Self { Self { inner } } # [getter] fn balances (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . balances . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FundBalance { inner : venues :: FundBalance , } # [pymethods] impl FundBalance { # [staticmethod] fn from_inner (inner : FundBalance) -> Self { Self { inner } } # [getter] fn asset (& self) -> PyResult < String > { Ok (self . inner . asset . clone () . into ()) } # [getter] fn display_name (& self) -> PyResult < String > { Ok (self . inner . display_name . clone () . into ()) } # [getter] fn free (& self) -> PyResult < String > { Ok (self . inner . free . clone () . into ()) } # [getter] fn locked (& self) -> PyResult < String > { Ok (self . inner . locked . clone () . into ()) } } # [pymethods] impl RestClient { fn get_fund_balance <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_fund_balance () . await }) } } # [pyclass] # [derive (Clone)] pub enum CancelRestrictions { New , Pending , PartiallyFilled , } # [pyclass] # [derive (Clone)] pub struct CancelOrderRequest { inner : venues :: CancelOrderRequest , } # [pymethods] impl CancelOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn cancel_restrictions (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cancel_restrictions . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelOrderResponse { inner : venues :: CancelOrderResponse , } # [pymethods] impl CancelOrderResponse { # [staticmethod] fn from_inner (inner : CancelOrderResponse) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < i64 > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn orig_qty (& self) -> PyResult < String > { Ok (self . inner . orig_qty . clone () . into ()) } # [getter] fn executed_qty (& self) -> PyResult < String > { Ok (self . inner . executed_qty . clone () . into ()) } # [getter] fn cummulative_quote_qty (& self) -> PyResult < String > { Ok (self . inner . cummulative_quote_qty . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_price . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct AssetTransferRequest { inner : venues :: AssetTransferRequest , } # [pymethods] impl AssetTransferRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn from_account (& self) -> PyResult < String > { Ok (self . inner . from_account . clone () . into ()) } # [getter] fn to_account (& self) -> PyResult < String > { Ok (self . inner . to_account . clone () . into ()) } # [getter] fn asset (& self) -> PyResult < String > { Ok (self . inner . asset . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AssetTransferResponse { inner : venues :: AssetTransferResponse , } # [pymethods] impl AssetTransferResponse { # [staticmethod] fn from_inner (inner : AssetTransferResponse) -> Self { Self { inner } } # [getter] fn transfer_id (& self) -> PyResult < String > { Ok (self . inner . transfer_id . clone () . into ()) } } # [pymethods] impl RestClient { fn asset_transfer <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . asset_transfer () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelReplaceOrderRequest { inner : venues :: CancelReplaceOrderRequest , } # [pymethods] impl CancelReplaceOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn cancel_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cancel_order_id . clone () . into ()) } # [getter] fn cancel_client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cancel_client_order_id . clone () . into ()) } # [getter] fn cancel_restrictions (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cancel_restrictions . clone () . into ()) } # [getter] fn cancel_replace_mode (& self) -> PyResult < PyObject > { Ok (self . inner . cancel_replace_mode . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn quote_order_qty (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_order_qty . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn new_client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . new_client_order_id . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelReplaceOrderResponse { inner : venues :: CancelReplaceOrderResponse , } # [pymethods] impl CancelReplaceOrderResponse { # [staticmethod] fn from_inner (inner : CancelReplaceOrderResponse) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < i64 > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn orig_qty (& self) -> PyResult < String > { Ok (self . inner . orig_qty . clone () . into ()) } # [getter] fn executed_qty (& self) -> PyResult < String > { Ok (self . inner . executed_qty . clone () . into ()) } # [getter] fn cummulative_quote_qty (& self) -> PyResult < String > { Ok (self . inner . cummulative_quote_qty . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < String > { Ok (self . inner . stop_price . clone () . into ()) } # [getter] fn cancel_restrictions (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cancel_restrictions . clone () . into ()) } # [getter] fn transact_time (& self) -> PyResult < i64 > { Ok (self . inner . transact_time . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_replace_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_replace_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct SubAccountTransferRequest { inner : venues :: SubAccountTransferRequest , } # [pymethods] impl SubAccountTransferRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn from_email (& self) -> PyResult < String > { Ok (self . inner . from_email . clone () . into ()) } # [getter] fn to_email (& self) -> PyResult < String > { Ok (self . inner . to_email . clone () . into ()) } # [getter] fn asset (& self) -> PyResult < String > { Ok (self . inner . asset . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn r#type (& self) -> PyResult < PyObject > { Ok (self . inner . r#type . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SubAccountTransferResponse { inner : venues :: SubAccountTransferResponse , } # [pymethods] impl SubAccountTransferResponse { # [staticmethod] fn from_inner (inner : SubAccountTransferResponse) -> Self { Self { inner } } # [getter] fn txn_id (& self) -> PyResult < String > { Ok (self . inner . txn_id . clone () . into ()) } # [getter] fn success (& self) -> PyResult < bool > { Ok (self . inner . success . clone () . into ()) } } # [pymethods] impl RestClient { fn sub_account_transfer <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . sub_account_transfer () . await }) } } # [pyclass] # [derive (Clone)] pub enum OrderType { Market , Limit , TakeStopLimit , TakeStopMarket , TriggerLimit , TriggerMarket , } # [pyclass] # [derive (Clone)] pub enum OrderSide { Buy , Sell , } # [pyclass] # [derive (Clone)] pub enum TimeInForce { PostOnly , Gtc , Ioc , Fok , } # [pyclass] # [derive (Clone)] pub enum OrderStatus { New , Pending , PartiallyFilled , Filled , Canceled , Failed , } # [pyclass] # [derive (Clone)] pub struct PlaceOrderRequest { inner : venues :: PlaceOrderRequest , } # [pymethods] impl PlaceOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn quote_order_qty (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . quote_order_qty . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn new_client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . new_client_order_id . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct PlaceOrderResponse { inner : venues :: PlaceOrderResponse , } # [pymethods] impl PlaceOrderResponse { # [staticmethod] fn from_inner (inner : PlaceOrderResponse) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < i64 > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn transact_time (& self) -> PyResult < i64 > { Ok (self . inner . transact_time . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn orig_qty (& self) -> PyResult < String > { Ok (self . inner . orig_qty . clone () . into ()) } # [getter] fn executed_qty (& self) -> PyResult < String > { Ok (self . inner . executed_qty . clone () . into ()) } # [getter] fn cummulative_quote_qty (& self) -> PyResult < String > { Ok (self . inner . cummulative_quote_qty . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . client_order_id . clone () . into ()) } } # [pymethods] impl RestClient { fn place_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . place_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct EditSubAccountApiKeyRequest { inner : venues :: EditSubAccountApiKeyRequest , } # [pymethods] impl EditSubAccountApiKeyRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn sub_uid (& self) -> PyResult < i64 > { Ok (self . inner . sub_uid . clone () . into ()) } # [getter] fn api_key (& self) -> PyResult < String > { Ok (self . inner . api_key . clone () . into ()) } # [getter] fn note (& self) -> PyResult < String > { Ok (self . inner . note . clone () . into ()) } # [getter] fn permissions (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . permissions . clone () . into ()) } # [getter] fn ip_addresses (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . ip_addresses . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct EditSubAccountApiKeyResponse { inner : venues :: EditSubAccountApiKeyResponse , } # [pymethods] impl EditSubAccountApiKeyResponse { # [staticmethod] fn from_inner (inner : EditSubAccountApiKeyResponse) -> Self { Self { inner } } # [getter] fn permissions (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . permissions . clone () . into ()) } # [getter] fn ip_addresses (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . ip_addresses . clone () . into ()) } # [getter] fn note (& self) -> PyResult < String > { Ok (self . inner . note . clone () . into ()) } } # [pymethods] impl RestClient { fn edit_sub_account_api_key <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . edit_sub_account_api_key () . await }) } } # [pyclass] # [derive (Clone)] pub struct AuthorizeSubAccountTransferRequest { inner : venues :: AuthorizeSubAccountTransferRequest , } # [pymethods] impl AuthorizeSubAccountTransferRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn sub_uid (& self) -> PyResult < String > { Ok (self . inner . sub_uid . clone () . into ()) } # [getter] fn can_transfer (& self) -> PyResult < bool > { Ok (self . inner . can_transfer . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AuthorizeSubAccountTransferResponse { inner : venues :: AuthorizeSubAccountTransferResponse , } # [pymethods] impl AuthorizeSubAccountTransferResponse { # [staticmethod] fn from_inner (inner : AuthorizeSubAccountTransferResponse) -> Self { Self { inner } } # [getter] fn success (& self) -> PyResult < bool > { Ok (self . inner . success . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SubAccountTransferAuth { inner : venues :: SubAccountTransferAuth , } # [pymethods] impl SubAccountTransferAuth { # [staticmethod] fn from_inner (inner : SubAccountTransferAuth) -> Self { Self { inner } } # [getter] fn sub_uid (& self) -> PyResult < String > { Ok (self . inner . sub_uid . clone () . into ()) } # [getter] fn can_transfer (& self) -> PyResult < bool > { Ok (self . inner . can_transfer . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < i64 > { Ok (self . inner . update_time . clone () . into ()) } } # [pymethods] impl RestClient { fn authorize_sub_account_transfer <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . authorize_sub_account_transfer () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetCommissionRateRequest { inner : venues :: GetCommissionRateRequest , } # [pymethods] impl GetCommissionRateRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetCommissionRateResponse { inner : venues :: GetCommissionRateResponse , } # [pymethods] impl GetCommissionRateResponse { # [staticmethod] fn from_inner (inner : GetCommissionRateResponse) -> Self { Self { inner } } # [getter] fn taker_commission_rate (& self) -> PyResult < f64 > { Ok (self . inner . taker_commission_rate . clone () . into ()) } # [getter] fn maker_commission_rate (& self) -> PyResult < f64 > { Ok (self . inner . maker_commission_rate . clone () . into ()) } } # [pymethods] impl RestClient { fn get_commission_rate <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_commission_rate () . await }) } } # [pyclass] # [derive (Clone)] pub struct QueryTransferableCoinsRequest { inner : venues :: QueryTransferableCoinsRequest , } # [pymethods] impl QueryTransferableCoinsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn from_account (& self) -> PyResult < String > { Ok (self . inner . from_account . clone () . into ()) } # [getter] fn to_account (& self) -> PyResult < String > { Ok (self . inner . to_account . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct QueryTransferableCoinsResponse { inner : venues :: QueryTransferableCoinsResponse , } # [pymethods] impl QueryTransferableCoinsResponse { # [staticmethod] fn from_inner (inner : QueryTransferableCoinsResponse) -> Self { Self { inner } } # [getter] fn coins (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . coins . clone () . into ()) } } # [pymethods] impl RestClient { fn query_transferable_coins <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . query_transferable_coins () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetSubAccountTransferHistoryRequest { inner : venues :: GetSubAccountTransferHistoryRequest , } # [pymethods] impl GetSubAccountTransferHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn asset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . asset . clone () . into ()) } # [getter] fn r#type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . r#type . clone () . into ()) } # [getter] fn start_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . start_time . clone () . into ()) } # [getter] fn end_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . end_time . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetSubAccountTransferHistoryResponse { inner : venues :: GetSubAccountTransferHistoryResponse , } # [pymethods] impl GetSubAccountTransferHistoryResponse { # [staticmethod] fn from_inner (inner : GetSubAccountTransferHistoryResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SubAccountTransferRecord { inner : venues :: SubAccountTransferRecord , } # [pymethods] impl SubAccountTransferRecord { # [staticmethod] fn from_inner (inner : SubAccountTransferRecord) -> Self { Self { inner } } # [getter] fn from (& self) -> PyResult < String > { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < String > { Ok (self . inner . to . clone () . into ()) } # [getter] fn asset (& self) -> PyResult < String > { Ok (self . inner . asset . clone () . into ()) } # [getter] fn qty (& self) -> PyResult < String > { Ok (self . inner . qty . clone () . into ()) } # [getter] fn r#type (& self) -> PyResult < String > { Ok (self . inner . r#type . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn tran_id (& self) -> PyResult < i64 > { Ok (self . inner . tran_id . clone () . into ()) } # [getter] fn time (& self) -> PyResult < i64 > { Ok (self . inner . time . clone () . into ()) } } # [pymethods] impl RestClient { fn get_sub_account_transfer_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_sub_account_transfer_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct Order { inner : venues :: Order , } # [pymethods] impl Order { # [staticmethod] fn from_inner (inner : Order) -> Self { Self { inner } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < i64 > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn orig_qty (& self) -> PyResult < String > { Ok (self . inner . orig_qty . clone () . into ()) } # [getter] fn executed_qty (& self) -> PyResult < String > { Ok (self . inner . executed_qty . clone () . into ()) } # [getter] fn cummulative_quote_qty (& self) -> PyResult < String > { Ok (self . inner . cummulative_quote_qty . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn time (& self) -> PyResult < i64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < i64 > { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn orig_quote_order_qty (& self) -> PyResult < String > { Ok (self . inner . orig_quote_order_qty . clone () . into ()) } # [getter] fn stop_price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stop_price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOpenOrdersRequest { inner : venues :: GetOpenOrdersRequest , } # [pymethods] impl GetOpenOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetOpenOrdersResponse { inner : venues :: GetOpenOrdersResponse , } # [pymethods] impl GetOpenOrdersResponse { # [staticmethod] fn from_inner (inner : GetOpenOrdersResponse) -> Self { Self { inner } } # [getter] fn orders (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . orders . clone () . into ()) } } # [pymethods] impl RestClient { fn get_open_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_open_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelAllAfterRequest { inner : venues :: CancelAllAfterRequest , } # [pymethods] impl CancelAllAfterRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn request_type (& self) -> PyResult < PyObject > { Ok (self . inner . request_type . clone () . into ()) } # [getter] fn timeout (& self) -> PyResult < u64 > { Ok (self . inner . timeout . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < u64 > { Ok (self . inner . timestamp . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelAllAfterResponse { inner : venues :: CancelAllAfterResponse , } # [pymethods] impl CancelAllAfterResponse { # [staticmethod] fn from_inner (inner : CancelAllAfterResponse) -> Self { Self { inner } } # [getter] fn trigger_time (& self) -> PyResult < i64 > { Ok (self . inner . trigger_time . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn note (& self) -> PyResult < String > { Ok (self . inner . note . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_all_after <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_after () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetSubAccountAssetsRequest { inner : venues :: GetSubAccountAssetsRequest , } # [pymethods] impl GetSubAccountAssetsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn email (& self) -> PyResult < String > { Ok (self . inner . email . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetSubAccountAssetsResponse { inner : venues :: GetSubAccountAssetsResponse , } # [pymethods] impl GetSubAccountAssetsResponse { # [staticmethod] fn from_inner (inner : GetSubAccountAssetsResponse) -> Self { Self { inner } } # [getter] fn balances (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . balances . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SubAccountAsset { inner : venues :: SubAccountAsset , } # [pymethods] impl SubAccountAsset { # [staticmethod] fn from_inner (inner : SubAccountAsset) -> Self { Self { inner } } # [getter] fn asset (& self) -> PyResult < String > { Ok (self . inner . asset . clone () . into ()) } # [getter] fn free (& self) -> PyResult < String > { Ok (self . inner . free . clone () . into ()) } # [getter] fn locked (& self) -> PyResult < String > { Ok (self . inner . locked . clone () . into ()) } } # [pymethods] impl RestClient { fn get_sub_account_assets <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_sub_account_assets () . await }) } } # [pyclass] # [derive (Clone)] pub struct BatchSubAccountAssetsRequest { inner : venues :: BatchSubAccountAssetsRequest , } # [pymethods] impl BatchSubAccountAssetsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn sub_uid_list (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sub_uid_list . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . size . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SubAccountAssetSummary { inner : venues :: SubAccountAssetSummary , } # [pymethods] impl SubAccountAssetSummary { # [staticmethod] fn from_inner (inner : SubAccountAssetSummary) -> Self { Self { inner } } # [getter] fn sub_uid (& self) -> PyResult < String > { Ok (self . inner . sub_uid . clone () . into ()) } # [getter] fn email (& self) -> PyResult < String > { Ok (self . inner . email . clone () . into ()) } # [getter] fn total_balance_usdt (& self) -> PyResult < String > { Ok (self . inner . total_balance_usdt . clone () . into ()) } # [getter] fn spot_balance_usdt (& self) -> PyResult < String > { Ok (self . inner . spot_balance_usdt . clone () . into ()) } # [getter] fn futures_balance_usdt (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . futures_balance_usdt . clone () . into ()) } # [getter] fn margin_balance_usdt (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . margin_balance_usdt . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < i64 > { Ok (self . inner . update_time . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BatchSubAccountAssetsResponse { inner : venues :: BatchSubAccountAssetsResponse , } # [pymethods] impl BatchSubAccountAssetsResponse { # [staticmethod] fn from_inner (inner : BatchSubAccountAssetsResponse) -> Self { Self { inner } } # [getter] fn success (& self) -> PyResult < bool > { Ok (self . inner . success . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BatchSubAccountAssetsData { inner : venues :: BatchSubAccountAssetsData , } # [pymethods] impl BatchSubAccountAssetsData { # [staticmethod] fn from_inner (inner : BatchSubAccountAssetsData) -> Self { Self { inner } } # [getter] fn sub_accounts (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . sub_accounts . clone () . into ()) } # [getter] fn total_count (& self) -> PyResult < i64 > { Ok (self . inner . total_count . clone () . into ()) } # [getter] fn page (& self) -> PyResult < i64 > { Ok (self . inner . page . clone () . into ()) } # [getter] fn size (& self) -> PyResult < i64 > { Ok (self . inner . size . clone () . into ()) } } # [pymethods] impl RestClient { fn batch_sub_account_assets <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . batch_sub_account_assets () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetUidRequest { inner : venues :: GetUidRequest , } # [pymethods] impl GetUidRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetUidResponse { inner : venues :: GetUidResponse , } # [pymethods] impl GetUidResponse { # [staticmethod] fn from_inner (inner : GetUidResponse) -> Self { Self { inner } } # [getter] fn uid (& self) -> PyResult < String > { Ok (self . inner . uid . clone () . into ()) } } # [pymethods] impl RestClient { fn get_uid <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_uid () . await }) } } # [pyclass] # [derive (Clone)] pub enum OcoOrderType { OcoLimit , OcoTps , } # [pyclass] # [derive (Clone)] pub struct CreateOcoOrderRequest { inner : venues :: CreateOcoOrderRequest , } # [pymethods] impl CreateOcoOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < String > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn limit_price (& self) -> PyResult < String > { Ok (self . inner . limit_price . clone () . into ()) } # [getter] fn order_price (& self) -> PyResult < String > { Ok (self . inner . order_price . clone () . into ()) } # [getter] fn trigger_price (& self) -> PyResult < String > { Ok (self . inner . trigger_price . clone () . into ()) } # [getter] fn list_client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . list_client_order_id . clone () . into ()) } # [getter] fn above_client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . above_client_order_id . clone () . into ()) } # [getter] fn below_client_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . below_client_order_id . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateOcoOrderResponse { inner : venues :: CreateOcoOrderResponse , } # [pymethods] impl CreateOcoOrderResponse { # [staticmethod] fn from_inner (inner : CreateOcoOrderResponse) -> Self { Self { inner } } # [getter] fn orders (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . orders . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OcoOrderInfo { inner : venues :: OcoOrderInfo , } # [pymethods] impl OcoOrderInfo { # [staticmethod] fn from_inner (inner : OcoOrderInfo) -> Self { Self { inner } } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn client_order_id (& self) -> PyResult < String > { Ok (self . inner . client_order_id . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn symbol (& self) -> PyResult < String > { Ok (self . inner . symbol . clone () . into ()) } # [getter] fn price (& self) -> PyResult < f64 > { Ok (self . inner . price . clone () . into ()) } # [getter] fn trigger_price (& self) -> PyResult < f64 > { Ok (self . inner . trigger_price . clone () . into ()) } # [getter] fn quantity (& self) -> PyResult < f64 > { Ok (self . inner . quantity . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } } # [pymethods] impl RestClient { fn create_oco_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_oco_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateSubAccountApiKeyRequest { inner : venues :: CreateSubAccountApiKeyRequest , } # [pymethods] impl CreateSubAccountApiKeyRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn sub_uid (& self) -> PyResult < i64 > { Ok (self . inner . sub_uid . clone () . into ()) } # [getter] fn note (& self) -> PyResult < String > { Ok (self . inner . note . clone () . into ()) } # [getter] fn permissions (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . permissions . clone () . into ()) } # [getter] fn ip_addresses (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . ip_addresses . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateSubAccountApiKeyResponse { inner : venues :: CreateSubAccountApiKeyResponse , } # [pymethods] impl CreateSubAccountApiKeyResponse { # [staticmethod] fn from_inner (inner : CreateSubAccountApiKeyResponse) -> Self { Self { inner } } # [getter] fn api_key (& self) -> PyResult < String > { Ok (self . inner . api_key . clone () . into ()) } # [getter] fn api_secret (& self) -> PyResult < String > { Ok (self . inner . api_secret . clone () . into ()) } # [getter] fn permissions (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . permissions . clone () . into ()) } # [getter] fn ip_addresses (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . ip_addresses . clone () . into ()) } # [getter] fn note (& self) -> PyResult < String > { Ok (self . inner . note . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct QueryApiKeyRequest { inner : venues :: QueryApiKeyRequest , } # [pymethods] impl QueryApiKeyRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn uid (& self) -> PyResult < i64 > { Ok (self . inner . uid . clone () . into ()) } # [getter] fn api_key (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . api_key . clone () . into ()) } # [getter] fn recv_window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . recv_window . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ApiKeyInfo { inner : venues :: ApiKeyInfo , } # [pymethods] impl ApiKeyInfo { # [staticmethod] fn from_inner (inner : ApiKeyInfo) -> Self { Self { inner } } # [getter] fn api_key (& self) -> PyResult < String > { Ok (self . inner . api_key . clone () . into ()) } # [getter] fn note (& self) -> PyResult < String > { Ok (self . inner . note . clone () . into ()) } # [getter] fn permissions (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . permissions . clone () . into ()) } # [getter] fn ip_addresses (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . ip_addresses . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < i64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < i64 > { Ok (self . inner . update_time . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct QueryApiKeyResponse { inner : venues :: QueryApiKeyResponse , } # [pymethods] impl QueryApiKeyResponse { # [staticmethod] fn from_inner (inner : QueryApiKeyResponse) -> Self { Self { inner } } # [getter] fn data (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn create_sub_account_api_key <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_sub_account_api_key () . await }) } fn query_api_key <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . query_api_key () . await }) } } # [pyclass] # [derive (Clone)] pub struct ErrorResponse { inner : venues :: ErrorResponse , } # [pymethods] impl ErrorResponse { # [staticmethod] fn from_inner (inner : ErrorResponse) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < i64 > { Ok (self . inner . code . clone () . into ()) } # [getter] fn msg (& self) -> PyResult < String > { Ok (self . inner . msg . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ApiResponse { inner : venues :: ApiResponse , } # [pymethods] impl ApiResponse { # [staticmethod] fn from_inner (inner : ApiResponse) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < i64 > { Ok (self . inner . code . clone () . into ()) } # [getter] fn msg (& self) -> PyResult < String > { Ok (self . inner . msg . clone () . into ()) } # [getter] fn debug_msg (& self) -> PyResult < String > { Ok (self . inner . debug_msg . clone () . into ()) } # [getter] fn retryable (& self) -> PyResult < i64 > { Ok (self . inner . retryable . clone () . into ()) } # [getter] fn data (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . data . clone () . into ()) } # [getter] fn timestamp (& self) -> PyResult < i64 > { Ok (self . inner . timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub enum EndpointType { Account , Trading , General , PublicMarket , AccountApiGroup2 , AccountApiGroup3 , } # [pyclass] # [derive (Clone)] pub struct RateLimit { inner : venues :: RateLimit , } # [pymethods] impl RateLimit { # [staticmethod] fn from_inner (inner : RateLimit) -> Self { Self { inner } } # [getter] fn max_requests (& self) -> PyResult < u64 > { Ok (self . inner . max_requests . clone () . into ()) } # [getter] fn window (& self) -> PyResult < PyObject > { Ok (self . inner . window . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RateLimiter { inner : venues :: RateLimiter , } # [pymethods] impl RateLimiter { # [staticmethod] fn from_inner (inner : RateLimiter) -> Self { Self { inner } } } # [doc = " Create the Python module for bingx"] pub fn create_module (py : Python) -> PyResult <& PyModule > { let m = PyModule :: new (py , "bingx") ?; Ok (m) }