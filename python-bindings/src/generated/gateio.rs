# ! [doc = " Python bindings for gateio venue"] # ! [doc = ""] # ! [doc = " This module is automatically generated from the Rust source code."] # ! [doc = " Do not edit this file directly."] use pyo3 :: prelude ::*; use pyo3_asyncio ; use venues ; # [pyclass] # [derive (Clone)] pub struct RestResponse { inner : venues :: RestResponse , } # [pymethods] impl RestResponse { # [staticmethod] fn from_inner (inner : RestResponse) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < String > { Ok (self . inner . code . clone () . into ()) } # [getter] fn data (& self) -> PyResult < PyObject > { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FuturesPremiumIndexRequest { inner : venues :: FuturesPremiumIndexRequest , } # [pymethods] impl FuturesPremiumIndexRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . interval . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_premium_index <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_premium_index () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn base_url (& self) -> PyResult < () > { self . inner . base_url () ; Ok (()) } fn get <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get () . await }) } fn get_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_with_query () . await }) } } # [pyclass] # [derive (Clone)] pub struct FuturesInsuranceRequest { inner : venues :: FuturesInsuranceRequest , } # [pymethods] impl FuturesInsuranceRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_insurance <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_insurance () . await }) } } # [pyclass] # [derive (Clone)] pub struct FuturesTickersRequest { inner : venues :: FuturesTickersRequest , } # [pymethods] impl FuturesTickersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FuturesTicker { inner : venues :: FuturesTicker , } # [pymethods] impl FuturesTicker { # [staticmethod] fn from_inner (inner : FuturesTicker) -> Self { Self { inner } } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn last (& self) -> PyResult < String > { Ok (self . inner . last . clone () . into ()) } # [getter] fn lowest_ask (& self) -> PyResult < String > { Ok (self . inner . lowest_ask . clone () . into ()) } # [getter] fn highest_bid (& self) -> PyResult < String > { Ok (self . inner . highest_bid . clone () . into ()) } # [getter] fn change_percentage (& self) -> PyResult < String > { Ok (self . inner . change_percentage . clone () . into ()) } # [getter] fn change_utc0 (& self) -> PyResult < String > { Ok (self . inner . change_utc0 . clone () . into ()) } # [getter] fn change_utc8 (& self) -> PyResult < String > { Ok (self . inner . change_utc8 . clone () . into ()) } # [getter] fn total_size (& self) -> PyResult < String > { Ok (self . inner . total_size . clone () . into ()) } # [getter] fn volume_24h (& self) -> PyResult < String > { Ok (self . inner . volume_24h . clone () . into ()) } # [getter] fn volume_24h_btc (& self) -> PyResult < String > { Ok (self . inner . volume_24h_btc . clone () . into ()) } # [getter] fn volume_24h_usd (& self) -> PyResult < String > { Ok (self . inner . volume_24h_usd . clone () . into ()) } # [getter] fn volume_24h_base (& self) -> PyResult < String > { Ok (self . inner . volume_24h_base . clone () . into ()) } # [getter] fn volume_24h_quote (& self) -> PyResult < String > { Ok (self . inner . volume_24h_quote . clone () . into ()) } # [getter] fn volume_24h_settle (& self) -> PyResult < String > { Ok (self . inner . volume_24h_settle . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < String > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn funding_rate (& self) -> PyResult < String > { Ok (self . inner . funding_rate . clone () . into ()) } # [getter] fn funding_rate_indicative (& self) -> PyResult < String > { Ok (self . inner . funding_rate_indicative . clone () . into ()) } # [getter] fn index_price (& self) -> PyResult < String > { Ok (self . inner . index_price . clone () . into ()) } # [getter] fn quanto_base_rate (& self) -> PyResult < String > { Ok (self . inner . quanto_base_rate . clone () . into ()) } # [getter] fn funding_next_apply (& self) -> PyResult < i64 > { Ok (self . inner . funding_next_apply . clone () . into ()) } # [getter] fn basis_rate (& self) -> PyResult < String > { Ok (self . inner . basis_rate . clone () . into ()) } # [getter] fn basis_value (& self) -> PyResult < String > { Ok (self . inner . basis_value . clone () . into ()) } # [getter] fn premium_index (& self) -> PyResult < String > { Ok (self . inner . premium_index . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_tickers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_tickers () . await }) } } # [pyclass] # [derive (Clone)] pub struct FuturesFundingRateRequest { inner : venues :: FuturesFundingRateRequest , } # [pymethods] impl FuturesFundingRateRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_funding_rate <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_funding_rate () . await }) } } # [pyclass] # [derive (Clone)] pub struct FuturesRiskLimitTiersRequest { inner : venues :: FuturesRiskLimitTiersRequest , } # [pymethods] impl FuturesRiskLimitTiersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_risk_limit_tiers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_risk_limit_tiers () . await }) } } # [pyclass] # [derive (Clone)] pub struct FuturesStatsRequest { inner : venues :: FuturesStatsRequest , } # [pymethods] impl FuturesStatsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . interval . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FuturesStats { inner : venues :: FuturesStats , } # [pymethods] impl FuturesStats { # [staticmethod] fn from_inner (inner : FuturesStats) -> Self { Self { inner } } # [getter] fn time (& self) -> PyResult < i64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn lsr_taker (& self) -> PyResult < String > { Ok (self . inner . lsr_taker . clone () . into ()) } # [getter] fn lsr_account (& self) -> PyResult < String > { Ok (self . inner . lsr_account . clone () . into ()) } # [getter] fn long_liq_size (& self) -> PyResult < String > { Ok (self . inner . long_liq_size . clone () . into ()) } # [getter] fn long_liq_amount (& self) -> PyResult < String > { Ok (self . inner . long_liq_amount . clone () . into ()) } # [getter] fn long_liq_usd (& self) -> PyResult < String > { Ok (self . inner . long_liq_usd . clone () . into ()) } # [getter] fn short_liq_size (& self) -> PyResult < String > { Ok (self . inner . short_liq_size . clone () . into ()) } # [getter] fn short_liq_amount (& self) -> PyResult < String > { Ok (self . inner . short_liq_amount . clone () . into ()) } # [getter] fn short_liq_usd (& self) -> PyResult < String > { Ok (self . inner . short_liq_usd . clone () . into ()) } # [getter] fn open_interest (& self) -> PyResult < String > { Ok (self . inner . open_interest . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < String > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn top_lsr_account (& self) -> PyResult < String > { Ok (self . inner . top_lsr_account . clone () . into ()) } # [getter] fn top_lsr_size (& self) -> PyResult < String > { Ok (self . inner . top_lsr_size . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_stats <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_stats () . await }) } } # [pyclass] # [derive (Clone)] pub struct FuturesIndexConstituentsRequest { inner : venues :: FuturesIndexConstituentsRequest , } # [pymethods] impl FuturesIndexConstituentsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn index (& self) -> PyResult < String > { Ok (self . inner . index . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_index_constituents <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_index_constituents () . await }) } } # [pyclass] # [derive (Clone)] pub struct FuturesContractsRequest { inner : venues :: FuturesContractsRequest , } # [pymethods] impl FuturesContractsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FuturesContractRequest { inner : venues :: FuturesContractRequest , } # [pymethods] impl FuturesContractRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_contracts <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_contracts () . await }) } fn get_futures_contract <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_contract () . await }) } } # [pyclass] # [derive (Clone)] pub struct FuturesTradesRequest { inner : venues :: FuturesTradesRequest , } # [pymethods] impl FuturesTradesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn last_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . last_id . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FuturesTrade { inner : venues :: FuturesTrade , } # [pymethods] impl FuturesTrade { # [staticmethod] fn from_inner (inner : FuturesTrade) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < f64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn size (& self) -> PyResult < i64 > { Ok (self . inner . size . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn is_internal (& self) -> PyResult < bool > { Ok (self . inner . is_internal . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct FuturesOrderBookRequest { inner : venues :: FuturesOrderBookRequest , } # [pymethods] impl FuturesOrderBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . interval . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn with_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . with_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderBookEntry { inner : venues :: OrderBookEntry , } # [pymethods] impl OrderBookEntry { # [staticmethod] fn from_inner (inner : OrderBookEntry) -> Self { Self { inner } } # [getter] fn p (& self) -> PyResult < String > { Ok (self . inner . p . clone () . into ()) } # [getter] fn s (& self) -> PyResult < i64 > { Ok (self . inner . s . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FuturesOrderBook { inner : venues :: FuturesOrderBook , } # [pymethods] impl FuturesOrderBook { # [staticmethod] fn from_inner (inner : FuturesOrderBook) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn current (& self) -> PyResult < f64 > { Ok (self . inner . current . clone () . into ()) } # [getter] fn update (& self) -> PyResult < f64 > { Ok (self . inner . update . clone () . into ()) } # [getter] fn asks (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . asks . clone () . into ()) } # [getter] fn bids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . bids . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_order_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_order_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct FuturesCandlesticksRequest { inner : venues :: FuturesCandlesticksRequest , } # [pymethods] impl FuturesCandlesticksRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . interval . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_candlesticks <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_candlesticks () . await }) } fn get_futures_mark_price_candlesticks <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_mark_price_candlesticks () . await }) } fn get_futures_index_price_candlesticks <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_index_price_candlesticks () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateFuturesOrderRequest { inner : venues :: CreateFuturesOrderRequest , } # [pymethods] impl CreateFuturesOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn size (& self) -> PyResult < i64 > { Ok (self . inner . size . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn tif (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . tif . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } # [getter] fn reduce_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reduce_only . clone () . into ()) } # [getter] fn close (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . close . clone () . into ()) } # [getter] fn iceberg (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . iceberg . clone () . into ()) } # [getter] fn auto_size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . auto_size . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FuturesOrder { inner : venues :: FuturesOrder , } # [pymethods] impl FuturesOrder { # [staticmethod] fn from_inner (inner : FuturesOrder) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn user (& self) -> PyResult < i64 > { Ok (self . inner . user . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < f64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn finish_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . finish_time . clone () . into ()) } # [getter] fn finish_as (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . finish_as . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn size (& self) -> PyResult < i64 > { Ok (self . inner . size . clone () . into ()) } # [getter] fn iceberg (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . iceberg . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn tif (& self) -> PyResult < String > { Ok (self . inner . tif . clone () . into ()) } # [getter] fn left (& self) -> PyResult < i64 > { Ok (self . inner . left . clone () . into ()) } # [getter] fn fill_price (& self) -> PyResult < String > { Ok (self . inner . fill_price . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } # [getter] fn reduce_only (& self) -> PyResult < bool > { Ok (self . inner . reduce_only . clone () . into ()) } # [getter] fn close (& self) -> PyResult < bool > { Ok (self . inner . close . clone () . into ()) } # [getter] fn reject_post_only (& self) -> PyResult < bool > { Ok (self . inner . reject_post_only . clone () . into ()) } # [getter] fn stp_act (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_act . clone () . into ()) } # [getter] fn amend_text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . amend_text . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ListFuturesOrdersRequest { inner : venues :: ListFuturesOrdersRequest , } # [pymethods] impl ListFuturesOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn count_total (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count_total . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BatchOrdersRequest { inner : venues :: BatchOrdersRequest , } # [pymethods] impl BatchOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn orders (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . orders . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BatchCancelOrdersRequest { inner : venues :: BatchCancelOrdersRequest , } # [pymethods] impl BatchCancelOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn order_ids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . order_ids . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BatchAmendOrdersRequest { inner : venues :: BatchAmendOrdersRequest , } # [pymethods] impl BatchAmendOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn orders (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . orders . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AmendFuturesOrderRequest { inner : venues :: AmendFuturesOrderRequest , } # [pymethods] impl AmendFuturesOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . size . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn amend_text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . amend_text . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BatchOrderResult { inner : venues :: BatchOrderResult , } # [pymethods] impl BatchOrderResult { # [staticmethod] fn from_inner (inner : BatchOrderResult) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . id . clone () . into ()) } # [getter] fn succeeded (& self) -> PyResult < bool > { Ok (self . inner . succeeded . clone () . into ()) } # [getter] fn label (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . label . clone () . into ()) } # [getter] fn message (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . message . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CountdownCancelRequest { inner : venues :: CountdownCancelRequest , } # [pymethods] impl CountdownCancelRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn timeout (& self) -> PyResult < i64 > { Ok (self . inner . timeout . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ListOrdersByTimeRangeRequest { inner : venues :: ListOrdersByTimeRangeRequest , } # [pymethods] impl ListOrdersByTimeRangeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn from (& self) -> PyResult < i64 > { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < i64 > { Ok (self . inner . to . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } } # [pymethods] impl RestClient { fn create_futures_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_futures_order () . await }) } fn list_futures_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_futures_orders () . await }) } fn get_futures_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_order () . await }) } fn cancel_all_futures_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_futures_orders () . await }) } fn cancel_futures_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_futures_order () . await }) } fn create_batch_futures_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_batch_futures_orders () . await }) } fn cancel_batch_futures_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_batch_futures_orders () . await }) } fn amend_batch_futures_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . amend_batch_futures_orders () . await }) } fn countdown_cancel_all_futures_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . countdown_cancel_all_futures_orders () . await }) } fn list_futures_orders_by_time_range <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_futures_orders_by_time_range () . await }) } fn amend_futures_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . amend_futures_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct FuturesPositionsRequest { inner : venues :: FuturesPositionsRequest , } # [pymethods] impl FuturesPositionsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn holding (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . holding . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FuturesPosition { inner : venues :: FuturesPosition , } # [pymethods] impl FuturesPosition { # [staticmethod] fn from_inner (inner : FuturesPosition) -> Self { Self { inner } } # [getter] fn user (& self) -> PyResult < i64 > { Ok (self . inner . user . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn size (& self) -> PyResult < i64 > { Ok (self . inner . size . clone () . into ()) } # [getter] fn entry_price (& self) -> PyResult < String > { Ok (self . inner . entry_price . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < String > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn realised_pnl (& self) -> PyResult < String > { Ok (self . inner . realised_pnl . clone () . into ()) } # [getter] fn unrealised_pnl (& self) -> PyResult < String > { Ok (self . inner . unrealised_pnl . clone () . into ()) } # [getter] fn margin (& self) -> PyResult < String > { Ok (self . inner . margin . clone () . into ()) } # [getter] fn leverage (& self) -> PyResult < String > { Ok (self . inner . leverage . clone () . into ()) } # [getter] fn risk_limit (& self) -> PyResult < String > { Ok (self . inner . risk_limit . clone () . into ()) } # [getter] fn liq_price (& self) -> PyResult < String > { Ok (self . inner . liq_price . clone () . into ()) } # [getter] fn bankruptcy_price (& self) -> PyResult < String > { Ok (self . inner . bankruptcy_price . clone () . into ()) } # [getter] fn cross_leverage_limit (& self) -> PyResult < String > { Ok (self . inner . cross_leverage_limit . clone () . into ()) } # [getter] fn mode (& self) -> PyResult < String > { Ok (self . inner . mode . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < i64 > { Ok (self . inner . update_time . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SetLeverageRequest { inner : venues :: SetLeverageRequest , } # [pymethods] impl SetLeverageRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn leverage (& self) -> PyResult < String > { Ok (self . inner . leverage . clone () . into ()) } # [getter] fn cross_leverage_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cross_leverage_limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct LeverageResponse { inner : venues :: LeverageResponse , } # [pymethods] impl LeverageResponse { # [staticmethod] fn from_inner (inner : LeverageResponse) -> Self { Self { inner } } # [getter] fn leverage (& self) -> PyResult < String > { Ok (self . inner . leverage . clone () . into ()) } # [getter] fn cross_leverage_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cross_leverage_limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UpdatePositionMarginRequest { inner : venues :: UpdatePositionMarginRequest , } # [pymethods] impl UpdatePositionMarginRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn change (& self) -> PyResult < String > { Ok (self . inner . change . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct PositionMarginResponse { inner : venues :: PositionMarginResponse , } # [pymethods] impl PositionMarginResponse { # [staticmethod] fn from_inner (inner : PositionMarginResponse) -> Self { Self { inner } } # [getter] fn margin (& self) -> PyResult < String > { Ok (self . inner . margin . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UpdateRiskLimitRequest { inner : venues :: UpdateRiskLimitRequest , } # [pymethods] impl UpdateRiskLimitRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn risk_limit (& self) -> PyResult < String > { Ok (self . inner . risk_limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RiskLimitResponse { inner : venues :: RiskLimitResponse , } # [pymethods] impl RiskLimitResponse { # [staticmethod] fn from_inner (inner : RiskLimitResponse) -> Self { Self { inner } } # [getter] fn risk_limit (& self) -> PyResult < String > { Ok (self . inner . risk_limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CrossModeRequest { inner : venues :: CrossModeRequest , } # [pymethods] impl CrossModeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn mode (& self) -> PyResult < String > { Ok (self . inner . mode . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DualModeRequest { inner : venues :: DualModeRequest , } # [pymethods] impl DualModeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn dual_mode (& self) -> PyResult < bool > { Ok (self . inner . dual_mode . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DualModeResponse { inner : venues :: DualModeResponse , } # [pymethods] impl DualModeResponse { # [staticmethod] fn from_inner (inner : DualModeResponse) -> Self { Self { inner } } # [getter] fn dual_mode (& self) -> PyResult < bool > { Ok (self . inner . dual_mode . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DualModePosition { inner : venues :: DualModePosition , } # [pymethods] impl DualModePosition { # [staticmethod] fn from_inner (inner : DualModePosition) -> Self { Self { inner } } # [getter] fn user (& self) -> PyResult < i64 > { Ok (self . inner . user . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn long_size (& self) -> PyResult < i64 > { Ok (self . inner . long_size . clone () . into ()) } # [getter] fn short_size (& self) -> PyResult < i64 > { Ok (self . inner . short_size . clone () . into ()) } # [getter] fn long_entry_price (& self) -> PyResult < String > { Ok (self . inner . long_entry_price . clone () . into ()) } # [getter] fn short_entry_price (& self) -> PyResult < String > { Ok (self . inner . short_entry_price . clone () . into ()) } # [getter] fn long_leverage (& self) -> PyResult < String > { Ok (self . inner . long_leverage . clone () . into ()) } # [getter] fn short_leverage (& self) -> PyResult < String > { Ok (self . inner . short_leverage . clone () . into ()) } # [getter] fn long_margin (& self) -> PyResult < String > { Ok (self . inner . long_margin . clone () . into ()) } # [getter] fn short_margin (& self) -> PyResult < String > { Ok (self . inner . short_margin . clone () . into ()) } # [getter] fn long_pnl (& self) -> PyResult < String > { Ok (self . inner . long_pnl . clone () . into ()) } # [getter] fn short_pnl (& self) -> PyResult < String > { Ok (self . inner . short_pnl . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < String > { Ok (self . inner . mark_price . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UpdateDualModeMarginRequest { inner : venues :: UpdateDualModeMarginRequest , } # [pymethods] impl UpdateDualModeMarginRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn change (& self) -> PyResult < String > { Ok (self . inner . change . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DualModeMarginResponse { inner : venues :: DualModeMarginResponse , } # [pymethods] impl DualModeMarginResponse { # [staticmethod] fn from_inner (inner : DualModeMarginResponse) -> Self { Self { inner } } # [getter] fn margin (& self) -> PyResult < String > { Ok (self . inner . margin . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UpdateDualModeLeverageRequest { inner : venues :: UpdateDualModeLeverageRequest , } # [pymethods] impl UpdateDualModeLeverageRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn leverage (& self) -> PyResult < String > { Ok (self . inner . leverage . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DualModeLeverageResponse { inner : venues :: DualModeLeverageResponse , } # [pymethods] impl DualModeLeverageResponse { # [staticmethod] fn from_inner (inner : DualModeLeverageResponse) -> Self { Self { inner } } # [getter] fn leverage (& self) -> PyResult < String > { Ok (self . inner . leverage . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UpdateDualModeRiskLimitRequest { inner : venues :: UpdateDualModeRiskLimitRequest , } # [pymethods] impl UpdateDualModeRiskLimitRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn risk_limit (& self) -> PyResult < String > { Ok (self . inner . risk_limit . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DualModeRiskLimitResponse { inner : venues :: DualModeRiskLimitResponse , } # [pymethods] impl DualModeRiskLimitResponse { # [staticmethod] fn from_inner (inner : DualModeRiskLimitResponse) -> Self { Self { inner } } # [getter] fn risk_limit (& self) -> PyResult < String > { Ok (self . inner . risk_limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_positions <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_positions () . await }) } fn get_futures_position <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_position () . await }) } fn set_position_leverage <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . set_position_leverage () . await }) } fn update_position_margin <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . update_position_margin () . await }) } fn update_position_risk_limit <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . update_position_risk_limit () . await }) } fn switch_to_cross_margin <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . switch_to_cross_margin () . await }) } fn set_dual_mode <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . set_dual_mode () . await }) } fn get_dual_mode_position <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_dual_mode_position () . await }) } fn update_dual_mode_position_margin <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . update_dual_mode_position_margin () . await }) } fn update_dual_mode_position_leverage <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . update_dual_mode_position_leverage () . await }) } fn update_dual_mode_position_risk_limit <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . update_dual_mode_position_risk_limit () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn base_url (& self) -> PyResult < () > { self . inner . base_url () ; Ok (()) } fn get <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get () . await }) } fn get_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_with_query () . await }) } fn post <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . post () . await }) } fn put <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . put () . await }) } fn delete <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . delete () . await }) } fn delete_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . delete_with_query () . await }) } fn patch <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . patch () . await }) } } # [pyclass] # [derive (Clone)] pub struct FuturesAccountsRequest { inner : venues :: FuturesAccountsRequest , } # [pymethods] impl FuturesAccountsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FuturesAccount { inner : venues :: FuturesAccount , } # [pymethods] impl FuturesAccount { # [staticmethod] fn from_inner (inner : FuturesAccount) -> Self { Self { inner } } # [getter] fn total (& self) -> PyResult < String > { Ok (self . inner . total . clone () . into ()) } # [getter] fn unrealised_pnl (& self) -> PyResult < String > { Ok (self . inner . unrealised_pnl . clone () . into ()) } # [getter] fn position_margin (& self) -> PyResult < String > { Ok (self . inner . position_margin . clone () . into ()) } # [getter] fn order_margin (& self) -> PyResult < String > { Ok (self . inner . order_margin . clone () . into ()) } # [getter] fn available (& self) -> PyResult < String > { Ok (self . inner . available . clone () . into ()) } # [getter] fn point (& self) -> PyResult < String > { Ok (self . inner . point . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn in_dual_mode (& self) -> PyResult < bool > { Ok (self . inner . in_dual_mode . clone () . into ()) } # [getter] fn enable_credit (& self) -> PyResult < bool > { Ok (self . inner . enable_credit . clone () . into ()) } # [getter] fn position_cross_margin (& self) -> PyResult < String > { Ok (self . inner . position_cross_margin . clone () . into ()) } # [getter] fn order_cross_margin (& self) -> PyResult < String > { Ok (self . inner . order_cross_margin . clone () . into ()) } # [getter] fn available_cross_margin (& self) -> PyResult < String > { Ok (self . inner . available_cross_margin . clone () . into ()) } # [getter] fn total_cross_margin (& self) -> PyResult < String > { Ok (self . inner . total_cross_margin . clone () . into ()) } } # [pymethods] impl RestClient { fn get_futures_accounts <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_futures_accounts () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestResponse { inner : venues :: RestResponse , } # [pymethods] impl RestResponse { # [staticmethod] fn from_inner (inner : RestResponse) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < String > { Ok (self . inner . code . clone () . into ()) } # [getter] fn data (& self) -> PyResult < PyObject > { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_expirations <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_expirations () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn base_url (& self) -> PyResult < () > { self . inner . base_url () ; Ok (()) } fn get <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get () . await }) } fn get_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_with_query () . await }) } } # [pymethods] impl RestClient { fn get_options_underlyings <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_underlyings () . await }) } } # [pyclass] # [derive (Clone)] pub struct OptionsTickersRequest { inner : venues :: OptionsTickersRequest , } # [pymethods] impl OptionsTickersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn underlying (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . underlying . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OptionsTicker { inner : venues :: OptionsTicker , } # [pymethods] impl OptionsTicker { # [staticmethod] fn from_inner (inner : OptionsTicker) -> Self { Self { inner } } # [getter] fn name (& self) -> PyResult < String > { Ok (self . inner . name . clone () . into ()) } # [getter] fn last (& self) -> PyResult < String > { Ok (self . inner . last . clone () . into ()) } # [getter] fn change_percentage (& self) -> PyResult < String > { Ok (self . inner . change_percentage . clone () . into ()) } # [getter] fn total_size (& self) -> PyResult < String > { Ok (self . inner . total_size . clone () . into ()) } # [getter] fn lowest_ask (& self) -> PyResult < String > { Ok (self . inner . lowest_ask . clone () . into ()) } # [getter] fn highest_bid (& self) -> PyResult < String > { Ok (self . inner . highest_bid . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < String > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn mark_iv (& self) -> PyResult < String > { Ok (self . inner . mark_iv . clone () . into ()) } # [getter] fn index_price (& self) -> PyResult < String > { Ok (self . inner . index_price . clone () . into ()) } # [getter] fn bid_iv (& self) -> PyResult < String > { Ok (self . inner . bid_iv . clone () . into ()) } # [getter] fn ask_iv (& self) -> PyResult < String > { Ok (self . inner . ask_iv . clone () . into ()) } # [getter] fn position_size (& self) -> PyResult < i64 > { Ok (self . inner . position_size . clone () . into ()) } # [getter] fn delta (& self) -> PyResult < String > { Ok (self . inner . delta . clone () . into ()) } # [getter] fn gamma (& self) -> PyResult < String > { Ok (self . inner . gamma . clone () . into ()) } # [getter] fn vega (& self) -> PyResult < String > { Ok (self . inner . vega . clone () . into ()) } # [getter] fn theta (& self) -> PyResult < String > { Ok (self . inner . theta . clone () . into ()) } # [getter] fn rho (& self) -> PyResult < String > { Ok (self . inner . rho . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnderlyingTicker { inner : venues :: UnderlyingTicker , } # [pymethods] impl UnderlyingTicker { # [staticmethod] fn from_inner (inner : UnderlyingTicker) -> Self { Self { inner } } # [getter] fn trade_enabled (& self) -> PyResult < bool > { Ok (self . inner . trade_enabled . clone () . into ()) } # [getter] fn index_price (& self) -> PyResult < String > { Ok (self . inner . index_price . clone () . into ()) } # [getter] fn trade_put (& self) -> PyResult < i64 > { Ok (self . inner . trade_put . clone () . into ()) } # [getter] fn trade_call (& self) -> PyResult < i64 > { Ok (self . inner . trade_call . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_tickers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_tickers () . await }) } fn get_underlying_ticker <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_underlying_ticker () . await }) } } # [pyclass] # [derive (Clone)] pub struct OptionsSettlementsRequest { inner : venues :: OptionsSettlementsRequest , } # [pymethods] impl OptionsSettlementsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn underlying (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . underlying . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_settlements <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_settlements () . await }) } fn get_options_contract_settlement <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_contract_settlement () . await }) } } # [pyclass] # [derive (Clone)] pub struct OptionsContractsRequest { inner : venues :: OptionsContractsRequest , } # [pymethods] impl OptionsContractsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn underlying (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . underlying . clone () . into ()) } # [getter] fn expiration (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . expiration . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_contracts <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_contracts () . await }) } fn get_options_contract <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_contract () . await }) } } # [pyclass] # [derive (Clone)] pub struct OptionsTradesRequest { inner : venues :: OptionsTradesRequest , } # [pymethods] impl OptionsTradesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn last_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . last_id . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OptionsTrade { inner : venues :: OptionsTrade , } # [pymethods] impl OptionsTrade { # [staticmethod] fn from_inner (inner : OptionsTrade) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < f64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn size (& self) -> PyResult < String > { Ok (self . inner . size . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn is_internal (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . is_internal . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct OptionsOrderBookRequest { inner : venues :: OptionsOrderBookRequest , } # [pymethods] impl OptionsOrderBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . interval . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn with_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . with_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OptionsOrderBookEntry { inner : venues :: OptionsOrderBookEntry , } # [pymethods] impl OptionsOrderBookEntry { # [staticmethod] fn from_inner (inner : OptionsOrderBookEntry) -> Self { Self { inner } } # [getter] fn p (& self) -> PyResult < String > { Ok (self . inner . p . clone () . into ()) } # [getter] fn s (& self) -> PyResult < i64 > { Ok (self . inner . s . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OptionsOrderBook { inner : venues :: OptionsOrderBook , } # [pymethods] impl OptionsOrderBook { # [staticmethod] fn from_inner (inner : OptionsOrderBook) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . id . clone () . into ()) } # [getter] fn current (& self) -> PyResult < i64 > { Ok (self . inner . current . clone () . into ()) } # [getter] fn update (& self) -> PyResult < i64 > { Ok (self . inner . update . clone () . into ()) } # [getter] fn asks (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . asks . clone () . into ()) } # [getter] fn bids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . bids . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_order_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_order_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct OptionsCandlesticksRequest { inner : venues :: OptionsCandlesticksRequest , } # [pymethods] impl OptionsCandlesticksRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . interval . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnderlyingCandlesticksRequest { inner : venues :: UnderlyingCandlesticksRequest , } # [pymethods] impl UnderlyingCandlesticksRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn underlying (& self) -> PyResult < String > { Ok (self . inner . underlying . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . interval . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_candlesticks <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_candlesticks () . await }) } fn get_underlying_candlesticks <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_underlying_candlesticks () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateOptionsOrderRequest { inner : venues :: CreateOptionsOrderRequest , } # [pymethods] impl CreateOptionsOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn size (& self) -> PyResult < String > { Ok (self . inner . size . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn tif (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . tif . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } # [getter] fn reduce_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reduce_only . clone () . into ()) } # [getter] fn close (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . close . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OptionsOrder { inner : venues :: OptionsOrder , } # [pymethods] impl OptionsOrder { # [staticmethod] fn from_inner (inner : OptionsOrder) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn user (& self) -> PyResult < i64 > { Ok (self . inner . user . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn underlying (& self) -> PyResult < String > { Ok (self . inner . underlying . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < f64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn finish_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . finish_time . clone () . into ()) } # [getter] fn finish_as (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . finish_as . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn size (& self) -> PyResult < String > { Ok (self . inner . size . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn tif (& self) -> PyResult < String > { Ok (self . inner . tif . clone () . into ()) } # [getter] fn left (& self) -> PyResult < String > { Ok (self . inner . left . clone () . into ()) } # [getter] fn filled_total (& self) -> PyResult < String > { Ok (self . inner . filled_total . clone () . into ()) } # [getter] fn avg_deal_price (& self) -> PyResult < String > { Ok (self . inner . avg_deal_price . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn is_reduce_only (& self) -> PyResult < bool > { Ok (self . inner . is_reduce_only . clone () . into ()) } # [getter] fn is_close (& self) -> PyResult < bool > { Ok (self . inner . is_close . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < String > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn rebate (& self) -> PyResult < String > { Ok (self . inner . rebate . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ListOptionsOrdersRequest { inner : venues :: ListOptionsOrdersRequest , } # [pymethods] impl ListOptionsOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn underlying (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . underlying . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } } # [pymethods] impl RestClient { fn create_options_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_options_order () . await }) } fn list_options_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_options_orders () . await }) } fn get_options_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_order () . await }) } fn cancel_all_options_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_options_orders () . await }) } fn cancel_options_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_options_order () . await }) } fn countdown_cancel_options_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . countdown_cancel_options_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct UpdateMMPRequest { inner : venues :: UpdateMMPRequest , } # [pymethods] impl UpdateMMPRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn underlying (& self) -> PyResult < String > { Ok (self . inner . underlying . clone () . into ()) } # [getter] fn enable (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . enable . clone () . into ()) } # [getter] fn window (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . window . clone () . into ()) } # [getter] fn freeze_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . freeze_time . clone () . into ()) } # [getter] fn trade_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trade_limit . clone () . into ()) } # [getter] fn delta_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . delta_limit . clone () . into ()) } # [getter] fn vega_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . vega_limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_mmp_settings <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_mmp_settings () . await }) } fn update_mmp_settings <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . update_mmp_settings () . await }) } fn reset_mmp <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . reset_mmp () . await }) } } # [pyclass] # [derive (Clone)] pub struct OptionsPositionsRequest { inner : venues :: OptionsPositionsRequest , } # [pymethods] impl OptionsPositionsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn underlying (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . underlying . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OptionsPosition { inner : venues :: OptionsPosition , } # [pymethods] impl OptionsPosition { # [staticmethod] fn from_inner (inner : OptionsPosition) -> Self { Self { inner } } # [getter] fn user (& self) -> PyResult < i64 > { Ok (self . inner . user . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn size (& self) -> PyResult < String > { Ok (self . inner . size . clone () . into ()) } # [getter] fn entry_price (& self) -> PyResult < String > { Ok (self . inner . entry_price . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < String > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn mark_iv (& self) -> PyResult < String > { Ok (self . inner . mark_iv . clone () . into ()) } # [getter] fn realised_pnl (& self) -> PyResult < String > { Ok (self . inner . realised_pnl . clone () . into ()) } # [getter] fn unrealised_pnl (& self) -> PyResult < String > { Ok (self . inner . unrealised_pnl . clone () . into ()) } # [getter] fn pending_orders (& self) -> PyResult < i64 > { Ok (self . inner . pending_orders . clone () . into ()) } # [getter] fn close_order (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . close_order . clone () . into ()) } # [getter] fn delta (& self) -> PyResult < String > { Ok (self . inner . delta . clone () . into ()) } # [getter] fn gamma (& self) -> PyResult < String > { Ok (self . inner . gamma . clone () . into ()) } # [getter] fn vega (& self) -> PyResult < String > { Ok (self . inner . vega . clone () . into ()) } # [getter] fn theta (& self) -> PyResult < String > { Ok (self . inner . theta . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_positions <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_positions () . await }) } fn get_options_position <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_position () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn base_url (& self) -> PyResult < () > { self . inner . base_url () ; Ok (()) } fn get <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get () . await }) } fn get_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_with_query () . await }) } fn post <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . post () . await }) } fn put <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . put () . await }) } fn delete <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . delete () . await }) } fn delete_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . delete_with_query () . await }) } fn patch <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . patch () . await }) } } # [pyclass] # [derive (Clone)] pub struct OptionsAccountBookEntry { inner : venues :: OptionsAccountBookEntry , } # [pymethods] impl OptionsAccountBookEntry { # [staticmethod] fn from_inner (inner : OptionsAccountBookEntry) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn time (& self) -> PyResult < f64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn change (& self) -> PyResult < String > { Ok (self . inner . change . clone () . into ()) } # [getter] fn balance (& self) -> PyResult < String > { Ok (self . inner . balance . clone () . into ()) } # [getter] fn entry_type (& self) -> PyResult < String > { Ok (self . inner . entry_type . clone () . into ()) } # [getter] fn text (& self) -> PyResult < String > { Ok (self . inner . text . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OptionsAccountBookRequest { inner : venues :: OptionsAccountBookRequest , } # [pymethods] impl OptionsAccountBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn entry_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . entry_type . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_account_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_account_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct OptionsAccount { inner : venues :: OptionsAccount , } # [pymethods] impl OptionsAccount { # [staticmethod] fn from_inner (inner : OptionsAccount) -> Self { Self { inner } } # [getter] fn total (& self) -> PyResult < String > { Ok (self . inner . total . clone () . into ()) } # [getter] fn unrealised_pnl (& self) -> PyResult < String > { Ok (self . inner . unrealised_pnl . clone () . into ()) } # [getter] fn init_margin (& self) -> PyResult < String > { Ok (self . inner . init_margin . clone () . into ()) } # [getter] fn maint_margin (& self) -> PyResult < String > { Ok (self . inner . maint_margin . clone () . into ()) } # [getter] fn option_value (& self) -> PyResult < String > { Ok (self . inner . option_value . clone () . into ()) } # [getter] fn available (& self) -> PyResult < String > { Ok (self . inner . available . clone () . into ()) } # [getter] fn point (& self) -> PyResult < String > { Ok (self . inner . point . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn portfolio_margin (& self) -> PyResult < String > { Ok (self . inner . portfolio_margin . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_accounts <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_accounts () . await }) } } # [pyclass] # [derive (Clone)] pub struct OptionsPositionCloseHistory { inner : venues :: OptionsPositionCloseHistory , } # [pymethods] impl OptionsPositionCloseHistory { # [staticmethod] fn from_inner (inner : OptionsPositionCloseHistory) -> Self { Self { inner } } # [getter] fn time (& self) -> PyResult < f64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn pnl (& self) -> PyResult < String > { Ok (self . inner . pnl . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn text (& self) -> PyResult < String > { Ok (self . inner . text . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OptionsPositionCloseHistoryRequest { inner : venues :: OptionsPositionCloseHistoryRequest , } # [pymethods] impl OptionsPositionCloseHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn underlying (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . underlying . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn side (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . side . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_position_close_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_position_close_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct OptionsSettlementsRequest { inner : venues :: OptionsSettlementsRequest , } # [pymethods] impl OptionsSettlementsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn underlying (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . underlying . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_settlements <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_settlements () . await }) } } # [pyclass] # [derive (Clone)] pub struct OptionsTrade { inner : venues :: OptionsTrade , } # [pymethods] impl OptionsTrade { # [staticmethod] fn from_inner (inner : OptionsTrade) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < f64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn size (& self) -> PyResult < i64 > { Ok (self . inner . size . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn underlying (& self) -> PyResult < String > { Ok (self . inner . underlying . clone () . into ()) } # [getter] fn role (& self) -> PyResult < String > { Ok (self . inner . role . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OptionsTradesRequest { inner : venues :: OptionsTradesRequest , } # [pymethods] impl OptionsTradesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn underlying (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . underlying . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } } # [pymethods] impl RestClient { fn get_options_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_options_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestResponse { inner : venues :: RestResponse , } # [pymethods] impl RestResponse { # [staticmethod] fn from_inner (inner : RestResponse) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < String > { Ok (self . inner . code . clone () . into ()) } # [getter] fn data (& self) -> PyResult < PyObject > { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn base_url (& self) -> PyResult < () > { self . inner . base_url () ; Ok (()) } fn get <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get () . await }) } fn get_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_with_query () . await }) } } # [pyclass] # [derive (Clone)] pub struct UnifiedMarginCurrencyPairsRequest { inner : venues :: UnifiedMarginCurrencyPairsRequest , } # [pymethods] impl UnifiedMarginCurrencyPairsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnifiedMarginLoansRequest { inner : venues :: UnifiedMarginLoansRequest , } # [pymethods] impl UnifiedMarginLoansRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateUnifiedMarginLoanRequest { inner : venues :: CreateUnifiedMarginLoanRequest , } # [pymethods] impl CreateUnifiedMarginLoanRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnifiedMarginLoanRecordsRequest { inner : venues :: UnifiedMarginLoanRecordsRequest , } # [pymethods] impl UnifiedMarginLoanRecordsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnifiedMarginBorrowableRequest { inner : venues :: UnifiedMarginBorrowableRequest , } # [pymethods] impl UnifiedMarginBorrowableRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnifiedMarginInterestRecordsRequest { inner : venues :: UnifiedMarginInterestRecordsRequest , } # [pymethods] impl UnifiedMarginInterestRecordsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_unified_margin_currency_pairs <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_unified_margin_currency_pairs () . await }) } fn get_unified_margin_currency_pair <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_unified_margin_currency_pair () . await }) } fn get_unified_margin_loans <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_unified_margin_loans () . await }) } fn create_unified_margin_loan <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_unified_margin_loan () . await }) } fn get_unified_margin_loan_records <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_unified_margin_loan_records () . await }) } fn get_unified_margin_borrowable <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_unified_margin_borrowable () . await }) } fn get_unified_margin_interest_records <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_unified_margin_interest_records () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn base_url (& self) -> PyResult < () > { self . inner . base_url () ; Ok (()) } fn get <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get () . await }) } fn get_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_with_query () . await }) } fn post <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . post () . await }) } fn put <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . put () . await }) } fn delete <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . delete () . await }) } fn delete_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . delete_with_query () . await }) } fn patch <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . patch () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetUnifiedAccountRequest { inner : venues :: GetUnifiedAccountRequest , } # [pymethods] impl GetUnifiedAccountRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnifiedAccount { inner : venues :: UnifiedAccount , } # [pymethods] impl UnifiedAccount { # [staticmethod] fn from_inner (inner : UnifiedAccount) -> Self { Self { inner } } # [getter] fn user_id (& self) -> PyResult < i64 > { Ok (self . inner . user_id . clone () . into ()) } # [getter] fn refresh_time (& self) -> PyResult < i64 > { Ok (self . inner . refresh_time . clone () . into ()) } # [getter] fn locked (& self) -> PyResult < bool > { Ok (self . inner . locked . clone () . into ()) } # [getter] fn balances (& self) -> PyResult < PyObject > { Ok (self . inner . balances . clone () . into ()) } # [getter] fn total (& self) -> PyResult < String > { Ok (self . inner . total . clone () . into ()) } # [getter] fn borrowed (& self) -> PyResult < String > { Ok (self . inner . borrowed . clone () . into ()) } # [getter] fn interest (& self) -> PyResult < String > { Ok (self . inner . interest . clone () . into ()) } # [getter] fn risk (& self) -> PyResult < String > { Ok (self . inner . risk . clone () . into ()) } # [getter] fn total_initial_margin (& self) -> PyResult < String > { Ok (self . inner . total_initial_margin . clone () . into ()) } # [getter] fn total_margin_balance (& self) -> PyResult < String > { Ok (self . inner . total_margin_balance . clone () . into ()) } # [getter] fn total_maintenance_margin (& self) -> PyResult < String > { Ok (self . inner . total_maintenance_margin . clone () . into ()) } # [getter] fn total_initial_margin_rate (& self) -> PyResult < String > { Ok (self . inner . total_initial_margin_rate . clone () . into ()) } # [getter] fn total_maintenance_margin_rate (& self) -> PyResult < String > { Ok (self . inner . total_maintenance_margin_rate . clone () . into ()) } # [getter] fn total_available_margin (& self) -> PyResult < String > { Ok (self . inner . total_available_margin . clone () . into ()) } # [getter] fn total_position_initial_margin (& self) -> PyResult < String > { Ok (self . inner . total_position_initial_margin . clone () . into ()) } # [getter] fn total_order_initial_margin (& self) -> PyResult < String > { Ok (self . inner . total_order_initial_margin . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CurrencyBalance { inner : venues :: CurrencyBalance , } # [pymethods] impl CurrencyBalance { # [staticmethod] fn from_inner (inner : CurrencyBalance) -> Self { Self { inner } } # [getter] fn available (& self) -> PyResult < String > { Ok (self . inner . available . clone () . into ()) } # [getter] fn freeze (& self) -> PyResult < String > { Ok (self . inner . freeze . clone () . into ()) } # [getter] fn borrowed (& self) -> PyResult < String > { Ok (self . inner . borrowed . clone () . into ()) } # [getter] fn interest (& self) -> PyResult < String > { Ok (self . inner . interest . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BorrowOrRepayRequest { inner : venues :: BorrowOrRepayRequest , } # [pymethods] impl BorrowOrRepayRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn operation_type (& self) -> PyResult < String > { Ok (self . inner . operation_type . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BorrowOrRepayResponse { inner : venues :: BorrowOrRepayResponse , } # [pymethods] impl BorrowOrRepayResponse { # [staticmethod] fn from_inner (inner : BorrowOrRepayResponse) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn operation_type (& self) -> PyResult < String > { Ok (self . inner . operation_type . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetBorrowableRequest { inner : venues :: GetBorrowableRequest , } # [pymethods] impl GetBorrowableRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BorrowableResponse { inner : venues :: BorrowableResponse , } # [pymethods] impl BorrowableResponse { # [staticmethod] fn from_inner (inner : BorrowableResponse) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn borrowable (& self) -> PyResult < String > { Ok (self . inner . borrowable . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetTransferablesRequest { inner : venues :: GetTransferablesRequest , } # [pymethods] impl GetTransferablesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TransferableResponse { inner : venues :: TransferableResponse , } # [pymethods] impl TransferableResponse { # [staticmethod] fn from_inner (inner : TransferableResponse) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } } # [pymethods] impl RestClient { fn get_unified_account <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_unified_account () . await }) } } # [pyclass] # [derive (Clone)] pub struct UnifiedModeRequest { inner : venues :: UnifiedModeRequest , } # [pymethods] impl UnifiedModeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn unified (& self) -> PyResult < bool > { Ok (self . inner . unified . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnifiedModeResponse { inner : venues :: UnifiedModeResponse , } # [pymethods] impl UnifiedModeResponse { # [staticmethod] fn from_inner (inner : UnifiedModeResponse) -> Self { Self { inner } } # [getter] fn user_id (& self) -> PyResult < i64 > { Ok (self . inner . user_id . clone () . into ()) } # [getter] fn unified (& self) -> PyResult < bool > { Ok (self . inner . unified . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnifiedCurrenciesRequest { inner : venues :: UnifiedCurrenciesRequest , } # [pymethods] impl UnifiedCurrenciesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnifiedBorrowableRequest { inner : venues :: UnifiedBorrowableRequest , } # [pymethods] impl UnifiedBorrowableRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnifiedBorrowableResponse { inner : venues :: UnifiedBorrowableResponse , } # [pymethods] impl UnifiedBorrowableResponse { # [staticmethod] fn from_inner (inner : UnifiedBorrowableResponse) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn borrowable (& self) -> PyResult < String > { Ok (self . inner . borrowable . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BatchBorrowableRequest { inner : venues :: BatchBorrowableRequest , } # [pymethods] impl BatchBorrowableRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currencies (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . currencies . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BatchBorrowableResponse { inner : venues :: BatchBorrowableResponse , } # [pymethods] impl BatchBorrowableResponse { # [staticmethod] fn from_inner (inner : BatchBorrowableResponse) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn borrowable (& self) -> PyResult < String > { Ok (self . inner . borrowable . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnifiedTransferableRequest { inner : venues :: UnifiedTransferableRequest , } # [pymethods] impl UnifiedTransferableRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn from (& self) -> PyResult < String > { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < String > { Ok (self . inner . to . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UnifiedTransferableResponse { inner : venues :: UnifiedTransferableResponse , } # [pymethods] impl UnifiedTransferableResponse { # [staticmethod] fn from_inner (inner : UnifiedTransferableResponse) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn transferable (& self) -> PyResult < String > { Ok (self . inner . transferable . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct EstimateRateRequest { inner : venues :: EstimateRateRequest , } # [pymethods] impl EstimateRateRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currencies (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . currencies . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct HistoricalLoanRateRequest { inner : venues :: HistoricalLoanRateRequest , } # [pymethods] impl HistoricalLoanRateRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct LeverageConfig { inner : venues :: LeverageConfig , } # [pymethods] impl LeverageConfig { # [staticmethod] fn from_inner (inner : LeverageConfig) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn max_leverage (& self) -> PyResult < String > { Ok (self . inner . max_leverage . clone () . into ()) } # [getter] fn min_size (& self) -> PyResult < String > { Ok (self . inner . min_size . clone () . into ()) } # [getter] fn max_size (& self) -> PyResult < String > { Ok (self . inner . max_size . clone () . into ()) } # [getter] fn maintenance_rate (& self) -> PyResult < String > { Ok (self . inner . maintenance_rate . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SetLeverageConfigRequest { inner : venues :: SetLeverageConfigRequest , } # [pymethods] impl SetLeverageConfigRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn leverage (& self) -> PyResult < String > { Ok (self . inner . leverage . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct PortfolioCalculatorRequest { inner : venues :: PortfolioCalculatorRequest , } # [pymethods] impl PortfolioCalculatorRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn spot_balances (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . spot_balances . clone () . into ()) } # [getter] fn futures_positions (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . futures_positions . clone () . into ()) } # [getter] fn options_positions (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . options_positions . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BalanceEntry { inner : venues :: BalanceEntry , } # [pymethods] impl BalanceEntry { # [staticmethod] fn from_inner (inner : BalanceEntry) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct PositionEntry { inner : venues :: PositionEntry , } # [pymethods] impl PositionEntry { # [staticmethod] fn from_inner (inner : PositionEntry) -> Self { Self { inner } } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn size (& self) -> PyResult < String > { Ok (self . inner . size . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct PortfolioCalculationResult { inner : venues :: PortfolioCalculationResult , } # [pymethods] impl PortfolioCalculationResult { # [staticmethod] fn from_inner (inner : PortfolioCalculationResult) -> Self { Self { inner } } # [getter] fn total_balance (& self) -> PyResult < String > { Ok (self . inner . total_balance . clone () . into ()) } # [getter] fn total_margin (& self) -> PyResult < String > { Ok (self . inner . total_margin . clone () . into ()) } # [getter] fn available_margin (& self) -> PyResult < String > { Ok (self . inner . available_margin . clone () . into ()) } # [getter] fn risk_level (& self) -> PyResult < String > { Ok (self . inner . risk_level . clone () . into ()) } # [getter] fn maintenance_margin (& self) -> PyResult < String > { Ok (self . inner . maintenance_margin . clone () . into ()) } } # [pymethods] impl RestClient { fn get_unified_mode <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_unified_mode () . await }) } fn set_unified_mode <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . set_unified_mode () . await }) } fn get_unified_currencies <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_unified_currencies () . await }) } fn get_unified_borrowable <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_unified_borrowable () . await }) } fn get_batch_borrowable <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_batch_borrowable () . await }) } fn get_unified_transferable <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_unified_transferable () . await }) } fn get_unified_transferables <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_unified_transferables () . await }) } fn get_currency_discount_tiers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_currency_discount_tiers () . await }) } fn get_loan_margin_tiers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_loan_margin_tiers () . await }) } fn get_risk_units <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_risk_units () . await }) } fn get_estimate_rate <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_estimate_rate () . await }) } fn get_history_loan_rate <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_history_loan_rate () . await }) } fn get_leverage_user_currency_config <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_leverage_user_currency_config () . await }) } fn get_leverage_user_currency_setting <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_leverage_user_currency_setting () . await }) } fn set_leverage_user_currency_setting <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . set_leverage_user_currency_setting () . await }) } fn portfolio_calculator <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . portfolio_calculator () . await }) } } # [pyclass] # [derive (Clone)] pub struct BorrowOrRepayRequest { inner : venues :: BorrowOrRepayRequest , } # [pymethods] impl BorrowOrRepayRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn type_ (& self) -> PyResult < String > { Ok (self . inner . type_ . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BorrowOrRepayResponse { inner : venues :: BorrowOrRepayResponse , } # [pymethods] impl BorrowOrRepayResponse { # [staticmethod] fn from_inner (inner : BorrowOrRepayResponse) -> Self { Self { inner } } # [getter] fn succeed (& self) -> PyResult < bool > { Ok (self . inner . succeed . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ListLoansRequest { inner : venues :: ListLoansRequest , } # [pymethods] impl ListLoansRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct GetMaxBorrowableRequest { inner : venues :: GetMaxBorrowableRequest , } # [pymethods] impl GetMaxBorrowableRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ListLoanInterestRecordsRequest { inner : venues :: ListLoanInterestRecordsRequest , } # [pymethods] impl ListLoanInterestRecordsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn borrow_or_repay <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . borrow_or_repay () . await }) } fn borrow <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . borrow () . await }) } fn repay <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . repay () . await }) } fn repay_all <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . repay_all () . await }) } fn list_loans <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_loans () . await }) } fn get_loan_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_loan_history () . await }) } fn get_all_loan_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_all_loan_history () . await }) } fn get_max_borrowable <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_max_borrowable () . await }) } fn list_loan_interest_records <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_loan_interest_records () . await }) } } # [pyclass] # [derive (Clone)] pub enum OrderSide { Buy , Sell , } # [pyclass] # [derive (Clone)] pub enum OrderType { Limit , Market , } # [pyclass] # [derive (Clone)] pub enum TimeInForce { GoodTillCanceled , ImmediateOrCancel , PendingOrCancelled , FillOrKill , } # [pyclass] # [derive (Clone)] pub enum OrderStatus { Open , Closed , Cancelled , } # [pyclass] # [derive (Clone)] pub enum StpMode { CancelNewest , CancelOldest , CancelBoth , DecreaseCancel , } # [pyclass] # [derive (Clone)] pub enum AccountType { Spot , Margin , Futures , Delivery , Options , Cross , Isolated , } # [pyclass] # [derive (Clone)] pub enum CandlestickInterval { Seconds10 , Minutes1 , Minutes5 , Minutes15 , Minutes30 , Hours1 , Hours4 , Hours8 , Days1 , Days7 , Days30 , } # [pyclass] # [derive (Clone)] pub struct ApiError { inner : venues :: ApiError , } # [pymethods] impl ApiError { # [staticmethod] fn from_inner (inner : ApiError) -> Self { Self { inner } } # [getter] fn label (& self) -> PyResult < String > { Ok (self . inner . label . clone () . into ()) } # [getter] fn message (& self) -> PyResult < String > { Ok (self . inner . message . clone () . into ()) } # [getter] fn detail (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . detail . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ErrorResponse { inner : venues :: ErrorResponse , } # [pymethods] impl ErrorResponse { # [staticmethod] fn from_inner (inner : ErrorResponse) -> Self { Self { inner } } # [getter] fn label (& self) -> PyResult < String > { Ok (self . inner . label . clone () . into ()) } # [getter] fn message (& self) -> PyResult < String > { Ok (self . inner . message . clone () . into ()) } # [getter] fn detail (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . detail . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RateLimitHeader { inner : venues :: RateLimitHeader , } # [pymethods] impl RateLimitHeader { # [staticmethod] fn from_inner (inner : RateLimitHeader) -> Self { Self { inner } } # [getter] fn requests_remain (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . requests_remain . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn reset_timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reset_timestamp . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RateLimitStatus { inner : venues :: RateLimitStatus , } # [pymethods] impl RateLimitStatus { # [staticmethod] fn from_inner (inner : RateLimitStatus) -> Self { Self { inner } } # [getter] fn endpoint (& self) -> PyResult < String > { Ok (self . inner . endpoint . clone () . into ()) } # [getter] fn requests_remaining (& self) -> PyResult < u64 > { Ok (self . inner . requests_remaining . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < u64 > { Ok (self . inner . limit . clone () . into ()) } # [getter] fn reset_at (& self) -> PyResult < PyObject > { Ok (self . inner . reset_at . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UsageInfo { inner : venues :: UsageInfo , } # [pymethods] impl UsageInfo { # [staticmethod] fn from_inner (inner : UsageInfo) -> Self { Self { inner } } # [getter] fn requests_made (& self) -> PyResult < u64 > { Ok (self . inner . requests_made . clone () . into ()) } # [getter] fn last_request (& self) -> PyResult < PyObject > { Ok (self . inner . last_request . clone () . into ()) } # [getter] fn reset_time (& self) -> PyResult < PyObject > { Ok (self . inner . reset_time . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RateLimiter { inner : venues :: RateLimiter , } # [pymethods] impl RateLimiter { # [staticmethod] fn from_inner (inner : RateLimiter) -> Self { Self { inner } } } # [pyclass] # [derive (Clone)] pub struct RestResponse { inner : venues :: RestResponse , } # [pymethods] impl RestResponse { # [staticmethod] fn from_inner (inner : RestResponse) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < String > { Ok (self . inner . code . clone () . into ()) } # [getter] fn data (& self) -> PyResult < PyObject > { Ok (self . inner . data . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn base_url (& self) -> PyResult < () > { self . inner . base_url () ; Ok (()) } fn get <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get () . await }) } fn get_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_with_query () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryInsuranceRequest { inner : venues :: DeliveryInsuranceRequest , } # [pymethods] impl DeliveryInsuranceRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_insurance <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_insurance () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryTickersRequest { inner : venues :: DeliveryTickersRequest , } # [pymethods] impl DeliveryTickersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryTicker { inner : venues :: DeliveryTicker , } # [pymethods] impl DeliveryTicker { # [staticmethod] fn from_inner (inner : DeliveryTicker) -> Self { Self { inner } } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn last (& self) -> PyResult < String > { Ok (self . inner . last . clone () . into ()) } # [getter] fn lowest_ask (& self) -> PyResult < String > { Ok (self . inner . lowest_ask . clone () . into ()) } # [getter] fn highest_bid (& self) -> PyResult < String > { Ok (self . inner . highest_bid . clone () . into ()) } # [getter] fn change_percentage (& self) -> PyResult < String > { Ok (self . inner . change_percentage . clone () . into ()) } # [getter] fn change_utc0 (& self) -> PyResult < String > { Ok (self . inner . change_utc0 . clone () . into ()) } # [getter] fn change_utc8 (& self) -> PyResult < String > { Ok (self . inner . change_utc8 . clone () . into ()) } # [getter] fn total_size (& self) -> PyResult < String > { Ok (self . inner . total_size . clone () . into ()) } # [getter] fn volume_24h (& self) -> PyResult < String > { Ok (self . inner . volume_24h . clone () . into ()) } # [getter] fn volume_24h_btc (& self) -> PyResult < String > { Ok (self . inner . volume_24h_btc . clone () . into ()) } # [getter] fn volume_24h_usd (& self) -> PyResult < String > { Ok (self . inner . volume_24h_usd . clone () . into ()) } # [getter] fn volume_24h_base (& self) -> PyResult < String > { Ok (self . inner . volume_24h_base . clone () . into ()) } # [getter] fn volume_24h_quote (& self) -> PyResult < String > { Ok (self . inner . volume_24h_quote . clone () . into ()) } # [getter] fn volume_24h_settle (& self) -> PyResult < String > { Ok (self . inner . volume_24h_settle . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < String > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn index_price (& self) -> PyResult < String > { Ok (self . inner . index_price . clone () . into ()) } # [getter] fn quanto_base_rate (& self) -> PyResult < String > { Ok (self . inner . quanto_base_rate . clone () . into ()) } # [getter] fn basis_rate (& self) -> PyResult < String > { Ok (self . inner . basis_rate . clone () . into ()) } # [getter] fn basis_value (& self) -> PyResult < String > { Ok (self . inner . basis_value . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_tickers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_tickers () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryRiskLimitTiersRequest { inner : venues :: DeliveryRiskLimitTiersRequest , } # [pymethods] impl DeliveryRiskLimitTiersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_risk_limit_tiers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_risk_limit_tiers () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryContractsRequest { inner : venues :: DeliveryContractsRequest , } # [pymethods] impl DeliveryContractsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryContractRequest { inner : venues :: DeliveryContractRequest , } # [pymethods] impl DeliveryContractRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_contracts <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_contracts () . await }) } fn get_delivery_contract <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_contract () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryTradesRequest { inner : venues :: DeliveryTradesRequest , } # [pymethods] impl DeliveryTradesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn last_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . last_id . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryTrade { inner : venues :: DeliveryTrade , } # [pymethods] impl DeliveryTrade { # [staticmethod] fn from_inner (inner : DeliveryTrade) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < f64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn size (& self) -> PyResult < i64 > { Ok (self . inner . size . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn is_internal (& self) -> PyResult < bool > { Ok (self . inner . is_internal . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryOrderBookRequest { inner : venues :: DeliveryOrderBookRequest , } # [pymethods] impl DeliveryOrderBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . interval . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn with_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . with_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryOrderBookEntry { inner : venues :: DeliveryOrderBookEntry , } # [pymethods] impl DeliveryOrderBookEntry { # [staticmethod] fn from_inner (inner : DeliveryOrderBookEntry) -> Self { Self { inner } } # [getter] fn p (& self) -> PyResult < String > { Ok (self . inner . p . clone () . into ()) } # [getter] fn s (& self) -> PyResult < i64 > { Ok (self . inner . s . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryOrderBook { inner : venues :: DeliveryOrderBook , } # [pymethods] impl DeliveryOrderBook { # [staticmethod] fn from_inner (inner : DeliveryOrderBook) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn current (& self) -> PyResult < f64 > { Ok (self . inner . current . clone () . into ()) } # [getter] fn update (& self) -> PyResult < f64 > { Ok (self . inner . update . clone () . into ()) } # [getter] fn asks (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . asks . clone () . into ()) } # [getter] fn bids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . bids . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_order_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_order_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryCandlesticksRequest { inner : venues :: DeliveryCandlesticksRequest , } # [pymethods] impl DeliveryCandlesticksRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . interval . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_candlesticks <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_candlesticks () . await }) } fn get_delivery_mark_price_candlesticks <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_mark_price_candlesticks () . await }) } fn get_delivery_index_price_candlesticks <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_index_price_candlesticks () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateDeliveryOrderRequest { inner : venues :: CreateDeliveryOrderRequest , } # [pymethods] impl CreateDeliveryOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn size (& self) -> PyResult < i64 > { Ok (self . inner . size . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn tif (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . tif . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } # [getter] fn reduce_only (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reduce_only . clone () . into ()) } # [getter] fn close (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . close . clone () . into ()) } # [getter] fn iceberg (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . iceberg . clone () . into ()) } # [getter] fn auto_size (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . auto_size . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryOrder { inner : venues :: DeliveryOrder , } # [pymethods] impl DeliveryOrder { # [staticmethod] fn from_inner (inner : DeliveryOrder) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn user (& self) -> PyResult < i64 > { Ok (self . inner . user . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < f64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn finish_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . finish_time . clone () . into ()) } # [getter] fn finish_as (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . finish_as . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn size (& self) -> PyResult < i64 > { Ok (self . inner . size . clone () . into ()) } # [getter] fn iceberg (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . iceberg . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn tif (& self) -> PyResult < String > { Ok (self . inner . tif . clone () . into ()) } # [getter] fn left (& self) -> PyResult < i64 > { Ok (self . inner . left . clone () . into ()) } # [getter] fn fill_price (& self) -> PyResult < String > { Ok (self . inner . fill_price . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } # [getter] fn reduce_only (& self) -> PyResult < bool > { Ok (self . inner . reduce_only . clone () . into ()) } # [getter] fn close (& self) -> PyResult < bool > { Ok (self . inner . close . clone () . into ()) } # [getter] fn stp_act (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_act . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ListDeliveryOrdersRequest { inner : venues :: ListDeliveryOrdersRequest , } # [pymethods] impl ListDeliveryOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } } # [pymethods] impl RestClient { fn create_delivery_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_delivery_order () . await }) } fn list_delivery_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_delivery_orders () . await }) } fn get_delivery_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_order () . await }) } fn cancel_all_delivery_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_delivery_orders () . await }) } fn cancel_delivery_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_delivery_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryPositionsRequest { inner : venues :: DeliveryPositionsRequest , } # [pymethods] impl DeliveryPositionsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryPosition { inner : venues :: DeliveryPosition , } # [pymethods] impl DeliveryPosition { # [staticmethod] fn from_inner (inner : DeliveryPosition) -> Self { Self { inner } } # [getter] fn user (& self) -> PyResult < i64 > { Ok (self . inner . user . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn size (& self) -> PyResult < i64 > { Ok (self . inner . size . clone () . into ()) } # [getter] fn entry_price (& self) -> PyResult < String > { Ok (self . inner . entry_price . clone () . into ()) } # [getter] fn mark_price (& self) -> PyResult < String > { Ok (self . inner . mark_price . clone () . into ()) } # [getter] fn realised_pnl (& self) -> PyResult < String > { Ok (self . inner . realised_pnl . clone () . into ()) } # [getter] fn unrealised_pnl (& self) -> PyResult < String > { Ok (self . inner . unrealised_pnl . clone () . into ()) } # [getter] fn margin (& self) -> PyResult < String > { Ok (self . inner . margin . clone () . into ()) } # [getter] fn leverage (& self) -> PyResult < String > { Ok (self . inner . leverage . clone () . into ()) } # [getter] fn risk_limit (& self) -> PyResult < String > { Ok (self . inner . risk_limit . clone () . into ()) } # [getter] fn liq_price (& self) -> PyResult < String > { Ok (self . inner . liq_price . clone () . into ()) } # [getter] fn bankruptcy_price (& self) -> PyResult < String > { Ok (self . inner . bankruptcy_price . clone () . into ()) } # [getter] fn cross_leverage_limit (& self) -> PyResult < String > { Ok (self . inner . cross_leverage_limit . clone () . into ()) } # [getter] fn mode (& self) -> PyResult < String > { Ok (self . inner . mode . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < i64 > { Ok (self . inner . update_time . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SetDeliveryLeverageRequest { inner : venues :: SetDeliveryLeverageRequest , } # [pymethods] impl SetDeliveryLeverageRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn leverage (& self) -> PyResult < String > { Ok (self . inner . leverage . clone () . into ()) } # [getter] fn cross_leverage_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cross_leverage_limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryLeverageResponse { inner : venues :: DeliveryLeverageResponse , } # [pymethods] impl DeliveryLeverageResponse { # [staticmethod] fn from_inner (inner : DeliveryLeverageResponse) -> Self { Self { inner } } # [getter] fn leverage (& self) -> PyResult < String > { Ok (self . inner . leverage . clone () . into ()) } # [getter] fn cross_leverage_limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . cross_leverage_limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UpdateDeliveryPositionMarginRequest { inner : venues :: UpdateDeliveryPositionMarginRequest , } # [pymethods] impl UpdateDeliveryPositionMarginRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn change (& self) -> PyResult < String > { Ok (self . inner . change . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryPositionMarginResponse { inner : venues :: DeliveryPositionMarginResponse , } # [pymethods] impl DeliveryPositionMarginResponse { # [staticmethod] fn from_inner (inner : DeliveryPositionMarginResponse) -> Self { Self { inner } } # [getter] fn margin (& self) -> PyResult < String > { Ok (self . inner . margin . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct UpdateDeliveryRiskLimitRequest { inner : venues :: UpdateDeliveryRiskLimitRequest , } # [pymethods] impl UpdateDeliveryRiskLimitRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn risk_limit (& self) -> PyResult < String > { Ok (self . inner . risk_limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryRiskLimitResponse { inner : venues :: DeliveryRiskLimitResponse , } # [pymethods] impl DeliveryRiskLimitResponse { # [staticmethod] fn from_inner (inner : DeliveryRiskLimitResponse) -> Self { Self { inner } } # [getter] fn risk_limit (& self) -> PyResult < String > { Ok (self . inner . risk_limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_positions <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_positions () . await }) } fn get_delivery_position <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_position () . await }) } fn set_delivery_position_leverage <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . set_delivery_position_leverage () . await }) } fn update_delivery_position_margin <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . update_delivery_position_margin () . await }) } fn update_delivery_position_risk_limit <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . update_delivery_position_risk_limit () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn base_url (& self) -> PyResult < () > { self . inner . base_url () ; Ok (()) } fn get <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get () . await }) } fn get_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_with_query () . await }) } fn post <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . post () . await }) } fn put <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . put () . await }) } fn delete <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . delete () . await }) } fn delete_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . delete_with_query () . await }) } fn patch <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . patch () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryAccountBookRequest { inner : venues :: DeliveryAccountBookRequest , } # [pymethods] impl DeliveryAccountBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn type_ (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . type_ . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryAccountBookEntry { inner : venues :: DeliveryAccountBookEntry , } # [pymethods] impl DeliveryAccountBookEntry { # [staticmethod] fn from_inner (inner : DeliveryAccountBookEntry) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn time (& self) -> PyResult < f64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn change (& self) -> PyResult < String > { Ok (self . inner . change . clone () . into ()) } # [getter] fn balance (& self) -> PyResult < String > { Ok (self . inner . balance . clone () . into ()) } # [getter] fn entry_type (& self) -> PyResult < String > { Ok (self . inner . entry_type . clone () . into ()) } # [getter] fn text (& self) -> PyResult < String > { Ok (self . inner . text . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_account_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_account_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryAccountsRequest { inner : venues :: DeliveryAccountsRequest , } # [pymethods] impl DeliveryAccountsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryAccount { inner : venues :: DeliveryAccount , } # [pymethods] impl DeliveryAccount { # [staticmethod] fn from_inner (inner : DeliveryAccount) -> Self { Self { inner } } # [getter] fn total (& self) -> PyResult < String > { Ok (self . inner . total . clone () . into ()) } # [getter] fn unrealised_pnl (& self) -> PyResult < String > { Ok (self . inner . unrealised_pnl . clone () . into ()) } # [getter] fn position_margin (& self) -> PyResult < String > { Ok (self . inner . position_margin . clone () . into ()) } # [getter] fn order_margin (& self) -> PyResult < String > { Ok (self . inner . order_margin . clone () . into ()) } # [getter] fn available (& self) -> PyResult < String > { Ok (self . inner . available . clone () . into ()) } # [getter] fn point (& self) -> PyResult < String > { Ok (self . inner . point . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn enable_credit (& self) -> PyResult < bool > { Ok (self . inner . enable_credit . clone () . into ()) } # [getter] fn position_cross_margin (& self) -> PyResult < String > { Ok (self . inner . position_cross_margin . clone () . into ()) } # [getter] fn order_cross_margin (& self) -> PyResult < String > { Ok (self . inner . order_cross_margin . clone () . into ()) } # [getter] fn available_cross_margin (& self) -> PyResult < String > { Ok (self . inner . available_cross_margin . clone () . into ()) } # [getter] fn total_cross_margin (& self) -> PyResult < String > { Ok (self . inner . total_cross_margin . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_accounts <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_accounts () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryPositionCloseHistoryRequest { inner : venues :: DeliveryPositionCloseHistoryRequest , } # [pymethods] impl DeliveryPositionCloseHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn side (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . side . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryPositionClose { inner : venues :: DeliveryPositionClose , } # [pymethods] impl DeliveryPositionClose { # [staticmethod] fn from_inner (inner : DeliveryPositionClose) -> Self { Self { inner } } # [getter] fn time (& self) -> PyResult < f64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn pnl (& self) -> PyResult < String > { Ok (self . inner . pnl . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < String > { Ok (self . inner . contract . clone () . into ()) } # [getter] fn text (& self) -> PyResult < String > { Ok (self . inner . text . clone () . into ()) } # [getter] fn max_size (& self) -> PyResult < i64 > { Ok (self . inner . max_size . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_position_close_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_position_close_history () . await }) } } # [pymethods] impl RestClient { fn get_delivery_settlements <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_settlements () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateDeliveryPriceOrderRequest { inner : venues :: CreateDeliveryPriceOrderRequest , } # [pymethods] impl CreateDeliveryPriceOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn initial (& self) -> PyResult < PyObject > { Ok (self . inner . initial . clone () . into ()) } # [getter] fn trigger (& self) -> PyResult < PyObject > { Ok (self . inner . trigger . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ListDeliveryPriceOrdersRequest { inner : venues :: ListDeliveryPriceOrdersRequest , } # [pymethods] impl ListDeliveryPriceOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DeliveryPriceOrder { inner : venues :: DeliveryPriceOrder , } # [pymethods] impl DeliveryPriceOrder { # [staticmethod] fn from_inner (inner : DeliveryPriceOrder) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn user (& self) -> PyResult < i64 > { Ok (self . inner . user . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < f64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn finish_time (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . finish_time . clone () . into ()) } # [getter] fn trade_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . trade_id . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn initial (& self) -> PyResult < PyObject > { Ok (self . inner . initial . clone () . into ()) } # [getter] fn trigger (& self) -> PyResult < PyObject > { Ok (self . inner . trigger . clone () . into ()) } # [getter] fn reason (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reason . clone () . into ()) } } # [pymethods] impl RestClient { fn create_delivery_price_triggered_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_delivery_price_triggered_order () . await }) } fn list_delivery_price_triggered_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_delivery_price_triggered_orders () . await }) } fn get_delivery_price_triggered_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_price_triggered_order () . await }) } fn cancel_delivery_price_triggered_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_delivery_price_triggered_order () . await }) } fn cancel_all_delivery_price_triggered_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_delivery_price_triggered_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryMyTradesRequest { inner : venues :: DeliveryMyTradesRequest , } # [pymethods] impl DeliveryMyTradesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn order (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } # [getter] fn last_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . last_id . clone () . into ()) } # [getter] fn count_total (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . count_total . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_my_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_my_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct DeliveryLiquidationHistoryRequest { inner : venues :: DeliveryLiquidationHistoryRequest , } # [pymethods] impl DeliveryLiquidationHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn settle (& self) -> PyResult < String > { Ok (self . inner . settle . clone () . into ()) } # [getter] fn contract (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . contract . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_delivery_liquidation_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_delivery_liquidation_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestResponse { inner : venues :: RestResponse , } # [pymethods] impl RestResponse { # [staticmethod] fn from_inner (inner : RestResponse) -> Self { Self { inner } } # [getter] fn code (& self) -> PyResult < String > { Ok (self . inner . code . clone () . into ()) } # [getter] fn data (& self) -> PyResult < PyObject > { Ok (self . inner . data . clone () . into ()) } } # [pymethods] impl RestClient { fn get_currency <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_currency () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn base_url (& self) -> PyResult < () > { self . inner . base_url () ; Ok (()) } fn get <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get () . await }) } fn get_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_with_query () . await }) } } # [pyclass] # [derive (Clone)] pub struct InsuranceHistoryRequest { inner : venues :: InsuranceHistoryRequest , } # [pymethods] impl InsuranceHistoryRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn get_insurance_history <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_insurance_history () . await }) } } # [pyclass] # [derive (Clone)] pub struct TickersRequest { inner : venues :: TickersRequest , } # [pymethods] impl TickersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn timezone (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . timezone . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct Ticker { inner : venues :: Ticker , } # [pymethods] impl Ticker { # [staticmethod] fn from_inner (inner : Ticker) -> Self { Self { inner } } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn last (& self) -> PyResult < String > { Ok (self . inner . last . clone () . into ()) } # [getter] fn lowest_ask (& self) -> PyResult < String > { Ok (self . inner . lowest_ask . clone () . into ()) } # [getter] fn highest_bid (& self) -> PyResult < String > { Ok (self . inner . highest_bid . clone () . into ()) } # [getter] fn change_percentage (& self) -> PyResult < String > { Ok (self . inner . change_percentage . clone () . into ()) } # [getter] fn change_utc0 (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . change_utc0 . clone () . into ()) } # [getter] fn change_utc8 (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . change_utc8 . clone () . into ()) } # [getter] fn base_volume (& self) -> PyResult < String > { Ok (self . inner . base_volume . clone () . into ()) } # [getter] fn quote_volume (& self) -> PyResult < String > { Ok (self . inner . quote_volume . clone () . into ()) } # [getter] fn high_24h (& self) -> PyResult < String > { Ok (self . inner . high_24h . clone () . into ()) } # [getter] fn low_24h (& self) -> PyResult < String > { Ok (self . inner . low_24h . clone () . into ()) } # [getter] fn etf_net_value (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . etf_net_value . clone () . into ()) } # [getter] fn etf_pre_net_value (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . etf_pre_net_value . clone () . into ()) } # [getter] fn etf_pre_timestamp (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . etf_pre_timestamp . clone () . into ()) } # [getter] fn etf_leverage (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . etf_leverage . clone () . into ()) } } # [pymethods] impl RestClient { fn get_tickers <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_tickers () . await }) } } # [pymethods] impl RestClient { fn list_currency_pairs <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_currency_pairs () . await }) } } # [pymethods] impl RestClient { fn get_currency_pair <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_currency_pair () . await }) } } # [pyclass] # [derive (Clone)] pub struct TradingFeeRequest { inner : venues :: TradingFeeRequest , } # [pymethods] impl TradingFeeRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } } # [pymethods] impl RestClient { fn get_trading_fee <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_trading_fee () . await }) } fn get_batch_trading_fee <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_batch_trading_fee () . await }) } } # [pymethods] impl RestClient { fn get_server_time <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_server_time () . await }) } } # [pymethods] impl RestClient { fn list_currencies <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_currencies () . await }) } } # [pyclass] # [derive (Clone)] pub struct TradesRequest { inner : venues :: TradesRequest , } # [pymethods] impl TradesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct Trade { inner : venues :: Trade , } # [pymethods] impl Trade { # [staticmethod] fn from_inner (inner : Trade) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < String > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn create_time_ms (& self) -> PyResult < String > { Ok (self . inner . create_time_ms . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn role (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . role . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . fee . clone () . into ()) } # [getter] fn fee_currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . fee_currency . clone () . into ()) } # [getter] fn point_fee (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . point_fee . clone () . into ()) } # [getter] fn gt_fee (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . gt_fee . clone () . into ()) } } # [pymethods] impl RestClient { fn get_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct OrderBookRequest { inner : venues :: OrderBookRequest , } # [pymethods] impl OrderBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn with_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . with_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderBookEntry { inner : venues :: OrderBookEntry , } # [pymethods] impl OrderBookEntry { # [staticmethod] fn from_inner (inner : OrderBookEntry) -> Self { Self { inner } } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OrderBook { inner : venues :: OrderBook , } # [pymethods] impl OrderBook { # [staticmethod] fn from_inner (inner : OrderBook) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . id . clone () . into ()) } # [getter] fn current (& self) -> PyResult < i64 > { Ok (self . inner . current . clone () . into ()) } # [getter] fn update (& self) -> PyResult < i64 > { Ok (self . inner . update . clone () . into ()) } # [getter] fn asks (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . asks . clone () . into ()) } # [getter] fn bids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . bids . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct CandlesticksRequest { inner : venues :: CandlesticksRequest , } # [pymethods] impl CandlesticksRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn interval (& self) -> PyResult < PyObject > { Ok (self . inner . interval . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } } # [pymethods] impl RestClient { fn get_candlesticks <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_candlesticks () . await }) } } # [pyclass] # [derive (Clone)] pub struct AmendOrderRequest { inner : venues :: AmendOrderRequest , } # [pymethods] impl AmendOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . amount . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn amend_text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . amend_text . clone () . into ()) } } # [pymethods] impl RestClient { fn amend_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . amend_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct FundingAccountsRequest { inner : venues :: FundingAccountsRequest , } # [pymethods] impl FundingAccountsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct FundingAccount { inner : venues :: FundingAccount , } # [pymethods] impl FundingAccount { # [staticmethod] fn from_inner (inner : FundingAccount) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn available (& self) -> PyResult < String > { Ok (self . inner . available . clone () . into ()) } # [getter] fn locked (& self) -> PyResult < String > { Ok (self . inner . locked . clone () . into ()) } # [getter] fn lent (& self) -> PyResult < String > { Ok (self . inner . lent . clone () . into ()) } # [getter] fn total_lent (& self) -> PyResult < String > { Ok (self . inner . total_lent . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TransferableRequest { inner : venues :: TransferableRequest , } # [pymethods] impl TransferableRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BorrowableRequest { inner : venues :: BorrowableRequest , } # [pymethods] impl BorrowableRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AutoRepayRequest { inner : venues :: AutoRepayRequest , } # [pymethods] impl AutoRepayRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } } # [pymethods] impl RestClient { fn get_funding_accounts <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_funding_accounts () . await }) } fn get_transferable <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_transferable () . await }) } fn get_borrowable <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_borrowable () . await }) } fn get_auto_repay <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_auto_repay () . await }) } fn update_auto_repay <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . update_auto_repay () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetOrderRequest { inner : venues :: GetOrderRequest , } # [pymethods] impl GetOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn account (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . account . clone () . into ()) } } # [pymethods] impl RestClient { fn get_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct ListLoansRequest { inner : venues :: ListLoansRequest , } # [pymethods] impl ListLoansRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn side (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . side . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn sort_by (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . sort_by . clone () . into ()) } # [getter] fn reverse_sort (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reverse_sort . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateLoanRequest { inner : venues :: CreateLoanRequest , } # [pymethods] impl CreateLoanRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn rate (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . rate . clone () . into ()) } # [getter] fn days (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . days . clone () . into ()) } # [getter] fn auto_renew (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . auto_renew . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct ModifyLoanRequest { inner : venues :: ModifyLoanRequest , } # [pymethods] impl ModifyLoanRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . amount . clone () . into ()) } # [getter] fn rate (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . rate . clone () . into ()) } # [getter] fn auto_renew (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . auto_renew . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RepayLoanRequest { inner : venues :: RepayLoanRequest , } # [pymethods] impl RepayLoanRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn mode (& self) -> PyResult < String > { Ok (self . inner . mode . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . amount . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct RepaymentRecordsRequest { inner : venues :: RepaymentRecordsRequest , } # [pymethods] impl RepaymentRecordsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn loan_id (& self) -> PyResult < String > { Ok (self . inner . loan_id . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct LoanRecordsRequest { inner : venues :: LoanRecordsRequest , } # [pymethods] impl LoanRecordsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn loan_record_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . loan_record_id . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pymethods] impl RestClient { fn list_margin_loans <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_margin_loans () . await }) } fn get_loan <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_loan () . await }) } fn create_loan <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_loan () . await }) } fn modify_loan <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . modify_loan () . await }) } fn cancel_loan <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_loan () . await }) } fn repay_loan <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . repay_loan () . await }) } fn get_repayment_records <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_repayment_records () . await }) } fn get_loan_records <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_loan_records () . await }) } fn get_loan_record <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_loan_record () . await }) } fn modify_loan_record <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . modify_loan_record () . await }) } } # [pyclass] # [derive (Clone)] pub struct RestClient { inner : venues :: RestClient , } # [pymethods] impl RestClient { # [staticmethod] fn from_inner (inner : RestClient) -> Self { Self { inner } } } # [pymethods] impl RestClient { fn base_url (& self) -> PyResult < () > { self . inner . base_url () ; Ok (()) } fn get <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get () . await }) } fn get_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_with_query () . await }) } fn post <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . post () . await }) } fn put <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . put () . await }) } fn delete <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . delete () . await }) } fn delete_with_query <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . delete_with_query () . await }) } fn patch <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . patch () . await }) } } # [pyclass] # [derive (Clone)] pub struct ListOpenOrdersRequest { inner : venues :: ListOpenOrdersRequest , } # [pymethods] impl ListOpenOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn side (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . side . clone () . into ()) } # [getter] fn account (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . account . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct OpenOrder { inner : venues :: OpenOrder , } # [pymethods] impl OpenOrder { # [staticmethod] fn from_inner (inner : OpenOrder) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn account (& self) -> PyResult < String > { Ok (self . inner . account . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < String > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn filled_amount (& self) -> PyResult < String > { Ok (self . inner . filled_amount . clone () . into ()) } # [getter] fn left (& self) -> PyResult < String > { Ok (self . inner . left . clone () . into ()) } # [getter] fn avg_deal_price (& self) -> PyResult < String > { Ok (self . inner . avg_deal_price . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < String > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn fee_currency (& self) -> PyResult < String > { Ok (self . inner . fee_currency . clone () . into ()) } # [getter] fn points_fee (& self) -> PyResult < String > { Ok (self . inner . points_fee . clone () . into ()) } # [getter] fn gt_fee (& self) -> PyResult < String > { Ok (self . inner . gt_fee . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < String > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < String > { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } # [getter] fn iceberg (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . iceberg . clone () . into ()) } # [getter] fn auto_borrow (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . auto_borrow . clone () . into ()) } # [getter] fn auto_repay (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . auto_repay . clone () . into ()) } # [getter] fn stp_act (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_act . clone () . into ()) } # [getter] fn finish_as (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . finish_as . clone () . into ()) } } # [pymethods] impl RestClient { fn list_open_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_open_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetAccountBookRequest { inner : venues :: GetAccountBookRequest , } # [pymethods] impl GetAccountBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn record_type (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . record_type . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AccountBookEntry { inner : venues :: AccountBookEntry , } # [pymethods] impl AccountBookEntry { # [staticmethod] fn from_inner (inner : AccountBookEntry) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn time (& self) -> PyResult < i64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn change (& self) -> PyResult < String > { Ok (self . inner . change . clone () . into ()) } # [getter] fn balance (& self) -> PyResult < String > { Ok (self . inner . balance . clone () . into ()) } # [getter] fn entry_type (& self) -> PyResult < String > { Ok (self . inner . entry_type . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } } # [pymethods] impl RestClient { fn get_account_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_account_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelAllOrdersRequest { inner : venues :: CancelAllOrdersRequest , } # [pymethods] impl CancelAllOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn side (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . side . clone () . into ()) } # [getter] fn account (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . account . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_all_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_orders () . await }) } fn cancel_all_orders_for_pair <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_orders_for_pair () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateOrderRequest { inner : venues :: CreateOrderRequest , } # [pymethods] impl CreateOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn account (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . account . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn iceberg (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . iceberg . clone () . into ()) } # [getter] fn stp_mode (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_mode . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct Order { inner : venues :: Order , } # [pymethods] impl Order { # [staticmethod] fn from_inner (inner : Order) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn text (& self) -> PyResult < String > { Ok (self . inner . text . clone () . into ()) } # [getter] fn amend_text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . amend_text . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < String > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < String > { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn status (& self) -> PyResult < PyObject > { Ok (self . inner . status . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < PyObject > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn account (& self) -> PyResult < String > { Ok (self . inner . account . clone () . into ()) } # [getter] fn side (& self) -> PyResult < PyObject > { Ok (self . inner . side . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < PyObject > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn iceberg (& self) -> PyResult < String > { Ok (self . inner . iceberg . clone () . into ()) } # [getter] fn left (& self) -> PyResult < String > { Ok (self . inner . left . clone () . into ()) } # [getter] fn filled_amount (& self) -> PyResult < String > { Ok (self . inner . filled_amount . clone () . into ()) } # [getter] fn fill_price (& self) -> PyResult < String > { Ok (self . inner . fill_price . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < String > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn fee_currency (& self) -> PyResult < String > { Ok (self . inner . fee_currency . clone () . into ()) } # [getter] fn point_fee (& self) -> PyResult < String > { Ok (self . inner . point_fee . clone () . into ()) } # [getter] fn gt_fee (& self) -> PyResult < String > { Ok (self . inner . gt_fee . clone () . into ()) } # [getter] fn gt_discount (& self) -> PyResult < bool > { Ok (self . inner . gt_discount . clone () . into ()) } # [getter] fn rebated_fee (& self) -> PyResult < String > { Ok (self . inner . rebated_fee . clone () . into ()) } # [getter] fn rebated_fee_currency (& self) -> PyResult < String > { Ok (self . inner . rebated_fee_currency . clone () . into ()) } # [getter] fn stp_mode (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_mode . clone () . into ()) } # [getter] fn stp_act (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . stp_act . clone () . into ()) } } # [pymethods] impl RestClient { fn create_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct CountdownCancelAllRequest { inner : venues :: CountdownCancelAllRequest , } # [pymethods] impl CountdownCancelAllRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn timeout (& self) -> PyResult < u64 > { Ok (self . inner . timeout . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CountdownCancelAllResponse { inner : venues :: CountdownCancelAllResponse , } # [pymethods] impl CountdownCancelAllResponse { # [staticmethod] fn from_inner (inner : CountdownCancelAllResponse) -> Self { Self { inner } } # [getter] fn trigger_time (& self) -> PyResult < i64 > { Ok (self . inner . trigger_time . clone () . into ()) } } # [pymethods] impl RestClient { fn countdown_cancel_all <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . countdown_cancel_all () . await }) } } # [pyclass] # [derive (Clone)] pub struct GetMyTradesRequest { inner : venues :: GetMyTradesRequest , } # [pymethods] impl GetMyTradesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn account (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . account . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct MyTrade { inner : venues :: MyTrade , } # [pymethods] impl MyTrade { # [staticmethod] fn from_inner (inner : MyTrade) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < String > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn create_time_ms (& self) -> PyResult < String > { Ok (self . inner . create_time_ms . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn order_id (& self) -> PyResult < String > { Ok (self . inner . order_id . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn role (& self) -> PyResult < String > { Ok (self . inner . role . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < String > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn fee_currency (& self) -> PyResult < String > { Ok (self . inner . fee_currency . clone () . into ()) } # [getter] fn point_fee (& self) -> PyResult < String > { Ok (self . inner . point_fee . clone () . into ()) } # [getter] fn gt_fee (& self) -> PyResult < String > { Ok (self . inner . gt_fee . clone () . into ()) } # [getter] fn gt_fee_deduction (& self) -> PyResult < bool > { Ok (self . inner . gt_fee_deduction . clone () . into ()) } # [getter] fn rebated_fee (& self) -> PyResult < String > { Ok (self . inner . rebated_fee . clone () . into ()) } # [getter] fn rebated_fee_currency (& self) -> PyResult < String > { Ok (self . inner . rebated_fee_currency . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } } # [pymethods] impl RestClient { fn get_my_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_my_trades () . await }) } fn get_my_trades_for_pair <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_my_trades_for_pair () . await }) } fn get_order_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_order_trades () . await }) } fn get_my_trades_in_range <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_my_trades_in_range () . await }) } fn get_recent_my_trades <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_recent_my_trades () . await }) } } # [pyclass] # [derive (Clone)] pub struct AmendOrderRequest { inner : venues :: AmendOrderRequest , } # [pymethods] impl AmendOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . amount . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn account (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . account . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AmendBatchOrdersRequest { inner : venues :: AmendBatchOrdersRequest , } # [pymethods] impl AmendBatchOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn orders (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . orders . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct AmendedOrder { inner : venues :: AmendedOrder , } # [pymethods] impl AmendedOrder { # [staticmethod] fn from_inner (inner : AmendedOrder) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn account (& self) -> PyResult < String > { Ok (self . inner . account . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < String > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn filled_amount (& self) -> PyResult < String > { Ok (self . inner . filled_amount . clone () . into ()) } # [getter] fn left (& self) -> PyResult < String > { Ok (self . inner . left . clone () . into ()) } # [getter] fn avg_deal_price (& self) -> PyResult < String > { Ok (self . inner . avg_deal_price . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < String > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn fee_currency (& self) -> PyResult < String > { Ok (self . inner . fee_currency . clone () . into ()) } # [getter] fn points_fee (& self) -> PyResult < String > { Ok (self . inner . points_fee . clone () . into ()) } # [getter] fn gt_fee (& self) -> PyResult < String > { Ok (self . inner . gt_fee . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < String > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < String > { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } # [getter] fn succeeded (& self) -> PyResult < bool > { Ok (self . inner . succeeded . clone () . into ()) } # [getter] fn message (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . message . clone () . into ()) } # [getter] fn code (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . code . clone () . into ()) } } # [pymethods] impl RestClient { fn amend_batch_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . amend_batch_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct MarginAccountsRequest { inner : venues :: MarginAccountsRequest , } # [pymethods] impl MarginAccountsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct MarginAccount { inner : venues :: MarginAccount , } # [pymethods] impl MarginAccount { # [staticmethod] fn from_inner (inner : MarginAccount) -> Self { Self { inner } } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn locked (& self) -> PyResult < bool > { Ok (self . inner . locked . clone () . into ()) } # [getter] fn risk (& self) -> PyResult < String > { Ok (self . inner . risk . clone () . into ()) } # [getter] fn base (& self) -> PyResult < PyObject > { Ok (self . inner . base . clone () . into ()) } # [getter] fn quote (& self) -> PyResult < PyObject > { Ok (self . inner . quote . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct MarginBalance { inner : venues :: MarginBalance , } # [pymethods] impl MarginBalance { # [staticmethod] fn from_inner (inner : MarginBalance) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn available (& self) -> PyResult < String > { Ok (self . inner . available . clone () . into ()) } # [getter] fn locked (& self) -> PyResult < String > { Ok (self . inner . locked . clone () . into ()) } # [getter] fn borrowed (& self) -> PyResult < String > { Ok (self . inner . borrowed . clone () . into ()) } # [getter] fn interest (& self) -> PyResult < String > { Ok (self . inner . interest . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct MarginAccountBookRequest { inner : venues :: MarginAccountBookRequest , } # [pymethods] impl MarginAccountBookRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct MarginAccountBookEntry { inner : venues :: MarginAccountBookEntry , } # [pymethods] impl MarginAccountBookEntry { # [staticmethod] fn from_inner (inner : MarginAccountBookEntry) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn time (& self) -> PyResult < i64 > { Ok (self . inner . time . clone () . into ()) } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn change (& self) -> PyResult < String > { Ok (self . inner . change . clone () . into ()) } # [getter] fn balance (& self) -> PyResult < String > { Ok (self . inner . balance . clone () . into ()) } # [getter] fn change_type (& self) -> PyResult < String > { Ok (self . inner . change_type . clone () . into ()) } # [getter] fn account (& self) -> PyResult < String > { Ok (self . inner . account . clone () . into ()) } # [getter] fn detail (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . detail . clone () . into ()) } } # [pymethods] impl RestClient { fn get_margin_accounts <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_margin_accounts () . await }) } fn get_margin_account_book <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_margin_account_book () . await }) } } # [pyclass] # [derive (Clone)] pub struct CreateBatchOrdersRequest { inner : venues :: CreateBatchOrdersRequest , } # [pymethods] impl CreateBatchOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn orders (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . orders . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct BatchOrderResponse { inner : venues :: BatchOrderResponse , } # [pymethods] impl BatchOrderResponse { # [staticmethod] fn from_inner (inner : BatchOrderResponse) -> Self { Self { inner } } # [getter] fn succeeded (& self) -> PyResult < bool > { Ok (self . inner . succeeded . clone () . into ()) } # [getter] fn order (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . order . clone () . into ()) } # [getter] fn message (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . message . clone () . into ()) } } # [pymethods] impl RestClient { fn create_batch_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_batch_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelOrderRequest { inner : venues :: CancelOrderRequest , } # [pymethods] impl CancelOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn account (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . account . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_order () . await }) } } # [pymethods] impl RestClient { fn get_spot_account_balance <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_spot_account_balance () . await }) } } # [pyclass] # [derive (Clone)] pub struct TotalBalanceRequest { inner : venues :: TotalBalanceRequest , } # [pymethods] impl TotalBalanceRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TotalBalance { inner : venues :: TotalBalance , } # [pymethods] impl TotalBalance { # [staticmethod] fn from_inner (inner : TotalBalance) -> Self { Self { inner } } # [getter] fn details (& self) -> PyResult < PyObject > { Ok (self . inner . details . clone () . into ()) } # [getter] fn total (& self) -> PyResult < PyObject > { Ok (self . inner . total . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CurrencyBalance { inner : venues :: CurrencyBalance , } # [pymethods] impl CurrencyBalance { # [staticmethod] fn from_inner (inner : CurrencyBalance) -> Self { Self { inner } } # [getter] fn available (& self) -> PyResult < String > { Ok (self . inner . available . clone () . into ()) } # [getter] fn unrealised_pnl (& self) -> PyResult < String > { Ok (self . inner . unrealised_pnl . clone () . into ()) } # [getter] fn borrowed (& self) -> PyResult < String > { Ok (self . inner . borrowed . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct TotalBalanceValue { inner : venues :: TotalBalanceValue , } # [pymethods] impl TotalBalanceValue { # [staticmethod] fn from_inner (inner : TotalBalanceValue) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DepositAddressRequest { inner : venues :: DepositAddressRequest , } # [pymethods] impl DepositAddressRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct DepositsRequest { inner : venues :: DepositsRequest , } # [pymethods] impl DepositsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct WithdrawalsRequest { inner : venues :: WithdrawalsRequest , } # [pymethods] impl WithdrawalsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn offset (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . offset . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreateTransferRequest { inner : venues :: CreateTransferRequest , } # [pymethods] impl CreateTransferRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn from (& self) -> PyResult < String > { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < String > { Ok (self . inner . to . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn settle (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . settle . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct WithdrawalFeesRequest { inner : venues :: WithdrawalFeesRequest , } # [pymethods] impl WithdrawalFeesRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } } # [pymethods] impl RestClient { fn get_total_balance <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_total_balance () . await }) } fn get_deposit_address <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_deposit_address () . await }) } fn get_deposits <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_deposits () . await }) } fn get_withdrawals <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_withdrawals () . await }) } fn create_transfer <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_transfer () . await }) } fn get_withdrawal_fees <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_withdrawal_fees () . await }) } } # [pyclass] # [derive (Clone)] pub struct CancelBatchOrdersRequest { inner : venues :: CancelBatchOrdersRequest , } # [pymethods] impl CancelBatchOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn order_ids (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . order_ids . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelBatchOrdersResponse { inner : venues :: CancelBatchOrdersResponse , } # [pymethods] impl CancelBatchOrdersResponse { # [staticmethod] fn from_inner (inner : CancelBatchOrdersResponse) -> Self { Self { inner } } # [getter] fn succeeded (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . succeeded . clone () . into ()) } # [getter] fn failed (& self) -> PyResult < Vec < PyObject >> { Ok (self . inner . failed . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CancelBatchOrderError { inner : venues :: CancelBatchOrderError , } # [pymethods] impl CancelBatchOrderError { # [staticmethod] fn from_inner (inner : CancelBatchOrderError) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn message (& self) -> PyResult < String > { Ok (self . inner . message . clone () . into ()) } # [getter] fn code (& self) -> PyResult < String > { Ok (self . inner . code . clone () . into ()) } } # [pymethods] impl RestClient { fn cancel_batch_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_batch_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct ListPriceOrdersRequest { inner : venues :: ListPriceOrdersRequest , } # [pymethods] impl ListPriceOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CreatePriceOrderRequest { inner : venues :: CreatePriceOrderRequest , } # [pymethods] impl CreatePriceOrderRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn account (& self) -> PyResult < String > { Ok (self . inner . account . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn price (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . price . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < String > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } # [getter] fn trigger_price (& self) -> PyResult < String > { Ok (self . inner . trigger_price . clone () . into ()) } # [getter] fn rule (& self) -> PyResult < String > { Ok (self . inner . rule . clone () . into ()) } # [getter] fn expiration (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . expiration . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct PriceOrder { inner : venues :: PriceOrder , } # [pymethods] impl PriceOrder { # [staticmethod] fn from_inner (inner : PriceOrder) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < i64 > { Ok (self . inner . id . clone () . into ()) } # [getter] fn user (& self) -> PyResult < i64 > { Ok (self . inner . user . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn account (& self) -> PyResult < String > { Ok (self . inner . account . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < String > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn trigger_price (& self) -> PyResult < String > { Ok (self . inner . trigger_price . clone () . into ()) } # [getter] fn rule (& self) -> PyResult < String > { Ok (self . inner . rule . clone () . into ()) } # [getter] fn expiration (& self) -> PyResult < i64 > { Ok (self . inner . expiration . clone () . into ()) } # [getter] fn fired_order_id (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . fired_order_id . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < i64 > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn put_time (& self) -> PyResult < i64 > { Ok (self . inner . put_time . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } # [getter] fn reason (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . reason . clone () . into ()) } } # [pymethods] impl RestClient { fn list_price_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_price_orders () . await }) } fn get_price_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_price_order () . await }) } fn create_price_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . create_price_order () . await }) } fn cancel_all_price_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_all_price_orders () . await }) } fn cancel_price_order <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cancel_price_order () . await }) } } # [pyclass] # [derive (Clone)] pub struct ListOrdersRequest { inner : venues :: ListOrdersRequest , } # [pymethods] impl ListOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn status (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . status . clone () . into ()) } # [getter] fn page (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . page . clone () . into ()) } # [getter] fn limit (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . limit . clone () . into ()) } # [getter] fn account (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . account . clone () . into ()) } # [getter] fn from (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . from . clone () . into ()) } # [getter] fn to (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . to . clone () . into ()) } # [getter] fn side (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . side . clone () . into ()) } } # [pymethods] impl RestClient { fn list_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct CrossLiquidateOrdersRequest { inner : venues :: CrossLiquidateOrdersRequest , } # [pymethods] impl CrossLiquidateOrdersRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn liquidation_type (& self) -> PyResult < String > { Ok (self . inner . liquidation_type . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct CrossLiquidateOrder { inner : venues :: CrossLiquidateOrder , } # [pymethods] impl CrossLiquidateOrder { # [staticmethod] fn from_inner (inner : CrossLiquidateOrder) -> Self { Self { inner } } # [getter] fn id (& self) -> PyResult < String > { Ok (self . inner . id . clone () . into ()) } # [getter] fn currency_pair (& self) -> PyResult < String > { Ok (self . inner . currency_pair . clone () . into ()) } # [getter] fn status (& self) -> PyResult < String > { Ok (self . inner . status . clone () . into ()) } # [getter] fn account (& self) -> PyResult < String > { Ok (self . inner . account . clone () . into ()) } # [getter] fn side (& self) -> PyResult < String > { Ok (self . inner . side . clone () . into ()) } # [getter] fn amount (& self) -> PyResult < String > { Ok (self . inner . amount . clone () . into ()) } # [getter] fn price (& self) -> PyResult < String > { Ok (self . inner . price . clone () . into ()) } # [getter] fn order_type (& self) -> PyResult < String > { Ok (self . inner . order_type . clone () . into ()) } # [getter] fn time_in_force (& self) -> PyResult < String > { Ok (self . inner . time_in_force . clone () . into ()) } # [getter] fn filled_amount (& self) -> PyResult < String > { Ok (self . inner . filled_amount . clone () . into ()) } # [getter] fn left (& self) -> PyResult < String > { Ok (self . inner . left . clone () . into ()) } # [getter] fn avg_deal_price (& self) -> PyResult < String > { Ok (self . inner . avg_deal_price . clone () . into ()) } # [getter] fn fee (& self) -> PyResult < String > { Ok (self . inner . fee . clone () . into ()) } # [getter] fn fee_currency (& self) -> PyResult < String > { Ok (self . inner . fee_currency . clone () . into ()) } # [getter] fn points_fee (& self) -> PyResult < String > { Ok (self . inner . points_fee . clone () . into ()) } # [getter] fn gt_fee (& self) -> PyResult < String > { Ok (self . inner . gt_fee . clone () . into ()) } # [getter] fn create_time (& self) -> PyResult < String > { Ok (self . inner . create_time . clone () . into ()) } # [getter] fn update_time (& self) -> PyResult < String > { Ok (self . inner . update_time . clone () . into ()) } # [getter] fn text (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . text . clone () . into ()) } } # [pymethods] impl RestClient { fn cross_liquidate_orders <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . cross_liquidate_orders () . await }) } } # [pyclass] # [derive (Clone)] pub struct ListSpotAccountsRequest { inner : venues :: ListSpotAccountsRequest , } # [pymethods] impl ListSpotAccountsRequest { # [new] fn new () -> Self { Self { inner : Default :: default () } } # [getter] fn currency (& self) -> PyResult < Option < PyObject >> { Ok (self . inner . currency . clone () . into ()) } } # [pyclass] # [derive (Clone)] pub struct SpotAccount { inner : venues :: SpotAccount , } # [pymethods] impl SpotAccount { # [staticmethod] fn from_inner (inner : SpotAccount) -> Self { Self { inner } } # [getter] fn currency (& self) -> PyResult < String > { Ok (self . inner . currency . clone () . into ()) } # [getter] fn available (& self) -> PyResult < String > { Ok (self . inner . available . clone () . into ()) } # [getter] fn locked (& self) -> PyResult < String > { Ok (self . inner . locked . clone () . into ()) } } # [pymethods] impl RestClient { fn list_spot_accounts <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . list_spot_accounts () . await }) } } # [pymethods] impl RestClient { fn get_non_zero_spot_balances <'py > (& self , py : Python <'py >) -> PyResult <&'py PyAny > { let client = self . inner . clone () ; pyo3_asyncio :: tokio :: future_into_py (py , async move { client . get_non_zero_spot_balances () . await }) } } # [doc = " Create the Python module for gateio"] pub fn create_module (py : Python) -> PyResult <& PyModule > { let m = PyModule :: new (py , "gateio") ?; Ok (m) }