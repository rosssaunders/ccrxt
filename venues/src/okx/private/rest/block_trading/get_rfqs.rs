use serde::{Deserialize, Serialize};

use crate::okx::{EndpointType, RestResult, RfqState, private_client::RestClient};

/// Endpoint URL for getting RFQs
const GET_RFQS_ENDPOINT: &str = "api/v5/rfq/rfqs";

/// Request parameters for getting RFQs
#[derive(Debug, Clone, Default, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct GetRfqsRequest {
    /// RFQ ID created by system
    #[serde(rename = "rfqId", skip_serializing_if = "Option::is_none")]
    pub rfq_id: Option<String>,

    /// Client-supplied RFQ ID
    #[serde(rename = "clRfqId", skip_serializing_if = "Option::is_none")]
    pub cl_rfq_id: Option<String>,

    /// RFQ state filter
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<RfqState>,

    /// Pagination of data to return records earlier than the requested rfqId
    #[serde(skip_serializing_if = "Option::is_none")]
    pub before: Option<String>,

    /// Pagination of data to return records newer than the requested rfqId
    #[serde(skip_serializing_if = "Option::is_none")]
    pub after: Option<String>,

    /// Begin time (Unix timestamp in milliseconds)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub begin: Option<String>,

    /// End time (Unix timestamp in milliseconds)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<String>,

    /// Number of results per request (max 100, default 100)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<String>,
}

/// RFQ information
#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RfqInfo {
    /// The timestamp the RFQ was created (Unix timestamp in milliseconds)
    #[serde(rename = "cTime")]
    pub c_time: String,

    /// The timestamp the RFQ was last updated (Unix timestamp in milliseconds)
    #[serde(rename = "uTime")]
    pub u_time: String,

    /// The status of the RFQ
    pub state: RfqState,

    /// The list of counterparties traderCode the RFQ was broadcast to
    pub counterparties: Vec<String>,

    /// The timestamp the RFQ expires (Unix timestamp in milliseconds)
    #[serde(rename = "validUntil")]
    pub valid_until: String,

    /// Client-supplied RFQ ID
    #[serde(rename = "clRfqId")]
    pub cl_rfq_id: String,

    /// RFQ tag
    pub tag: String,

    /// Whether the RFQ can be partially filled
    pub allow_partial_execution: bool,

    /// A unique identifier of taker
    #[serde(rename = "traderCode")]
    pub trader_code: String,

    /// The unique identifier of the RFQ generated by system
    #[serde(rename = "rfqId")]
    pub rfq_id: String,

    /// Array of objects containing each leg of the RFQ
    pub legs: Vec<serde_json::Value>, // Using generic Value for now due to complex nested structure
}

impl RestClient {
    /// Get RFQs
    ///
    /// Retrieve RFQs that the user has sent or received.
    ///
    /// [docs](https://www.okx.com/docs-v5/en/#block-trading-rest-api-get-rfqs)
    ///
    /// Rate limit: 5 requests per 2 seconds
    ///
    /// # Arguments
    /// * `request` - The RFQs request parameters
    ///
    /// # Returns
    /// Response containing RFQ information
    pub async fn get_rfqs(&self, request: GetRfqsRequest) -> RestResult<RfqInfo> {
        self.send_get_request(
            GET_RFQS_ENDPOINT,
            Some(&request),
            EndpointType::PrivateAccount,
        )
        .await
    }
}

#[cfg(test)]
mod tests {
    use serde_json::json;

    use super::*;
    use crate::okx::response::ApiResponse;

    #[test]
    fn test_get_rfqs_request_builder() {
        let request = GetRfqsRequest {
            rfq_id: None,
            cl_rfq_id: None,
            state: Some(RfqState::Active),
            before: None,
            after: None,
            begin: None,
            end: None,
            limit: Some("50".to_string()),
        };

        let json = serde_json::to_string(&request).unwrap();
        assert!(json.contains("\"state\":\"active\""));
        assert!(json.contains("\"limit\":\"50\""));
        assert!(!json.contains("\"rfqId\""));
    }

    #[test]
    fn test_get_rfqs_request_with_ids() {
        let request = GetRfqsRequest {
            rfq_id: Some("rfq_123".to_string()),
            cl_rfq_id: Some("client_123".to_string()),
            state: None,
            before: None,
            after: None,
            begin: None,
            end: None,
            limit: None,
        };

        let json = serde_json::to_string(&request).unwrap();
        assert!(json.contains("\"rfqId\":\"rfq_123\""));
        assert!(json.contains("\"clRfqId\":\"client_123\""));
    }

    #[test]
    fn test_rfq_info_deserialization() {
        let rfq_json = json!({
            "cTime": "1597026383085",
            "uTime": "1597026383085",
            "state": "active",
            "counterparties": ["MM001", "MM002"],
            "validUntil": "1597026503085",
            "clRfqId": "client_rfq_123",
            "tag": "test_tag",
            "allowPartialExecution": false,
            "traderCode": "TAKER001",
            "rfqId": "rfq_123456",
            "legs": [
                {
                    "instId": "BTC-USDT-SWAP",
                    "tdMode": "cross",
                    "ccy": "USDT",
                    "sz": "10",
                    "side": "buy"
                }
            ]
        });

        let rfq_info: RfqInfo = serde_json::from_value(rfq_json).unwrap();
        assert_eq!(rfq_info.c_time, "1597026383085");
        assert_eq!(rfq_info.state, RfqState::Active);
        assert_eq!(rfq_info.counterparties.len(), 2);
        assert_eq!(rfq_info.counterparties[0], "MM001");
        assert!(!rfq_info.allow_partial_execution);
        assert_eq!(rfq_info.trader_code, "TAKER001");
        assert_eq!(rfq_info.rfq_id, "rfq_123456");
        assert_eq!(rfq_info.legs.len(), 1);
    }

    #[test]
    fn test_get_rfqs_response_structure() {
        let response_json = json!({
            "code": "0",
            "msg": "",
            "data": [
                {
                    "cTime": "1597026383085",
                    "uTime": "1597026383085",
                    "state": "filled",
                    "counterparties": ["MM001"],
                    "validUntil": "1597026503085",
                    "clRfqId": "client_rfq_123",
                    "tag": "test_tag",
                    "allowPartialExecution": true,
                    "traderCode": "TAKER001",
                    "rfqId": "rfq_123456",
                    "legs": []
                }
            ]
        });

        let response: ApiResponse<RfqInfo> = serde_json::from_value(response_json).unwrap();
        assert_eq!(response.code, "0");
        assert_eq!(response.data.len(), 1);
        assert_eq!(response.data[0].state, RfqState::Filled);
        assert!(response.data[0].allow_partial_execution);
    }

    #[test]
    fn test_get_rfqs_request_empty() {
        let request = GetRfqsRequest::default();
        let json = serde_json::to_string(&request).unwrap();
        // Should serialize to empty object
        assert_eq!(json, "{}");
    }
}
