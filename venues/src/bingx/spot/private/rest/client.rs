use std::{borrow::Cow, sync::Arc};

use hmac::{Hmac, Mac};
use rest::{
    HttpClient,
    http_client::{Method as HttpMethod, RequestBuilder},
    secrets::ExposableSecret,
};
use serde::{Serialize, de::DeserializeOwned};
use sha2::Sha256;

use crate::bingx::spot::{ApiResponse, EndpointType, Errors, RateLimiter, RestResult};

/// Private REST client for BingX exchange
///
/// This client handles all private API endpoints that require authentication.
/// It provides automatic rate limiting, error handling, and request signing.
pub struct RestClient {
    /// The base URL for the BingX private REST API (e.g., "https://open-api.bingx.com")
    ///
    /// This is used as the prefix for all endpoint requests.
    pub base_url: Cow<'static, str>,

    /// The underlying HTTP client used for making requests.
    ///
    /// This is reused for connection pooling and performance.
    pub http_client: Arc<dyn HttpClient>,

    /// The rate limiter used to manage request rates and prevent hitting API limits.
    ///
    /// This is used to ensure compliance with BingX's rate limits for private endpoints.
    pub rate_limiter: RateLimiter,

    /// The encrypted API key.
    pub(crate) api_key: Box<dyn ExposableSecret>,

    /// The encrypted API secret.
    pub(crate) api_secret: Box<dyn ExposableSecret>,
}

impl RestClient {
    /// Create a new BingX private REST client
    ///
    /// # Arguments
    /// * `api_key` - The API key for authentication
    /// * `api_secret` - The API secret for signing requests
    /// * `base_url` - The base URL for the BingX API (e.g., "https://open-api.bingx.com")
    /// * `http_client` - The HTTP client to use for requests
    /// * `rate_limiter` - The rate limiter to use for request throttling
    ///
    /// # Returns
    /// A new RestClient instance
    pub fn new(
        api_key: Box<dyn ExposableSecret>,
        api_secret: Box<dyn ExposableSecret>,
        base_url: &str,
        http_client: Arc<dyn HttpClient>,
        rate_limiter: RateLimiter,
    ) -> Self {
        Self {
            api_key,
            api_secret,
            base_url: Cow::Owned(base_url.to_string()),
            http_client,
            rate_limiter,
        }
    }

    /// Sign a request using HMAC-SHA256
    ///
    /// BingX uses HMAC-SHA256 for request signing. The signature is generated by:
    /// 1. Create query string from parameters (without sorting)
    /// 2. Sign with HMAC SHA256 using the API secret
    /// 3. Return as hex string
    ///
    /// # Arguments
    /// * `query_string` - The query string to sign
    ///
    /// # Returns
    /// A result containing the signature as a hex string or an error
    pub fn sign_request(&self, query_string: &str) -> Result<String, Errors> {
        // Sign with HMAC SHA256
        let api_secret = self.api_secret.expose_secret();
        let mut mac = Hmac::<Sha256>::new_from_slice(api_secret.as_bytes())
            .map_err(|_| Errors::InvalidApiKey)?;
        mac.update(query_string.as_bytes());

        // Return as hex string
        Ok(hex::encode(mac.finalize().into_bytes()))
    }

    /// Build a signed URL (querystring) for BingX private endpoints
    fn build_signed_url<P>(&self, endpoint: &str, params: Option<&P>) -> Result<String, Errors>
    where
        P: Serialize + ?Sized,
    {
        // Build query string with required parameters
        let timestamp = chrono::Utc::now().timestamp_millis();
        let mut query_params = vec![("timestamp".to_string(), timestamp.to_string())];

        // Add optional parameters
        if let Some(params) = params {
            let params_str = serde_urlencoded::to_string(params)
                .map_err(|e| Errors::Error(format!("Failed to serialize parameters: {e}")))?;

            if !params_str.is_empty() {
                for (key, value) in serde_urlencoded::from_str::<Vec<(String, String)>>(&params_str)
                    .map_err(|e| Errors::Error(format!("Failed to parse parameters: {e}")))?
                {
                    query_params.push((key, value));
                }
            }
        }

        // Build query string for signing
        let query_string = query_params
            .iter()
            .map(|(k, v)| format!("{k}={v}"))
            .collect::<Vec<_>>()
            .join("&");

        // Generate signature
        let signature = self.sign_request(&query_string)?;
        query_params.push(("signature".to_string(), signature));

        // Build final query string
        let final_query_string = query_params
            .iter()
            .map(|(k, v)| format!("{k}={v}"))
            .collect::<Vec<_>>()
            .join("&");

        Ok(format!("{}{}?{}", self.base_url, endpoint, final_query_string))
    }

    /// Execute a prepared request and parse ApiResponse wrapper
    async fn execute<T>(
        &self,
        method: HttpMethod,
        url: String,
        endpoint_type: EndpointType,
    ) -> RestResult<T>
    where
        T: DeserializeOwned,
    {
        // Check rate limits
        self.rate_limiter
            .check_limits(endpoint_type.clone())
            .await
            .map_err(|e| Errors::RateLimitExceeded(e.to_string()))?;

        // Build the request
        let api_key = self.api_key.expose_secret();
        let request = RequestBuilder::new(method, url)
            .header("X-BX-APIKEY", &api_key)
            .header("Content-Type", "application/json")
            .build();

        // Send request
        let response = self.http_client.execute(request).await
            .map_err(|e| Errors::NetworkError(format!("HTTP request failed: {e}")))?;

        // Record the request for rate limiting
        self.rate_limiter.increment_request(endpoint_type).await;

        // Get response text
        let response_text = response.text()
            .map_err(|e| Errors::NetworkError(format!("Failed to read response: {e}")))?;

        // Check if request was successful
        if response.status == 200 {
            // Parse the API response wrapper
            let api_response: ApiResponse<T> = serde_json::from_str(&response_text)?;

            // Check if the API returned an error
            if api_response.code != 0 {
                return Err(Errors::ApiError {
                    code: api_response.code,
                    msg: api_response.msg,
                });
            }

            // Return the unwrapped data
            match api_response.data {
                Some(data) => Ok(data),
                None => Err(Errors::ParseError("Response data is missing".to_string())),
            }
        } else {
            // Try to parse as BingX error response
            if let Ok(error_response) =
                serde_json::from_str::<crate::bingx::spot::ErrorResponse>(&response_text)
            {
                Err(Errors::from(error_response))
            } else {
                Err(Errors::Error(format!("HTTP {}: {}", response.status, response_text)))
            }
        }
    }

    /// Send a signed GET request (high-performance)
    ///
    /// # Arguments
    /// * `endpoint` - The API endpoint path
    /// * `params` - Parameters to include in the request
    /// * `endpoint_type` - The endpoint type for rate limiting
    ///
    /// # Returns
    /// A result containing the parsed response data or an error
    pub async fn send_get_signed_request<T, P>(
        &self,
        endpoint: &str,
        params: P,
        endpoint_type: EndpointType,
    ) -> RestResult<T>
    where
        T: DeserializeOwned,
        P: Serialize,
    {
        let url = self.build_signed_url(endpoint, Some(&params))?;
        self.execute(HttpMethod::Get, url, endpoint_type).await
    }

    /// Send a signed POST request (high-performance)
    ///
    /// # Arguments
    /// * `endpoint` - The API endpoint path
    /// * `params` - Parameters to include in the request
    /// * `endpoint_type` - The endpoint type for rate limiting
    ///
    /// # Returns
    /// A result containing the parsed response data or an error
    pub async fn send_post_signed_request<T, P>(
        &self,
        endpoint: &str,
        params: P,
        endpoint_type: EndpointType,
    ) -> RestResult<T>
    where
        T: DeserializeOwned,
        P: Serialize,
    {
        let url = self.build_signed_url(endpoint, Some(&params))?;
        self.execute(HttpMethod::Post, url, endpoint_type).await
    }

    /// Send a signed PUT request (high-performance)
    ///
    /// # Arguments
    /// * `endpoint` - The API endpoint path
    /// * `params` - Parameters to include in the request
    /// * `endpoint_type` - The endpoint type for rate limiting
    ///
    /// # Returns
    /// A result containing the parsed response data or an error
    pub async fn send_put_signed_request<T, P>(
        &self,
        endpoint: &str,
        params: P,
        endpoint_type: EndpointType,
    ) -> RestResult<T>
    where
        T: DeserializeOwned,
        P: Serialize,
    {
        let url = self.build_signed_url(endpoint, Some(&params))?;
        self.execute(HttpMethod::Put, url, endpoint_type).await
    }

    /// Send a signed DELETE request (high-performance)
    ///
    /// # Arguments
    /// * `endpoint` - The API endpoint path
    /// * `params` - Parameters to include in the request
    /// * `endpoint_type` - The endpoint type for rate limiting
    ///
    /// # Returns
    /// A result containing the parsed response data or an error
    pub async fn send_delete_signed_request<T, P>(
        &self,
        endpoint: &str,
        params: P,
        endpoint_type: EndpointType,
    ) -> RestResult<T>
    where
        T: DeserializeOwned,
        P: Serialize,
    {
        let url = self.build_signed_url(endpoint, Some(&params))?;
        self.execute(HttpMethod::Delete, url, endpoint_type).await
    }
}

#[cfg(test)]
mod tests {
    use rest::secrets::ExposableSecret;

    use super::*;

    #[derive(Debug)]
    struct TestSecret {
        secret: String,
    }

    impl TestSecret {
        fn new(secret: String) -> Self {
            Self { secret }
        }
    }

    impl ExposableSecret for TestSecret {
        fn expose_secret(&self) -> String {
            self.secret.clone()
        }
    }

    #[test]
    fn test_private_client_creation() {
        let api_key = Box::new(TestSecret::new("test_key".to_string())) as Box<dyn ExposableSecret>;
        let api_secret =
            Box::new(TestSecret::new("test_secret".to_string())) as Box<dyn ExposableSecret>;
        let http_client = std::sync::Arc::new(rest::native::NativeHttpClient::default());
        let rate_limiter = RateLimiter::new();

        let rest_client = RestClient::new(
            api_key,
            api_secret,
            "https://open-api.bingx.com",
            http_client,
            rate_limiter,
        );

        assert_eq!(rest_client.base_url, "https://open-api.bingx.com");
    }

    #[test]
    fn test_sign_request() {
        let api_key = Box::new(TestSecret::new("test_key".to_string())) as Box<dyn ExposableSecret>;
        let api_secret =
            Box::new(TestSecret::new("test_secret".to_string())) as Box<dyn ExposableSecret>;
        let http_client = std::sync::Arc::new(rest::native::NativeHttpClient::default());
        let rate_limiter = RateLimiter::new();

        let rest_client = RestClient::new(
            api_key,
            api_secret,
            "https://open-api.bingx.com",
            http_client,
            rate_limiter,
        );

        let query_string = "timestamp=1234567890";
        let signature = rest_client.sign_request(query_string).unwrap();

        // Signature should be a valid hex string
        assert!(signature.chars().all(|c| c.is_ascii_hexdigit()));
        assert!(!signature.is_empty());
    }
}
