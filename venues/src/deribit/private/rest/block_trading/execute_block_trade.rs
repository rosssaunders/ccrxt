use serde::{Deserialize, Serialize};

use crate::deribit::{EndpointType, JsonRpcResult, PrivateRestClient, RestResult};

/// REST API endpoint constant
const EXECUTE_BLOCK_TRADE_ENDPOINT: &str = "private/execute_block_trade";

/// Role enum for execute block trade requests
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Role {
    /// Maker role
    Maker,
    /// Taker role
    Taker,
}

/// Direction enum for trade direction
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Direction {
    /// Buy direction
    Buy,
    /// Sell direction
    Sell,
}

/// Trade data for a single trade in the block trade request
#[derive(Debug, Clone, Serialize)]
pub struct Trade {
    /// Instrument name
    pub instrument_name: String,

    /// Price for trade
    pub price: f64,

    /// Trade size (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amount: Option<f64>,

    /// Direction of trade from the maker perspective
    pub direction: Direction,
}

/// Request parameters for execute block trade
#[derive(Debug, Clone, Serialize)]
pub struct ExecuteBlockTradeRequest {
    /// Timestamp, shared with other party (milliseconds since the UNIX epoch)
    pub timestamp: i64,

    /// Nonce, shared with other party
    pub nonce: String,

    /// Describes if user wants to be maker or taker of trades
    pub role: Role,

    /// List of trades for block trade
    pub trades: Vec<Trade>,

    /// Signature of block trade generated by private/verify_block_trade_method
    pub counterparty_signature: String,
}

/// Executed trade data returned by the execute block trade endpoint
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutedTrade {
    /// Unique (per currency) trade identifier
    pub trade_id: String,

    /// Direction of the "tick" (0 = Plus Tick, 1 = Zero-Plus Tick, 2 = Minus Tick, 3 = Zero-Minus Tick)
    pub tick_direction: i32,

    /// Currency, i.e "BTC", "ETH", "USDC"
    pub fee_currency: String,

    /// true if user order was created with API
    pub api: bool,

    /// Advanced type of user order: "usd" or "implv" (only for options; omitted if not applicable)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub advanced: Option<String>,

    /// Id of the user order (maker or taker), i.e. subscriber's order id that took part in the trade
    pub order_id: String,

    /// Describes what was role of users order: "M" when it was maker order, "T" when it was taker order
    pub liquidity: String,

    /// true if user order is post-only
    pub post_only: bool,

    /// Direction: buy, or sell
    pub direction: String,

    /// Trade size in contract units (optional, may be absent in historical trades)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contracts: Option<f64>,

    /// true if user order is MMP
    pub mmp: bool,

    /// User's fee in units of the specified fee_currency
    pub fee: f64,

    /// QuoteID of the user order (optional, present only for orders placed with private/mass_quote)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quote_id: Option<String>,

    /// Index Price at the moment of trade
    pub index_price: f64,

    /// User defined label (presented only when previously set for order by user)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,

    /// Block trade id - when trade was part of a block trade
    #[serde(skip_serializing_if = "Option::is_none")]
    pub block_trade_id: Option<String>,

    /// Price in base currency
    pub price: f64,

    /// Optional field containing combo instrument name if the trade is a combo trade
    #[serde(skip_serializing_if = "Option::is_none")]
    pub combo_id: Option<String>,

    /// Always null
    pub matching_id: Option<String>,

    /// Order type: "limit", "market", or "liquidation"
    pub order_type: String,

    /// Profit and loss in base currency
    pub profit_loss: f64,

    /// The timestamp of the trade (milliseconds since the UNIX epoch)
    pub timestamp: i64,

    /// Option implied volatility for the price (Option only)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iv: Option<f64>,

    /// Order state: "open", "filled", "rejected", "cancelled", "untriggered" or "archive" (if order was archived)
    pub state: String,

    /// Underlying price for implied volatility calculations (Options only)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub underlying_price: Option<f64>,

    /// ID of the Block RFQ quote - when trade was part of the Block RFQ
    #[serde(skip_serializing_if = "Option::is_none")]
    pub block_rfq_quote_id: Option<i64>,

    /// QuoteSet of the user order (optional, present only for orders placed with private/mass_quote)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quote_set_id: Option<String>,

    /// Mark Price at the moment of trade
    pub mark_price: f64,

    /// ID of the Block RFQ - when trade was part of the Block RFQ
    #[serde(skip_serializing_if = "Option::is_none")]
    pub block_rfq_id: Option<i64>,

    /// Optional field containing combo trade identifier if the trade is a combo trade
    #[serde(skip_serializing_if = "Option::is_none")]
    pub combo_trade_id: Option<i64>,

    /// true if user order is reduce-only
    pub reduce_only: bool,

    /// Trade amount. For perpetual and inverse futures the amount is in USD units. For options and linear futures and it is the underlying base currency coin.
    pub amount: f64,

    /// Optional field (only for trades caused by liquidation): "M" when maker side of trade was under liquidation, "T" when taker side was under liquidation, "MT" when both sides of trade were under liquidation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub liquidation: Option<String>,

    /// The sequence number of the trade within instrument
    pub trade_seq: i64,

    /// true if user order is marked by the platform as a risk reducing order (can apply only to orders placed by PM users)
    pub risk_reducing: bool,

    /// Unique instrument identifier
    pub instrument_name: String,

    /// Optional field containing leg trades if trade is a combo trade (present when querying for only combo trades and in combo_trades events)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub legs: Option<Vec<serde_json::Value>>,
}

/// Result data for execute block trade response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecuteBlockTradeResult {
    /// The name of the application that executed the block trade on behalf of the user (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub app_name: Option<String>,

    /// Block trade id
    pub id: String,

    /// The timestamp (milliseconds since the Unix epoch)
    pub timestamp: i64,

    /// Array of executed trades
    pub trades: Vec<ExecutedTrade>,
}

/// Response for execute block trade endpoint
pub type ExecuteBlockTradeResponse = JsonRpcResult<ExecuteBlockTradeResult>;

impl PrivateRestClient {
    /// Execute block trade
    ///
    /// Creates block trade. The whole request have to be exact the same as in
    /// `private/verify_block_trade`, only role field should be set appropriately - it
    /// basically means that both sides have to agree on the same timestamp, nonce, trades
    /// fields and server will assure that role field is different between sides (each party
    /// accepted own role).
    ///
    /// Using the same timestamp and nonce by both sides in `private/verify_block_trade`
    /// assures that even if unintentionally both sides execute given block trade with
    /// valid counterparty_signature, the given block trade will be executed only once.
    ///
    /// [docs](https://docs.deribit.com/v2/#private-execute_block_trade)
    ///
    /// Rate limit: Matching engine endpoint (tier-based limits)
    /// Scope: block_trade:read_write
    ///
    /// # Arguments
    /// * `timestamp` - Timestamp, shared with other party (milliseconds since the UNIX epoch)
    /// * `nonce` - Nonce, shared with other party
    /// * `role` - Describes if user wants to be maker or taker of trades
    /// * `trades` - List of trades for block trade
    /// * `counterparty_signature` - Signature of block trade generated by private/verify_block_trade_method
    ///
    /// # Returns
    /// Result with executed block trade details
    pub async fn execute_block_trade(
        &self,
        request: ExecuteBlockTradeRequest,
    ) -> RestResult<ExecuteBlockTradeResponse> {
        self.send_signed_request(
            EXECUTE_BLOCK_TRADE_ENDPOINT,
            &request,
            EndpointType::MatchingEngine,
        )
        .await
    }
}

#[cfg(test)]
mod tests {
    use std::sync::Arc;

    use rest::secrets::SecretString;
    /// REST API endpoint constant
    use serde_json::{Value, json};

    use super::*;
    use crate::deribit::{AccountTier, credentials::Credentials};

    #[test]
    fn test_role_serialization() {
        let maker = Role::Maker;
        let taker = Role::Taker;

        let maker_json = serde_json::to_string(&maker).unwrap();
        let taker_json = serde_json::to_string(&taker).unwrap();

        assert_eq!(maker_json, "\"maker\"");
        assert_eq!(taker_json, "\"taker\"");
    }

    #[test]
    fn test_role_deserialization() {
        let maker: Role = serde_json::from_str("\"maker\"").unwrap();
        let taker: Role = serde_json::from_str("\"taker\"").unwrap();

        matches!(maker, Role::Maker);
        matches!(taker, Role::Taker);
    }

    #[test]
    fn test_direction_serialization() {
        let buy = Direction::Buy;
        let sell = Direction::Sell;

        let buy_json = serde_json::to_string(&buy).unwrap();
        let sell_json = serde_json::to_string(&sell).unwrap();

        assert_eq!(buy_json, "\"buy\"");
        assert_eq!(sell_json, "\"sell\"");
    }

    #[test]
    fn test_direction_deserialization() {
        let buy: Direction = serde_json::from_str("\"buy\"").unwrap();
        let sell: Direction = serde_json::from_str("\"sell\"").unwrap();

        matches!(buy, Direction::Buy);
        matches!(sell, Direction::Sell);
    }

    #[test]
    fn test_trade_serialization_minimal() {
        let trade = Trade {
            instrument_name: "BTCUSD-PERP".to_string(),
            price: 50000.0,
            amount: None,
            direction: Direction::Buy,
        };

        let json_str = serde_json::to_string(&trade).unwrap();
        let json_value: Value = serde_json::from_str(&json_str).unwrap();

        assert_eq!(json_value.get("instrument_name").unwrap(), "BTCUSD-PERP");
        assert_eq!(json_value.get("price").unwrap(), 50000.0);
        assert!(json_value.get("amount").is_none());
        assert_eq!(json_value.get("direction").unwrap(), "buy");
    }

    #[test]
    fn test_trade_serialization_full() {
        let trade = Trade {
            instrument_name: "ETHUSD-PERP".to_string(),
            price: 3000.0,
            amount: Some(1.5),
            direction: Direction::Sell,
        };

        let json_str = serde_json::to_string(&trade).unwrap();
        let json_value: Value = serde_json::from_str(&json_str).unwrap();

        assert_eq!(json_value.get("instrument_name").unwrap(), "ETHUSD-PERP");
        assert_eq!(json_value.get("price").unwrap(), 3000.0);
        assert_eq!(json_value.get("amount").unwrap(), 1.5);
        assert_eq!(json_value.get("direction").unwrap(), "sell");
    }

    #[test]
    fn test_request_serialization() {
        let trades = vec![
            Trade {
                instrument_name: "BTCUSD-PERP".to_string(),
                price: 50000.0,
                amount: Some(0.1),
                direction: Direction::Buy,
            },
            Trade {
                instrument_name: "ETHUSD-PERP".to_string(),
                price: 3000.0,
                amount: Some(1.0),
                direction: Direction::Sell,
            },
        ];

        let request = ExecuteBlockTradeRequest {
            timestamp: 1672738134824,
            nonce: "test_nonce_123".to_string(),
            role: Role::Maker,
            trades,
            counterparty_signature: "test_signature_456".to_string(),
        };

        let json_str = serde_json::to_string(&request).unwrap();
        let json_value: Value = serde_json::from_str(&json_str).unwrap();

        assert_eq!(json_value.get("timestamp").unwrap(), 1672738134824i64);
        assert_eq!(json_value.get("nonce").unwrap(), "test_nonce_123");
        assert_eq!(json_value.get("role").unwrap(), "maker");
        assert_eq!(
            json_value.get("counterparty_signature").unwrap(),
            "test_signature_456"
        );
        assert!(json_value.get("trades").unwrap().is_array());
        assert_eq!(
            json_value.get("trades").unwrap().as_array().unwrap().len(),
            2
        );
    }

    #[test]
    fn test_response_deserialization() {
        let response_json = json!({
            "id": 1,
            "jsonrpc": "2.0",
            "result": {
                "app_name": "Test App",
                "id": "block_trade_123",
                "timestamp": 1672738134824i64,
                "trades": [
                    {
                        "trade_id": "trade_001",
                        "tick_direction": 0,
                        "fee_currency": "BTC",
                        "api": true,
                        "order_id": "order_123",
                        "liquidity": "M",
                        "post_only": false,
                        "direction": "buy",
                        "mmp": false,
                        "fee": 0.0005,
                        "index_price": 50000.0,
                        "price": 50000.0,
                        "matching_id": null,
                        "order_type": "limit",
                        "profit_loss": 0.0,
                        "timestamp": 1672738134824i64,
                        "state": "filled",
                        "mark_price": 50000.0,
                        "reduce_only": false,
                        "amount": 0.1,
                        "trade_seq": 1,
                        "risk_reducing": false,
                        "instrument_name": "BTCUSD-PERP"
                    }
                ]
            }
        });

        let response: ExecuteBlockTradeResponse = serde_json::from_value(response_json).unwrap();

        assert_eq!(response.id, 1);
        assert_eq!(response.jsonrpc, "2.0");
        assert_eq!(response.result.app_name, Some("Test App".to_string()));
        assert_eq!(response.result.id, "block_trade_123");
        assert_eq!(response.result.timestamp, 1672738134824);
        assert_eq!(response.result.trades.len(), 1);

        let trade = &response.result.trades[0];
        assert_eq!(trade.trade_id, "trade_001");
        assert_eq!(trade.instrument_name, "BTCUSD-PERP");
        assert_eq!(trade.direction, "buy");
        assert_eq!(trade.price, 50000.0);
    }

    #[tokio::test]
    async fn test_execute_block_trade_method_exists() {
        // Test that the method exists and compiles without needing to call it
        let credentials = Credentials {
            api_key: SecretString::from("test_key".to_string()),
            api_secret: SecretString::from("test_secret".to_string()),
        };
        let http_client = Arc::new(rest::native::NativeHttpClient::default());
        let rate_limiter = crate::deribit::RateLimiter::new(AccountTier::Tier4);

        let rest_client = PrivateRestClient::new(
            credentials,
            "https://test.deribit.com",
            rate_limiter,
            http_client,
        );

        // Test that we can get a function reference to the method
        let _ = PrivateRestClient::execute_block_trade;

        // Verify the client exists
        let _ = &rest_client;

        println!("execute_block_trade method is accessible and properly typed");
    }
}
